{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst os = require('os');\n\nconst tar = require('tar');\n\nconst path = require('path');\n\nconst util = require('util');\n\nconst stream = require('stream');\n\nconst crypto = require('crypto');\n\nconst log = require('npmlog');\n\nconst semver = require('semver');\n\nconst fetch = require('make-fetch-happen');\n\nconst processRelease = require('./process-release');\n\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install(fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release); // Determine which node dev files version we are installing\n\n  log.verbose('install', 'input version string %j', release.version);\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version);\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n  } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n    }\n\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n    return;\n  } // flatten version into String\n\n\n  log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n  const devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n\n    try {\n      await fs.promises.stat(devDir);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version);\n\n        try {\n          return await go();\n        } catch (err) {\n          return rollback(err);\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err);\n      }\n\n      throw err;\n    }\n\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n    const installVersionFile = path.resolve(devDir, 'installVersion');\n    let installVersion = 0;\n\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii');\n      installVersion = parseInt(ver, 10) || 0;\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n\n    log.verbose('got \"installVersion\"', installVersion);\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling');\n\n      try {\n        return await go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n\n    log.verbose('install', 'version is good');\n  } else {\n    try {\n      return await go();\n    } catch (err) {\n      return rollback(err);\n    }\n  }\n\n  async function go() {\n    log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n    try {\n      const created = await fs.promises.mkdir(devDir, {\n        recursive: true\n      });\n\n      if (created) {\n        log.verbose('created nodedir', created);\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err);\n      }\n\n      throw err;\n    } // now download the node tarball\n\n\n    const tarPath = gyp.opts.tarball;\n    let extractCount = 0;\n    const contentShasums = {};\n    const expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n\n    function isValid(path) {\n      const isValid = valid(path);\n\n      if (isValid) {\n        log.verbose('extracted file from tarball', path);\n        extractCount++;\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path);\n      }\n\n      return isValid;\n    } // download the tarball and extract!\n\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      });\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl);\n\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n        }\n\n        await streamPipeline(res.body, // content checksum\n        new ShaSum((_, checksum) => {\n          const filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        }), tar.extract({\n          strip: 1,\n          cwd: devDir,\n          filter: isValid\n        }));\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n        }\n\n        throw err;\n      }\n    } // invoked after the tarball has finished being extracted\n\n\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball');\n    }\n\n    log.verbose('tarball', 'done parsing tarball');\n    const installVersionPath = path.resolve(devDir, 'installVersion');\n    await Promise.all([// need to download node.lib\n    ...(win ? downloadNodeLib() : []), // write the \"installVersion\" file\n    fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'), // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n    ...(!tarPath || win ? [downloadShasums()] : [])]);\n    log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n      }\n    }\n\n    async function downloadShasums() {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n      log.verbose('checksum url', release.shasumsUrl);\n      const res = await download(gyp, release.shasumsUrl);\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`);\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/);\n\n        if (items.length !== 2) {\n          return;\n        } // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n\n        const name = items[1].replace(/^\\.\\//, '');\n        expectShasums[name] = items[0];\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums));\n    }\n\n    function downloadNodeLib() {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n      const archs = ['ia32', 'x64', 'arm64'];\n      return archs.map(async arch => {\n        const dir = path.resolve(devDir, arch);\n        const targetLibPath = path.resolve(dir, release.name + '.lib');\n        const {\n          libUrl,\n          libPath\n        } = release[arch];\n        const name = `${arch} ${release.name}.lib`;\n        log.verbose(name, 'dir', dir);\n        log.verbose(name, 'url', libUrl);\n        await fs.promises.mkdir(dir, {\n          recursive: true\n        });\n        log.verbose('streaming', name, 'to:', targetLibPath);\n        const res = await download(gyp, libUrl);\n\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`);\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`);\n          }\n\n          return;\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`);\n        }\n\n        return streamPipeline(res.body, new ShaSum((_, checksum) => {\n          contentShasums[libPath] = checksum;\n          log.verbose('content checksum', libPath, checksum);\n        }), fs.createWriteStream(targetLibPath));\n      });\n    } // downloadNodeLib()\n\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n\n  function valid(file) {\n    // header files\n    const extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n\n  async function rollback(err) {\n    log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n    await util.promisify(gyp.commands.remove)([release.versionDir]);\n    throw err;\n  }\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n\n  async function eaccesFallback(err) {\n    const noretry = '--node_gyp_internal_noretry';\n\n    if (argv.indexOf(noretry) !== -1) {\n      throw err;\n    }\n\n    const tmpdir = os.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    let userString = '';\n\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`;\n    } catch (e) {}\n\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n\n    return util.promisify(gyp.commands.install)([noretry].concat(argv));\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n\n    callback(null, chunk);\n  }\n\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n\n    callback();\n  }\n\n}\n\nasync function download(gyp, url) {\n  log.http('GET', url);\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  };\n  const cafile = gyp.opts.cafile;\n\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile);\n  }\n\n  const res = await fetch(url, requestOpts);\n  log.http(res.status, res.url);\n  return res;\n}\n\nasync function readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8');\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\n\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"sources":["/home/dom/Videos/FlyM/node_modules/node-gyp/lib/install.js"],"names":["fs","require","os","tar","path","util","stream","crypto","log","semver","fetch","processRelease","win","process","platform","streamPipeline","promisify","pipeline","install","gyp","argv","release","version","verbose","Error","lt","prerelease","opts","nodedir","versionDir","devDir","resolve","ensure","promises","stat","err","code","go","rollback","eaccesFallback","installVersionFile","installVersion","ver","readFile","parseInt","package","created","mkdir","recursive","tarPath","tarball","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","res","download","tarballUrl","status","body","ShaSum","_","checksum","filename","basename","trim","installVersionPath","Promise","all","downloadNodeLib","writeFile","downloadShasums","JSON","stringify","k","shasumsUrl","line","text","split","items","length","name","replace","archs","map","arch","dir","targetLibPath","libUrl","libPath","warn","createWriteStream","extname","commands","remove","noretry","indexOf","tmpdir","userString","userInfo","username","e","todo","push","args","concat","Transform","constructor","callback","_callback","_digester","createHash","_transform","chunk","update","_flush","digest","url","http","requestOpts","headers","Connection","proxy","noProxy","noproxy","cafile","ca","readCAFile","re","match","module","exports","then","bind","undefined","test","usage"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst tar = require('tar')\nconst path = require('path')\nconst util = require('util')\nconst stream = require('stream')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst fetch = require('make-fetch-happen')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst streamPipeline = util.promisify(stream.pipeline)\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install (fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release)\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version)\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version)\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead')\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    try {\n      await fs.promises.stat(devDir)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version)\n        try {\n          return await go()\n        } catch (err) {\n          return rollback(err)\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n      throw err\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n    const installVersionFile = path.resolve(devDir, 'installVersion')\n    let installVersion = 0\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii')\n      installVersion = parseInt(ver, 10) || 0\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion)\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling')\n      try {\n        return await go()\n      } catch (err) {\n        return rollback(err)\n      }\n    }\n    log.verbose('install', 'version is good')\n  } else {\n    try {\n      return await go()\n    } catch (err) {\n      return rollback(err)\n    }\n  }\n\n  async function go () {\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, { recursive: true })\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n\n      throw err\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball\n    let extractCount = 0\n    const contentShasums = {}\n    const expectShasums = {}\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid (path) {\n      const isValid = valid(path)\n      if (isValid) {\n        log.verbose('extracted file from tarball', path)\n        extractCount++\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path)\n      }\n      return isValid\n    }\n\n    // download the tarball and extract!\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      })\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl)\n\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`)\n        }\n\n        await streamPipeline(\n          res.body,\n          // content checksum\n          new ShaSum((_, checksum) => {\n            const filename = path.basename(release.tarballUrl).trim()\n            contentShasums[filename] = checksum\n            log.verbose('content checksum', filename, checksum)\n          }),\n          tar.extract({\n            strip: 1,\n            cwd: devDir,\n            filter: isValid\n          })\n        )\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.')\n        }\n        throw err\n      }\n    }\n\n    // invoked after the tarball has finished being extracted\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball')\n    }\n\n    log.verbose('tarball', 'done parsing tarball')\n\n    const installVersionPath = path.resolve(devDir, 'installVersion')\n    await Promise.all([\n      // need to download node.lib\n      ...(win ? downloadNodeLib() : []),\n      // write the \"installVersion\" file\n      fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n      // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n      ...(!tarPath || win ? [downloadShasums()] : [])\n    ])\n\n    log.verbose('download contents checksum', JSON.stringify(contentShasums))\n    // check content shasums\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k])\n      }\n    }\n\n    async function downloadShasums () {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n      log.verbose('checksum url', release.shasumsUrl)\n\n      const res = await download(gyp, release.shasumsUrl)\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`)\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/)\n        if (items.length !== 2) {\n          return\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '')\n        expectShasums[name] = items[0]\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums))\n    }\n\n    function downloadNodeLib () {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n      const archs = ['ia32', 'x64', 'arm64']\n      return archs.map(async (arch) => {\n        const dir = path.resolve(devDir, arch)\n        const targetLibPath = path.resolve(dir, release.name + '.lib')\n        const { libUrl, libPath } = release[arch]\n        const name = `${arch} ${release.name}.lib`\n        log.verbose(name, 'dir', dir)\n        log.verbose(name, 'url', libUrl)\n\n        await fs.promises.mkdir(dir, { recursive: true })\n        log.verbose('streaming', name, 'to:', targetLibPath)\n\n        const res = await download(gyp, libUrl)\n\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`)\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`)\n          }\n          return\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`)\n        }\n\n        return streamPipeline(\n          res.body,\n          new ShaSum((_, checksum) => {\n            contentShasums[libPath] = checksum\n            log.verbose('content checksum', libPath, checksum)\n          }),\n          fs.createWriteStream(targetLibPath)\n        )\n      })\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    const extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  async function rollback (err) {\n    log.warn('install', 'got an error, rolling back install')\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir])\n    throw err\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback (err) {\n    const noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      throw err\n    }\n    const tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    let userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv))\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor (callback) {\n    super()\n    this._callback = callback\n    this._digester = crypto.createHash('sha256')\n  }\n\n  _transform (chunk, _, callback) {\n    this._digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush (callback) {\n    this._callback(null, this._digester.digest('hex'))\n    callback()\n  }\n}\n\nasync function download (gyp, url) {\n  log.http('GET', url)\n\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  }\n\n  const cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile)\n  }\n\n  const res = await fetch(url, requestOpts)\n  log.http(res.status, res.url)\n\n  return res\n}\n\nasync function readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8')\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback)\n}\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"]},"metadata":{},"sourceType":"script"}
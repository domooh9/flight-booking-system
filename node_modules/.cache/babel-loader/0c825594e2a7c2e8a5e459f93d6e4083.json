{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    throw: verb(1),\n    return: verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fireSessionUpdateEventsIfNecessary = exports.setFrontToken = exports.getFrontToken = exports.setAntiCSRF = exports.saveLastAccessTokenUpdate = exports.getTokenForHeaderAuth = exports.setToken = exports.getStorageNameForToken = exports.getLocalSessionState = exports.onInvalidClaimResponse = exports.onTokenUpdate = exports.onUnauthorisedResponse = exports.FrontToken = exports.AntiCsrfToken = void 0;\n/* Copyright (c) 2020, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\nvar processState_1 = require(\"./processState\");\n\nvar version_1 = require(\"./version\");\n\nvar utils_1 = require(\"./utils\");\n\nvar cookieHandler_1 = require(\"./utils/cookieHandler\");\n\nvar windowHandler_1 = require(\"./utils/windowHandler\");\n\nvar lockFactory_1 = require(\"./utils/lockFactory\");\n\nvar logger_1 = require(\"./logger\");\n\nvar AntiCsrfToken =\n/** @class */\nfunction () {\n  function AntiCsrfToken() {}\n\n  AntiCsrfToken.getToken = function (associatedAccessTokenUpdate) {\n    return __awaiter(this, void 0, void 0, function () {\n      var antiCsrf;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: called\");\n\n            if (associatedAccessTokenUpdate === undefined) {\n              AntiCsrfToken.tokenInfo = undefined;\n              (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning undefined\");\n              return [2\n              /*return*/\n              , undefined];\n            }\n\n            if (!(AntiCsrfToken.tokenInfo === undefined)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , getAntiCSRFToken()];\n\n          case 1:\n            antiCsrf = _a.sent();\n\n            if (antiCsrf === null) {\n              (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning undefined\");\n              return [2\n              /*return*/\n              , undefined];\n            }\n\n            AntiCsrfToken.tokenInfo = {\n              antiCsrf: antiCsrf,\n              associatedAccessTokenUpdate: associatedAccessTokenUpdate\n            };\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            if (!(AntiCsrfToken.tokenInfo.associatedAccessTokenUpdate !== associatedAccessTokenUpdate)) return [3\n            /*break*/\n            , 4]; // csrf token has changed.\n\n            AntiCsrfToken.tokenInfo = undefined;\n            return [4\n            /*yield*/\n            , AntiCsrfToken.getToken(associatedAccessTokenUpdate)];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 4:\n            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning: \" + AntiCsrfToken.tokenInfo.antiCsrf);\n            return [2\n            /*return*/\n            , AntiCsrfToken.tokenInfo.antiCsrf];\n        }\n      });\n    });\n  };\n\n  AntiCsrfToken.removeToken = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.removeToken: called\");\n            AntiCsrfToken.tokenInfo = undefined;\n            return [4\n            /*yield*/\n            , setAntiCSRF(undefined)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AntiCsrfToken.setItem = function (associatedAccessTokenUpdate, antiCsrf) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (associatedAccessTokenUpdate === undefined) {\n              AntiCsrfToken.tokenInfo = undefined;\n              return [2\n              /*return*/\n              ];\n            }\n\n            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.setItem: called\");\n            return [4\n            /*yield*/\n            , setAntiCSRF(antiCsrf)];\n\n          case 1:\n            _a.sent();\n\n            AntiCsrfToken.tokenInfo = {\n              antiCsrf: antiCsrf,\n              associatedAccessTokenUpdate: associatedAccessTokenUpdate\n            };\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return AntiCsrfToken;\n}();\n\nexports.AntiCsrfToken = AntiCsrfToken; // Note: We do not store this in memory because another tab may have\n// modified this value, and if so, we may not know about it in this tab\n\nvar FrontToken =\n/** @class */\nfunction () {\n  function FrontToken() {}\n\n  FrontToken.getTokenInfo = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var frontToken, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: called\");\n            return [4\n            /*yield*/\n            , getFrontToken()];\n\n          case 1:\n            frontToken = _a.sent();\n            if (!(frontToken === null)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , getLocalSessionState(false)];\n\n          case 2:\n            if (!(_a.sent().status === \"EXISTS\")) return [3\n            /*break*/\n            , 4]; // this means that the id refresh token has been set, so we must\n            // wait for this to be set or removed\n\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              FrontToken.waiters.push(resolve);\n            })];\n\n          case 3:\n            // this means that the id refresh token has been set, so we must\n            // wait for this to be set or removed\n            _a.sent();\n\n            return [2\n            /*return*/\n            , FrontToken.getTokenInfo()];\n\n          case 4:\n            return [2\n            /*return*/\n            , undefined];\n\n          case 5:\n            response = parseFrontToken(frontToken);\n            (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning ate: \" + response.ate);\n            (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning uid: \" + response.uid);\n            (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning up: \" + response.up);\n            return [2\n            /*return*/\n            , response];\n        }\n      });\n    });\n  };\n\n  FrontToken.removeToken = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"FrontToken.removeToken: called\");\n            return [4\n            /*yield*/\n            , setFrontToken(undefined)];\n\n          case 1:\n            _a.sent();\n\n            FrontToken.waiters.forEach(function (f) {\n              return f(undefined);\n            });\n            FrontToken.waiters = [];\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  FrontToken.setItem = function (frontToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // We update the refresh attempt info here as well, since this means that we've updated the session in some way\n            // This could be both by a refresh call or if the access token was updated in a custom endpoint\n            // By saving every time the access token has been updated, we cause an early retry if\n            // another request has failed with a 401 with the previous access token and the token still exists.\n            // Check the start and end of onUnauthorisedResponse\n            // As a side-effect we reload the anti-csrf token to check if it was changed by another tab.\n            return [4\n            /*yield*/\n            , saveLastAccessTokenUpdate()];\n\n          case 1:\n            // We update the refresh attempt info here as well, since this means that we've updated the session in some way\n            // This could be both by a refresh call or if the access token was updated in a custom endpoint\n            // By saving every time the access token has been updated, we cause an early retry if\n            // another request has failed with a 401 with the previous access token and the token still exists.\n            // Check the start and end of onUnauthorisedResponse\n            // As a side-effect we reload the anti-csrf token to check if it was changed by another tab.\n            _a.sent();\n\n            if (frontToken === \"remove\") {\n              return [2\n              /*return*/\n              , FrontToken.removeToken()];\n            }\n\n            (0, logger_1.logDebugMessage)(\"FrontToken.setItem: called\");\n            return [4\n            /*yield*/\n            , setFrontToken(frontToken)];\n\n          case 2:\n            _a.sent();\n\n            FrontToken.waiters.forEach(function (f) {\n              return f(undefined);\n            });\n            FrontToken.waiters = [];\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  FrontToken.doesTokenExists = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var frontToken;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getFrontTokenFromCookie()];\n\n          case 1:\n            frontToken = _a.sent();\n            return [2\n            /*return*/\n            , frontToken !== null];\n        }\n      });\n    });\n  }; // these are waiters for when the idRefreshToken has been set, but this token has\n  // not yet been set. Once this token is set or removed, the waiters are resolved.\n\n\n  FrontToken.waiters = [];\n  return FrontToken;\n}();\n\nexports.FrontToken = FrontToken;\n/**\n * @class AuthHttpRequest\n * @description wrapper for common http methods.\n */\n\nvar AuthHttpRequest =\n/** @class */\nfunction () {\n  function AuthHttpRequest() {}\n\n  AuthHttpRequest.init = function (config, recipeImpl) {\n    (0, logger_1.logDebugMessage)(\"init: called\");\n    (0, logger_1.logDebugMessage)(\"init: Input apiBasePath: \" + config.apiBasePath);\n    (0, logger_1.logDebugMessage)(\"init: Input apiDomain: \" + config.apiDomain);\n    (0, logger_1.logDebugMessage)(\"init: Input autoAddCredentials: \" + config.autoAddCredentials);\n    (0, logger_1.logDebugMessage)(\"init: Input sessionTokenBackendDomain: \" + config.sessionTokenBackendDomain);\n    (0, logger_1.logDebugMessage)(\"init: Input isInIframe: \" + config.isInIframe);\n    (0, logger_1.logDebugMessage)(\"init: Input sessionExpiredStatusCode: \" + config.sessionExpiredStatusCode);\n    (0, logger_1.logDebugMessage)(\"init: Input sessionTokenFrontendDomain: \" + config.sessionTokenFrontendDomain);\n    (0, logger_1.logDebugMessage)(\"init: Input tokenTransferMethod: \" + config.tokenTransferMethod);\n    var fetchedWindow = windowHandler_1.default.getReferenceOrThrow().windowHandler.getWindowUnsafe();\n    AuthHttpRequest.env = fetchedWindow === undefined || fetchedWindow.fetch === undefined ? global : fetchedWindow;\n    AuthHttpRequest.refreshTokenUrl = config.apiDomain + config.apiBasePath + \"/session/refresh\";\n    AuthHttpRequest.signOutUrl = config.apiDomain + config.apiBasePath + \"/signout\";\n    AuthHttpRequest.rid = \"session\";\n    AuthHttpRequest.config = config;\n\n    if (AuthHttpRequest.env.__supertokensOriginalFetch === undefined) {\n      (0, logger_1.logDebugMessage)(\"init: __supertokensOriginalFetch is undefined\"); // this block contains code that is run just once per page load..\n      // all items in this block are attached to the global env so that\n      // even if the init function is called more than once (maybe across JS scripts),\n      // things will not get created multiple times.\n\n      AuthHttpRequest.env.__supertokensOriginalFetch = AuthHttpRequest.env.fetch.bind(AuthHttpRequest.env);\n      AuthHttpRequest.env.__supertokensSessionRecipe = recipeImpl;\n      AuthHttpRequest.env.fetch = AuthHttpRequest.env.__supertokensSessionRecipe.addFetchInterceptorsAndReturnModifiedFetch({\n        originalFetch: AuthHttpRequest.env.__supertokensOriginalFetch,\n        userContext: {}\n      });\n\n      AuthHttpRequest.env.__supertokensSessionRecipe.addXMLHttpRequestInterceptor({\n        userContext: {}\n      });\n    }\n\n    AuthHttpRequest.recipeImpl = AuthHttpRequest.env.__supertokensSessionRecipe;\n    AuthHttpRequest.initCalled = true;\n  };\n\n  var _a;\n\n  _a = AuthHttpRequest;\n  AuthHttpRequest.initCalled = false;\n\n  AuthHttpRequest.doRequest = function (httpCall, config, url) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var doNotDoInterception, origHeaders, accessToken, returnObj, preRequestLSS, clonedHeaders, configWithAntiCsrf, antiCsrfToken, transferMethod, response, retry, postRequestIdToken;\n      return __generator(_a, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!AuthHttpRequest.initCalled) {\n              throw Error(\"init function not called\");\n            }\n\n            (0, logger_1.logDebugMessage)(\"doRequest: start of fetch interception\");\n            doNotDoInterception = false;\n\n            try {\n              doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, AuthHttpRequest.config.apiDomain, AuthHttpRequest.config.sessionTokenBackendDomain) || url !== undefined && typeof url.url === \"string\" && // this is because url can be an object like {method: ..., url: ...}\n              !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url.url, AuthHttpRequest.config.apiDomain, AuthHttpRequest.config.sessionTokenBackendDomain);\n            } catch (err) {\n              if (err.message === \"Please provide a valid domain name\") {\n                (0, logger_1.logDebugMessage)(\"doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin\"); // .origin gives the port as well..\n\n                doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), AuthHttpRequest.config.apiDomain, AuthHttpRequest.config.sessionTokenBackendDomain);\n              } else {\n                throw err;\n              }\n            }\n\n            (0, logger_1.logDebugMessage)(\"doRequest: Value of doNotDoInterception: \" + doNotDoInterception);\n            if (!doNotDoInterception) return [3\n            /*break*/\n            , 2];\n            (0, logger_1.logDebugMessage)(\"doRequest: Returning without interception\");\n            return [4\n            /*yield*/\n            , httpCall(config)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _b.sent()];\n\n          case 2:\n            origHeaders = new Headers(config !== undefined && config.headers !== undefined ? config.headers : url.headers);\n            if (!origHeaders.has(\"Authorization\")) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , getTokenForHeaderAuth(\"access\")];\n\n          case 3:\n            accessToken = _b.sent();\n\n            if (accessToken !== undefined && origHeaders.get(\"Authorization\") === \"Bearer \".concat(accessToken)) {\n              // We are ignoring the Authorization header set by the user in this case, because it would cause issues\n              // If we do not ignore this, then this header would be used even if the request is being retried after a refresh, even though it contains an outdated access token.\n              // This causes an infinite refresh loop.\n              (0, logger_1.logDebugMessage)(\"doRequest: Removing Authorization from user provided headers because it contains our access token\");\n              origHeaders.delete(\"Authorization\");\n            }\n\n            _b.label = 4;\n\n          case 4:\n            (0, logger_1.logDebugMessage)(\"doRequest: Interception started\");\n            processState_1.ProcessState.getInstance().addState(processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST);\n            _b.label = 5;\n\n          case 5:\n            _b.trys.push([5,, 19, 24]);\n\n            returnObj = undefined;\n            _b.label = 6;\n\n          case 6:\n            if (!true) return [3\n            /*break*/\n            , 18];\n            return [4\n            /*yield*/\n            , getLocalSessionState(true)];\n\n          case 7:\n            preRequestLSS = _b.sent();\n            clonedHeaders = new Headers(origHeaders);\n            configWithAntiCsrf = __assign(__assign({}, config), {\n              headers: clonedHeaders\n            });\n            if (!(preRequestLSS.status === \"EXISTS\")) return [3\n            /*break*/\n            , 9];\n            return [4\n            /*yield*/\n            , AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n\n          case 8:\n            antiCsrfToken = _b.sent();\n\n            if (antiCsrfToken !== undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding anti-csrf token to request\");\n              clonedHeaders.set(\"anti-csrf\", antiCsrfToken);\n            }\n\n            _b.label = 9;\n\n          case 9:\n            if (AuthHttpRequest.config.autoAddCredentials) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding credentials include\");\n\n              if (configWithAntiCsrf === undefined) {\n                configWithAntiCsrf = {\n                  credentials: \"include\"\n                };\n              } else if (configWithAntiCsrf.credentials === undefined) {\n                configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                  credentials: \"include\"\n                });\n              }\n            } // adding rid for anti-csrf protection: Anti-csrf via custom header\n\n\n            if (!clonedHeaders.has(\"rid\")) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding rid header: anti-csrf\");\n              clonedHeaders.set(\"rid\", \"anti-csrf\");\n            } else {\n              (0, logger_1.logDebugMessage)(\"doRequest: rid header was already there in request\");\n            }\n\n            transferMethod = AuthHttpRequest.config.tokenTransferMethod;\n            (0, logger_1.logDebugMessage)(\"doRequest: Adding st-auth-mode header: \" + transferMethod);\n            clonedHeaders.set(\"st-auth-mode\", transferMethod);\n            return [4\n            /*yield*/\n            , setAuthorizationHeaderIfRequired(clonedHeaders)];\n\n          case 10:\n            _b.sent();\n\n            (0, logger_1.logDebugMessage)(\"doRequest: Making user's http call\");\n            return [4\n            /*yield*/\n            , httpCall(configWithAntiCsrf)];\n\n          case 11:\n            response = _b.sent();\n            (0, logger_1.logDebugMessage)(\"doRequest: User's http call ended\");\n            return [4\n            /*yield*/\n            , saveTokensFromHeaders(response)];\n\n          case 12:\n            _b.sent();\n\n            fireSessionUpdateEventsIfNecessary(preRequestLSS.status === \"EXISTS\", response.status, response.headers.get(\"front-token\"));\n            if (!(response.status === AuthHttpRequest.config.sessionExpiredStatusCode)) return [3\n            /*break*/\n            , 14];\n            (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n            return [4\n            /*yield*/\n            , onUnauthorisedResponse(preRequestLSS)];\n\n          case 13:\n            retry = _b.sent();\n\n            if (retry.result !== \"RETRY\") {\n              (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n              returnObj = retry.error !== undefined ? retry.error : response;\n              return [3\n              /*break*/\n              , 18];\n            }\n\n            (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n            return [3\n            /*break*/\n            , 17];\n\n          case 14:\n            if (!(response.status === AuthHttpRequest.config.invalidClaimStatusCode)) return [3\n            /*break*/\n            , 16];\n            return [4\n            /*yield*/\n            , onInvalidClaimResponse(response)];\n\n          case 15:\n            _b.sent();\n\n            _b.label = 16;\n\n          case 16:\n            return [2\n            /*return*/\n            , response];\n\n          case 17:\n            return [3\n            /*break*/\n            , 6];\n\n          case 18:\n            // if it comes here, means we breaked. which happens only if we have logged out.\n            return [2\n            /*return*/\n            , returnObj];\n\n          case 19:\n            return [4\n            /*yield*/\n            , getLocalSessionState(false)];\n\n          case 20:\n            postRequestIdToken = _b.sent();\n            if (!(postRequestIdToken.status === \"NOT_EXISTS\")) return [3\n            /*break*/\n            , 23];\n            (0, logger_1.logDebugMessage)(\"doRequest: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n            return [4\n            /*yield*/\n            , AntiCsrfToken.removeToken()];\n\n          case 21:\n            _b.sent();\n\n            return [4\n            /*yield*/\n            , FrontToken.removeToken()];\n\n          case 22:\n            _b.sent();\n\n            _b.label = 23;\n\n          case 23:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 24:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AuthHttpRequest.attemptRefreshingSession = function () {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var preRequestLSS, refresh;\n      return __generator(_a, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!AuthHttpRequest.initCalled) {\n              throw Error(\"init function not called\");\n            }\n\n            return [4\n            /*yield*/\n            , getLocalSessionState(false)];\n\n          case 1:\n            preRequestLSS = _b.sent();\n            return [4\n            /*yield*/\n            , onUnauthorisedResponse(preRequestLSS)];\n\n          case 2:\n            refresh = _b.sent();\n\n            if (refresh.result === \"API_ERROR\") {\n              throw refresh.error;\n            }\n\n            return [2\n            /*return*/\n            , refresh.result === \"RETRY\"];\n        }\n      });\n    });\n  };\n\n  return AuthHttpRequest;\n}();\n\nexports.default = AuthHttpRequest;\nvar LAST_ACCESS_TOKEN_UPDATE = \"st-last-access-token-update\";\nvar REFRESH_TOKEN_NAME = \"st-refresh-token\";\nvar ACCESS_TOKEN_NAME = \"st-access-token\";\nvar ANTI_CSRF_NAME = \"sAntiCsrf\";\nvar FRONT_TOKEN_NAME = \"sFrontToken\";\n/**\n * @description attempts to call the refresh token API each time we are sure the session has expired, or it throws an error or,\n * or the ID_COOKIE_NAME has changed value -> which may mean that we have a new set of tokens.\n */\n\nfunction onUnauthorisedResponse(preRequestLSS) {\n  return __awaiter(this, void 0, void 0, function () {\n    var lock, postLockLSS, headers, antiCsrfToken, transferMethod, preAPIResult, response, isUnauthorised, error_1, postRequestLSS;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , lockFactory_1.default.getReferenceOrThrow().lockFactory()];\n\n        case 1:\n          lock = _b.sent();\n          _b.label = 2;\n\n        case 2:\n          if (!true) return [3\n          /*break*/\n          , 24];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: trying to acquire lock\");\n          return [4\n          /*yield*/\n          , lock.acquireLock(\"REFRESH_TOKEN_USE\", 1000)];\n\n        case 3:\n          if (!_b.sent()) return [3\n          /*break*/\n          , 22];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: lock acquired\");\n          _b.label = 4;\n\n        case 4:\n          _b.trys.push([4, 14, 16, 22]);\n\n          return [4\n          /*yield*/\n          , getLocalSessionState(false)];\n\n        case 5:\n          postLockLSS = _b.sent();\n\n          if (postLockLSS.status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Not refreshing because local session state is NOT_EXISTS\"); // if it comes here, it means a request was made thinking\n            // that the session exists, but it doesn't actually exist.\n\n            AuthHttpRequest.config.onHandleEvent({\n              action: \"UNAUTHORISED\",\n              sessionExpiredOrRevoked: false,\n              userContext: {}\n            });\n            return [2\n            /*return*/\n            , {\n              result: \"SESSION_EXPIRED\"\n            }];\n          }\n\n          if (postLockLSS.status !== preRequestLSS.status || postLockLSS.status === \"EXISTS\" && preRequestLSS.status === \"EXISTS\" && postLockLSS.lastAccessTokenUpdate !== preRequestLSS.lastAccessTokenUpdate) {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Retrying early because pre and post id refresh tokens don't match\"); // means that some other process has already called this API and succeeded. so we need to call it again\n\n            return [2\n            /*return*/\n            , {\n              result: \"RETRY\"\n            }];\n          }\n\n          headers = new Headers();\n          if (!(preRequestLSS.status === \"EXISTS\")) return [3\n          /*break*/\n          , 7];\n          return [4\n          /*yield*/\n          , AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n\n        case 6:\n          antiCsrfToken = _b.sent();\n\n          if (antiCsrfToken !== undefined) {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Adding anti-csrf token to refresh API call\");\n            headers.set(\"anti-csrf\", antiCsrfToken);\n          }\n\n          _b.label = 7;\n\n        case 7:\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Adding rid and fdi-versions to refresh call header\");\n          headers.set(\"rid\", AuthHttpRequest.rid);\n          headers.set(\"fdi-version\", version_1.supported_fdi.join(\",\"));\n          transferMethod = AuthHttpRequest.config.tokenTransferMethod;\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Adding st-auth-mode header: \" + transferMethod);\n          headers.set(\"st-auth-mode\", transferMethod);\n          return [4\n          /*yield*/\n          , setAuthorizationHeaderIfRequired(headers, true)];\n\n        case 8:\n          _b.sent();\n\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Calling refresh pre API hook\");\n          return [4\n          /*yield*/\n          , AuthHttpRequest.config.preAPIHook({\n            action: \"REFRESH_SESSION\",\n            requestInit: {\n              method: \"post\",\n              credentials: \"include\",\n              headers: headers\n            },\n            url: AuthHttpRequest.refreshTokenUrl,\n            userContext: {}\n          })];\n\n        case 9:\n          preAPIResult = _b.sent();\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Making refresh call\");\n          return [4\n          /*yield*/\n          , AuthHttpRequest.env.__supertokensOriginalFetch(preAPIResult.url, preAPIResult.requestInit)];\n\n        case 10:\n          response = _b.sent();\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Refresh call ended\");\n          return [4\n          /*yield*/\n          , saveTokensFromHeaders(response)];\n\n        case 11:\n          _b.sent();\n\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Refresh status code is: \" + response.status);\n          isUnauthorised = response.status === AuthHttpRequest.config.sessionExpiredStatusCode; // There is a case where the FE thinks the session is valid, but backend doesn't get the tokens.\n          // In this event, session expired error will be thrown and the frontend should remove this token\n\n          if (isUnauthorised && response.headers.get(\"front-token\") === null) {\n            FrontToken.setItem(\"remove\");\n          }\n\n          fireSessionUpdateEventsIfNecessary(preRequestLSS.status === \"EXISTS\", response.status, isUnauthorised && response.headers.get(\"front-token\") === null ? \"remove\" : response.headers.get(\"front-token\"));\n\n          if (response.status >= 300) {\n            throw response;\n          }\n\n          return [4\n          /*yield*/\n          , AuthHttpRequest.config.postAPIHook({\n            action: \"REFRESH_SESSION\",\n            fetchResponse: response.clone(),\n            requestInit: preAPIResult.requestInit,\n            url: preAPIResult.url,\n            userContext: {}\n          })];\n\n        case 12:\n          _b.sent();\n\n          return [4\n          /*yield*/\n          , getLocalSessionState(false)];\n\n        case 13:\n          if (_b.sent().status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: local session doesn't exist, so returning session expired\"); // The execution should never come here.. but just in case.\n            // removed by server during refresh. So we logout\n            // we do not send \"UNAUTHORISED\" event here because\n            // this is a result of the refresh API returning a session expiry, which\n            // means that the frontend did not know for sure that the session existed\n            // in the first place.\n\n            return [2\n            /*return*/\n            , {\n              result: \"SESSION_EXPIRED\"\n            }];\n          }\n\n          AuthHttpRequest.config.onHandleEvent({\n            action: \"REFRESH_SESSION\",\n            userContext: {}\n          });\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Sending RETRY signal\");\n          return [2\n          /*return*/\n          , {\n            result: \"RETRY\"\n          }];\n\n        case 14:\n          error_1 = _b.sent();\n          return [4\n          /*yield*/\n          , getLocalSessionState(false)];\n\n        case 15:\n          if (_b.sent().status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: local session doesn't exist, so returning session expired\"); // removed by server.\n            // we do not send \"UNAUTHORISED\" event here because\n            // this is a result of the refresh API returning a session expiry, which\n            // means that the frontend did not know for sure that the session existed\n            // in the first place.\n\n            return [2\n            /*return*/\n            , {\n              result: \"SESSION_EXPIRED\",\n              error: error_1\n            }];\n          }\n\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: sending API_ERROR\");\n          return [2\n          /*return*/\n          , {\n            result: \"API_ERROR\",\n            error: error_1\n          }];\n\n        case 16:\n          return [4\n          /*yield*/\n          , lock.releaseLock(\"REFRESH_TOKEN_USE\")];\n\n        case 17:\n          _b.sent();\n\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Released lock\");\n          return [4\n          /*yield*/\n          , getLocalSessionState(false)];\n\n        case 18:\n          if (!(_b.sent().status === \"NOT_EXISTS\")) return [3\n          /*break*/\n          , 21];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n          return [4\n          /*yield*/\n          , AntiCsrfToken.removeToken()];\n\n        case 19:\n          _b.sent();\n\n          return [4\n          /*yield*/\n          , FrontToken.removeToken()];\n\n        case 20:\n          _b.sent();\n\n          _b.label = 21;\n\n        case 21:\n          return [7\n          /*endfinally*/\n          ];\n\n        case 22:\n          return [4\n          /*yield*/\n          , getLocalSessionState(false)];\n\n        case 23:\n          postRequestLSS = _b.sent();\n\n          if (postRequestLSS.status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: lock acquired failed and local session doesn't exist, so sending SESSION_EXPIRED\"); // removed by server. So we logout\n\n            return [2\n            /*return*/\n            , {\n              result: \"SESSION_EXPIRED\"\n            }];\n          } else {\n            if (postRequestLSS.status !== preRequestLSS.status || postRequestLSS.status === \"EXISTS\" && preRequestLSS.status === \"EXISTS\" && postRequestLSS.lastAccessTokenUpdate !== preRequestLSS.lastAccessTokenUpdate) {\n              (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: lock acquired failed and retrying early because pre and post id refresh tokens don't match\");\n              return [2\n              /*return*/\n              , {\n                result: \"RETRY\"\n              }];\n            } // here we try to call the API again since we probably failed to acquire lock and nothing has changed.\n\n          }\n\n          return [3\n          /*break*/\n          , 2];\n\n        case 24:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nexports.onUnauthorisedResponse = onUnauthorisedResponse;\n\nfunction onTokenUpdate() {\n  (0, logger_1.logDebugMessage)(\"onTokenUpdate: firing ACCESS_TOKEN_PAYLOAD_UPDATED event\");\n  AuthHttpRequest.config.onHandleEvent({\n    action: \"ACCESS_TOKEN_PAYLOAD_UPDATED\",\n    userContext: {}\n  });\n}\n\nexports.onTokenUpdate = onTokenUpdate;\n\nfunction onInvalidClaimResponse(response) {\n  return __awaiter(this, void 0, void 0, function () {\n    var claimValidationErrors, _b;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          _c.trys.push([0, 2,, 3]);\n\n          return [4\n          /*yield*/\n          , AuthHttpRequest.recipeImpl.getInvalidClaimsFromResponse({\n            response: response,\n            userContext: {}\n          })];\n\n        case 1:\n          claimValidationErrors = _c.sent(); // This shouldn't be undefined normally, but since we can't be certain about the shape of the response object so we check it like this.\n          // It could still be something else, but chance of that happening by accident is really low.\n\n          if (claimValidationErrors) {\n            AuthHttpRequest.config.onHandleEvent({\n              action: \"API_INVALID_CLAIM\",\n              claimValidationErrors: claimValidationErrors,\n              userContext: {}\n            });\n          }\n\n          return [3\n          /*break*/\n          , 3];\n\n        case 2:\n          _b = _c.sent();\n          return [3\n          /*break*/\n          , 3];\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nexports.onInvalidClaimResponse = onInvalidClaimResponse; // if tryRefresh is true & this token doesn't exist, we try and refresh the session\n// else we return undefined.\n\nfunction getLocalSessionState(tryRefresh) {\n  return __awaiter(this, void 0, void 0, function () {\n    var lastAccessTokenUpdate, frontTokenExists, response, res;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"getLocalSessionState: called\");\n          return [4\n          /*yield*/\n          , getFromCookies(LAST_ACCESS_TOKEN_UPDATE)];\n\n        case 1:\n          lastAccessTokenUpdate = _b.sent();\n          return [4\n          /*yield*/\n          , FrontToken.doesTokenExists()];\n\n        case 2:\n          frontTokenExists = _b.sent();\n          if (!(frontTokenExists && lastAccessTokenUpdate !== undefined)) return [3\n          /*break*/\n          , 3];\n          (0, logger_1.logDebugMessage)(\"getLocalSessionState: returning EXISTS since both frontToken and lastAccessTokenUpdate exists\");\n          return [2\n          /*return*/\n          , {\n            status: \"EXISTS\",\n            lastAccessTokenUpdate: lastAccessTokenUpdate\n          }];\n\n        case 3:\n          if (!lastAccessTokenUpdate) return [3\n          /*break*/\n          , 4];\n          (0, logger_1.logDebugMessage)(\"getLocalSessionState: returning NOT_EXISTS since frontToken was cleared but lastAccessTokenUpdate exists\");\n          return [2\n          /*return*/\n          , {\n            status: \"NOT_EXISTS\"\n          }];\n\n        case 4:\n          response = {\n            status: \"MAY_EXIST\"\n          };\n          if (!tryRefresh) return [3\n          /*break*/\n          , 7];\n          (0, logger_1.logDebugMessage)(\"getLocalSessionState: trying to refresh\");\n          return [4\n          /*yield*/\n          , onUnauthorisedResponse(response)];\n\n        case 5:\n          res = _b.sent();\n\n          if (res.result !== \"RETRY\") {\n            (0, logger_1.logDebugMessage)(\"getLocalSessionState: return NOT_EXISTS in case error from backend\" + res.result); // in case the backend is not working, we treat it as the session not existing...\n\n            return [2\n            /*return*/\n            , {\n              status: \"NOT_EXISTS\"\n            }];\n          }\n\n          (0, logger_1.logDebugMessage)(\"getLocalSessionState: Retrying post refresh\");\n          return [4\n          /*yield*/\n          , getLocalSessionState(tryRefresh)];\n\n        case 6:\n          return [2\n          /*return*/\n          , _b.sent()];\n\n        case 7:\n          (0, logger_1.logDebugMessage)(\"getLocalSessionState: returning: \" + response.status);\n          return [2\n          /*return*/\n          , response];\n      }\n    });\n  });\n}\n\nexports.getLocalSessionState = getLocalSessionState;\n\nfunction getStorageNameForToken(tokenType) {\n  switch (tokenType) {\n    case \"access\":\n      return ACCESS_TOKEN_NAME;\n\n    case \"refresh\":\n      return REFRESH_TOKEN_NAME;\n  }\n}\n\nexports.getStorageNameForToken = getStorageNameForToken;\n\nfunction setToken(tokenType, value) {\n  var name = getStorageNameForToken(tokenType);\n\n  if (value !== \"\") {\n    (0, logger_1.logDebugMessage)(\"setToken: saved \".concat(tokenType, \" token into cookies\")); // We save the tokens with a 100-year expiration time\n\n    return storeInCookies(name, value, Date.now() + 3153600000);\n  } else {\n    (0, logger_1.logDebugMessage)(\"setToken: cleared \".concat(tokenType, \" token from cookies\"));\n    return storeInCookies(name, value, 0);\n  }\n}\n\nexports.setToken = setToken;\n\nfunction storeInCookies(name, value, expiry) {\n  var expires = \"Fri, 31 Dec 9999 23:59:59 GMT\";\n\n  if (expiry !== Number.MAX_SAFE_INTEGER) {\n    // We should respect the storage expirations set by the backend, even though tokens will also be checked elsewhere.\n    // We check them locally in case of front-token, and on the backend enforces the validity period for access and refresh tokens.\n    expires = new Date(expiry).toUTCString();\n  }\n\n  var domain = AuthHttpRequest.config.sessionTokenFrontendDomain;\n\n  if (domain === \"localhost\" || domain === windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getHostName()) {\n    // since some browsers ignore cookies with domain set to localhost\n    // see https://github.com/supertokens/supertokens-website/issues/25\n    return cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(name, \"=\").concat(value, \";expires=\").concat(expires, \";path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"));\n  } else {\n    return cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(name, \"=\").concat(value, \";expires=\").concat(expires, \";domain=\").concat(domain, \";path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"));\n  }\n}\n\nfunction getTokenForHeaderAuth(tokenType) {\n  return __awaiter(this, void 0, void 0, function () {\n    var name;\n    return __generator(this, function (_b) {\n      name = getStorageNameForToken(tokenType);\n      return [2\n      /*return*/\n      , getFromCookies(name)];\n    });\n  });\n}\n\nexports.getTokenForHeaderAuth = getTokenForHeaderAuth;\n\nfunction getFromCookies(name) {\n  return __awaiter(this, void 0, void 0, function () {\n    var value, _b, parts, last;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          _b = \"; \";\n          return [4\n          /*yield*/\n          , cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()];\n\n        case 1:\n          value = _b + _c.sent();\n          parts = value.split(\"; \" + name + \"=\");\n\n          if (parts.length >= 2) {\n            last = parts.pop();\n\n            if (last !== undefined) {\n              return [2\n              /*return*/\n              , last.split(\";\").shift()];\n            }\n          }\n\n          return [2\n          /*return*/\n          , undefined];\n      }\n    });\n  });\n}\n\nfunction setAuthorizationHeaderIfRequired(clonedHeaders, addRefreshToken) {\n  if (addRefreshToken === void 0) {\n    addRefreshToken = false;\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var accessToken, refreshToken;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"setTokenHeaders: adding existing tokens as header\");\n          return [4\n          /*yield*/\n          , getTokenForHeaderAuth(\"access\")];\n\n        case 1:\n          accessToken = _b.sent();\n          return [4\n          /*yield*/\n          , getTokenForHeaderAuth(\"refresh\")];\n\n        case 2:\n          refreshToken = _b.sent(); // We don't always need the refresh token because that's only required by the refresh call\n          // Still, we only add the Authorization header if both are present, because we are planning to add an option to expose the\n          // access token to the frontend while using cookie based auth - so that users can get the access token to use\n\n          if (accessToken !== undefined && refreshToken !== undefined) {\n            // the Headers class normalizes header names so we don't have to worry about casing\n            if (clonedHeaders.has(\"Authorization\")) {\n              (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding\");\n            } else {\n              (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: added authorization header\");\n              clonedHeaders.set(\"Authorization\", \"Bearer \".concat(addRefreshToken ? refreshToken : accessToken));\n            }\n          } else {\n            (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: token for header based auth not found\");\n          }\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction saveTokensFromHeaders(response) {\n  return __awaiter(this, void 0, void 0, function () {\n    var refreshToken, accessToken, frontToken, antiCsrfToken, tok;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Saving updated tokens from the response headers\");\n          refreshToken = response.headers.get(\"st-refresh-token\");\n          if (!(refreshToken !== null)) return [3\n          /*break*/\n          , 2];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new refresh token\");\n          return [4\n          /*yield*/\n          , setToken(\"refresh\", refreshToken)];\n\n        case 1:\n          _b.sent();\n\n          _b.label = 2;\n\n        case 2:\n          accessToken = response.headers.get(\"st-access-token\");\n          if (!(accessToken !== null)) return [3\n          /*break*/\n          , 4];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new access token\");\n          return [4\n          /*yield*/\n          , setToken(\"access\", accessToken)];\n\n        case 3:\n          _b.sent();\n\n          _b.label = 4;\n\n        case 4:\n          frontToken = response.headers.get(\"front-token\");\n          if (!(frontToken !== null)) return [3\n          /*break*/\n          , 6];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Setting sFrontToken: \" + frontToken);\n          return [4\n          /*yield*/\n          , FrontToken.setItem(frontToken)];\n\n        case 5:\n          _b.sent();\n\n          _b.label = 6;\n\n        case 6:\n          antiCsrfToken = response.headers.get(\"anti-csrf\");\n          if (!(antiCsrfToken !== null)) return [3\n          /*break*/\n          , 9];\n          return [4\n          /*yield*/\n          , getLocalSessionState(true)];\n\n        case 7:\n          tok = _b.sent();\n          if (!(tok.status === \"EXISTS\")) return [3\n          /*break*/\n          , 9];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Setting anti-csrf token\");\n          return [4\n          /*yield*/\n          , AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];\n\n        case 8:\n          _b.sent();\n\n          _b.label = 9;\n\n        case 9:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction saveLastAccessTokenUpdate() {\n  return __awaiter(this, void 0, void 0, function () {\n    var now;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"saveLastAccessTokenUpdate: called\");\n          now = Date.now().toString();\n          (0, logger_1.logDebugMessage)(\"saveLastAccessTokenUpdate: setting \" + now);\n          return [4\n          /*yield*/\n          , storeInCookies(LAST_ACCESS_TOKEN_UPDATE, now, Number.MAX_SAFE_INTEGER)];\n\n        case 1:\n          _b.sent(); // We clear the sIRTFrontend cookie\n          // We are handling this as a special case here because we want to limit the scope of legacy code\n\n\n          return [4\n          /*yield*/\n          , storeInCookies(\"sIRTFrontend\", \"\", 0)];\n\n        case 2:\n          // We clear the sIRTFrontend cookie\n          // We are handling this as a special case here because we want to limit the scope of legacy code\n          _b.sent();\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nexports.saveLastAccessTokenUpdate = saveLastAccessTokenUpdate;\n\nfunction getAntiCSRFToken() {\n  return __awaiter(this, void 0, void 0, function () {\n    function getAntiCSRFromCookie() {\n      return __awaiter(this, void 0, void 0, function () {\n        var value, _b, parts, last, temp;\n\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              _b = \"; \";\n              return [4\n              /*yield*/\n              , cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()];\n\n            case 1:\n              value = _b + _c.sent();\n              parts = value.split(\"; \" + ANTI_CSRF_NAME + \"=\");\n\n              if (parts.length >= 2) {\n                last = parts.pop();\n\n                if (last !== undefined) {\n                  temp = last.split(\";\").shift();\n\n                  if (temp === undefined) {\n                    return [2\n                    /*return*/\n                    , null];\n                  }\n\n                  return [2\n                  /*return*/\n                  , temp];\n                }\n              }\n\n              return [2\n              /*return*/\n              , null];\n          }\n        });\n      });\n    }\n\n    var fromCookie;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: called\");\n          return [4\n          /*yield*/\n          , getLocalSessionState(true)];\n\n        case 1:\n          // we do not call doesSessionExist here cause the user might override that\n          // function here and then it may break the logic of our original implementation.\n          if (!(_b.sent().status === \"EXISTS\")) {\n            (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: Returning because local session state != EXISTS\");\n            return [2\n            /*return*/\n            , null];\n          }\n\n          return [4\n          /*yield*/\n          , getAntiCSRFromCookie()];\n\n        case 2:\n          fromCookie = _b.sent();\n          (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: returning: \" + fromCookie);\n          return [2\n          /*return*/\n          , fromCookie];\n      }\n    });\n  });\n} // give antiCSRFToken as undefined to remove it.\n\n\nfunction setAntiCSRF(antiCSRFToken) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"setAntiCSRF: called: \" + antiCSRFToken);\n          if (!(antiCSRFToken !== undefined)) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , storeInCookies(ANTI_CSRF_NAME, antiCSRFToken, Number.MAX_SAFE_INTEGER)];\n\n        case 1:\n          _b.sent();\n\n          return [3\n          /*break*/\n          , 4];\n\n        case 2:\n          return [4\n          /*yield*/\n          , storeInCookies(ANTI_CSRF_NAME, \"\", 0)];\n\n        case 3:\n          _b.sent();\n\n          _b.label = 4;\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nexports.setAntiCSRF = setAntiCSRF;\n\nfunction getFrontTokenFromCookie() {\n  return __awaiter(this, void 0, void 0, function () {\n    var val;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"getFrontTokenFromCookie: called\");\n          return [4\n          /*yield*/\n          , getFromCookies(FRONT_TOKEN_NAME)];\n\n        case 1:\n          val = _b.sent();\n          return [2\n          /*return*/\n          , val === undefined ? null : val];\n      }\n    });\n  });\n}\n\nfunction parseFrontToken(frontToken) {\n  return JSON.parse(decodeURIComponent(escape(atob(frontToken))));\n}\n\nfunction getFrontToken() {\n  return __awaiter(this, void 0, void 0, function () {\n    var fromCookie;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"getFrontToken: called\");\n          return [4\n          /*yield*/\n          , getLocalSessionState(true)];\n\n        case 1:\n          // we do not call doesSessionExist here because that directly calls this function.\n          if (!(_b.sent().status === \"EXISTS\")) {\n            (0, logger_1.logDebugMessage)(\"getFrontToken: Returning because sIRTFrontend != EXISTS\");\n            return [2\n            /*return*/\n            , null];\n          }\n\n          return [4\n          /*yield*/\n          , getFrontTokenFromCookie()];\n\n        case 2:\n          fromCookie = _b.sent();\n          (0, logger_1.logDebugMessage)(\"getFrontToken: returning: \" + fromCookie);\n          return [2\n          /*return*/\n          , fromCookie];\n      }\n    });\n  });\n}\n\nexports.getFrontToken = getFrontToken;\n\nfunction setFrontToken(frontToken) {\n  return __awaiter(this, void 0, void 0, function () {\n    var oldToken, oldPayload, newPayload;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"setFrontToken: called\");\n          return [4\n          /*yield*/\n          , getFrontTokenFromCookie()];\n\n        case 1:\n          oldToken = _b.sent();\n\n          if (oldToken !== null && frontToken !== undefined) {\n            oldPayload = parseFrontToken(oldToken).up;\n            newPayload = parseFrontToken(frontToken).up;\n\n            if (JSON.stringify(oldPayload) !== JSON.stringify(newPayload)) {\n              onTokenUpdate();\n            }\n          }\n\n          if (!(frontToken === undefined)) return [3\n          /*break*/\n          , 3]; // clear the cookie\n\n          return [4\n          /*yield*/\n          , storeInCookies(FRONT_TOKEN_NAME, \"\", 0)];\n\n        case 2:\n          // clear the cookie\n          _b.sent();\n\n          return [3\n          /*break*/\n          , 5];\n\n        case 3:\n          return [4\n          /*yield*/\n          , storeInCookies(FRONT_TOKEN_NAME, frontToken, Number.MAX_SAFE_INTEGER)];\n\n        case 4:\n          _b.sent();\n\n          _b.label = 5;\n\n        case 5:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nexports.setFrontToken = setFrontToken;\n\nfunction fireSessionUpdateEventsIfNecessary(wasLoggedIn, status, frontTokenHeaderFromResponse) {\n  // In case we've received a 401 that didn't clear the session (e.g.: we've sent no session token, or we should try refreshing)\n  // then onUnauthorised will handle firing the UNAUTHORISED event if necessary\n  // In some rare cases (where we receive a 401 that also clears the session) this will fire the event twice.\n  // This may be considered a bug, but it is the existing behaviour before the rework\n  if (frontTokenHeaderFromResponse === undefined || frontTokenHeaderFromResponse === null) {\n    // The access token (and the session) hasn't been updated.\n    (0, logger_1.logDebugMessage)(\"fireSessionUpdateEventsIfNecessary returning early because the front token was not updated\");\n    return;\n  } // if the current endpoint clears the session it'll set the front-token to remove\n  // any other update means it's created or updated.\n\n\n  var frontTokenExistsAfter = frontTokenHeaderFromResponse !== \"remove\";\n  (0, logger_1.logDebugMessage)(\"fireSessionUpdateEventsIfNecessary wasLoggedIn: \".concat(wasLoggedIn, \" frontTokenExistsAfter: \").concat(frontTokenExistsAfter, \" status: \").concat(status));\n\n  if (wasLoggedIn) {\n    // we check for wasLoggedIn cause we don't want to fire an event\n    // unnecessarily on first app load or if the user tried\n    // to query an API that returned 401 while the user was not logged in...\n    if (!frontTokenExistsAfter) {\n      if (status === AuthHttpRequest.config.sessionExpiredStatusCode) {\n        (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: firing UNAUTHORISED event\");\n        AuthHttpRequest.config.onHandleEvent({\n          action: \"UNAUTHORISED\",\n          sessionExpiredOrRevoked: true,\n          userContext: {}\n        });\n      } else {\n        (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: firing SIGN_OUT event\");\n        AuthHttpRequest.config.onHandleEvent({\n          action: \"SIGN_OUT\",\n          userContext: {}\n        });\n      }\n    }\n  } else if (frontTokenExistsAfter) {\n    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: firing SESSION_CREATED event\");\n    AuthHttpRequest.config.onHandleEvent({\n      action: \"SESSION_CREATED\",\n      userContext: {}\n    });\n  }\n}\n\nexports.fireSessionUpdateEventsIfNecessary = fireSessionUpdateEventsIfNecessary;","map":{"version":3,"sources":["/home/dom/FlyM/node_modules/supertokens-website/lib/build/fetch.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","_","label","sent","trys","ops","f","y","g","verb","throw","return","Symbol","iterator","v","op","TypeError","pop","push","defineProperty","exports","fireSessionUpdateEventsIfNecessary","setFrontToken","getFrontToken","setAntiCSRF","saveLastAccessTokenUpdate","getTokenForHeaderAuth","setToken","getStorageNameForToken","getLocalSessionState","onInvalidClaimResponse","onTokenUpdate","onUnauthorisedResponse","FrontToken","AntiCsrfToken","processState_1","require","version_1","utils_1","cookieHandler_1","windowHandler_1","lockFactory_1","logger_1","getToken","associatedAccessTokenUpdate","antiCsrf","_a","logDebugMessage","undefined","tokenInfo","getAntiCSRFToken","removeToken","setItem","getTokenInfo","frontToken","response","status","waiters","parseFrontToken","ate","uid","up","forEach","doesTokenExists","getFrontTokenFromCookie","AuthHttpRequest","init","config","recipeImpl","apiBasePath","apiDomain","autoAddCredentials","sessionTokenBackendDomain","isInIframe","sessionExpiredStatusCode","sessionTokenFrontendDomain","tokenTransferMethod","fetchedWindow","default","getReferenceOrThrow","windowHandler","getWindowUnsafe","env","fetch","global","refreshTokenUrl","signOutUrl","rid","__supertokensOriginalFetch","bind","__supertokensSessionRecipe","addFetchInterceptorsAndReturnModifiedFetch","originalFetch","userContext","addXMLHttpRequestInterceptor","initCalled","doRequest","httpCall","url","doNotDoInterception","origHeaders","accessToken","returnObj","preRequestLSS","clonedHeaders","configWithAntiCsrf","antiCsrfToken","transferMethod","retry","postRequestIdToken","_b","Error","shouldDoInterceptionBasedOnUrl","err","message","location","getOrigin","Headers","headers","has","get","concat","delete","ProcessState","getInstance","addState","PROCESS_STATE","CALLING_INTERCEPTION_REQUEST","lastAccessTokenUpdate","set","credentials","setAuthorizationHeaderIfRequired","saveTokensFromHeaders","error","invalidClaimStatusCode","attemptRefreshingSession","refresh","LAST_ACCESS_TOKEN_UPDATE","REFRESH_TOKEN_NAME","ACCESS_TOKEN_NAME","ANTI_CSRF_NAME","FRONT_TOKEN_NAME","lock","postLockLSS","preAPIResult","isUnauthorised","error_1","postRequestLSS","lockFactory","acquireLock","onHandleEvent","action","sessionExpiredOrRevoked","supported_fdi","join","preAPIHook","requestInit","method","postAPIHook","fetchResponse","clone","releaseLock","claimValidationErrors","_c","getInvalidClaimsFromResponse","tryRefresh","frontTokenExists","res","getFromCookies","tokenType","name","storeInCookies","Date","now","expiry","expires","Number","MAX_SAFE_INTEGER","toUTCString","domain","getHostName","cookieHandler","setCookie","parts","last","getCookie","split","shift","addRefreshToken","refreshToken","tok","toString","getAntiCSRFromCookie","temp","fromCookie","antiCSRFToken","val","JSON","parse","decodeURIComponent","escape","atob","oldToken","oldPayload","newPayload","stringify","wasLoggedIn","frontTokenHeaderFromResponse","frontTokenExistsAfter"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign =\n    (this && this.__assign) ||\n    function () {\n        __assign =\n            Object.assign ||\n            function (t) {\n                for (var s, i = 1, n = arguments.length; i < n; i++) {\n                    s = arguments[i];\n                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n                }\n                return t;\n            };\n        return __assign.apply(this, arguments);\n    };\nvar __awaiter =\n    (this && this.__awaiter) ||\n    function (thisArg, _arguments, P, generator) {\n        function adopt(value) {\n            return value instanceof P\n                ? value\n                : new P(function (resolve) {\n                      resolve(value);\n                  });\n        }\n        return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) {\n                try {\n                    step(generator.next(value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function rejected(value) {\n                try {\n                    step(generator[\"throw\"](value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n            }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    };\nvar __generator =\n    (this && this.__generator) ||\n    function (thisArg, body) {\n        var _ = {\n                label: 0,\n                sent: function () {\n                    if (t[0] & 1) throw t[1];\n                    return t[1];\n                },\n                trys: [],\n                ops: []\n            },\n            f,\n            y,\n            t,\n            g;\n        return (\n            (g = { next: verb(0), throw: verb(1), return: verb(2) }),\n            typeof Symbol === \"function\" &&\n                (g[Symbol.iterator] = function () {\n                    return this;\n                }),\n            g\n        );\n        function verb(n) {\n            return function (v) {\n                return step([n, v]);\n            };\n        }\n        function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_)\n                try {\n                    if (\n                        ((f = 1),\n                        y &&\n                            (t =\n                                op[0] & 2\n                                    ? y[\"return\"]\n                                    : op[0]\n                                    ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0)\n                                    : y.next) &&\n                            !(t = t.call(y, op[1])).done)\n                    )\n                        return t;\n                    if (((y = 0), t)) op = [op[0] & 2, t.value];\n                    switch (op[0]) {\n                        case 0:\n                        case 1:\n                            t = op;\n                            break;\n                        case 4:\n                            _.label++;\n                            return { value: op[1], done: false };\n                        case 5:\n                            _.label++;\n                            y = op[1];\n                            op = [0];\n                            continue;\n                        case 7:\n                            op = _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                        default:\n                            if (\n                                !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&\n                                (op[0] === 6 || op[0] === 2)\n                            ) {\n                                _ = 0;\n                                continue;\n                            }\n                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                                _.label = op[1];\n                                break;\n                            }\n                            if (op[0] === 6 && _.label < t[1]) {\n                                _.label = t[1];\n                                t = op;\n                                break;\n                            }\n                            if (t && _.label < t[2]) {\n                                _.label = t[2];\n                                _.ops.push(op);\n                                break;\n                            }\n                            if (t[2]) _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                    }\n                    op = body.call(thisArg, _);\n                } catch (e) {\n                    op = [6, e];\n                    y = 0;\n                } finally {\n                    f = t = 0;\n                }\n            if (op[0] & 5) throw op[1];\n            return { value: op[0] ? op[1] : void 0, done: true };\n        }\n    };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fireSessionUpdateEventsIfNecessary =\n    exports.setFrontToken =\n    exports.getFrontToken =\n    exports.setAntiCSRF =\n    exports.saveLastAccessTokenUpdate =\n    exports.getTokenForHeaderAuth =\n    exports.setToken =\n    exports.getStorageNameForToken =\n    exports.getLocalSessionState =\n    exports.onInvalidClaimResponse =\n    exports.onTokenUpdate =\n    exports.onUnauthorisedResponse =\n    exports.FrontToken =\n    exports.AntiCsrfToken =\n        void 0;\n/* Copyright (c) 2020, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\nvar processState_1 = require(\"./processState\");\nvar version_1 = require(\"./version\");\nvar utils_1 = require(\"./utils\");\nvar cookieHandler_1 = require(\"./utils/cookieHandler\");\nvar windowHandler_1 = require(\"./utils/windowHandler\");\nvar lockFactory_1 = require(\"./utils/lockFactory\");\nvar logger_1 = require(\"./logger\");\nvar AntiCsrfToken = /** @class */ (function () {\n    function AntiCsrfToken() {}\n    AntiCsrfToken.getToken = function (associatedAccessTokenUpdate) {\n        return __awaiter(this, void 0, void 0, function () {\n            var antiCsrf;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: called\");\n                        if (associatedAccessTokenUpdate === undefined) {\n                            AntiCsrfToken.tokenInfo = undefined;\n                            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning undefined\");\n                            return [2 /*return*/, undefined];\n                        }\n                        if (!(AntiCsrfToken.tokenInfo === undefined)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, getAntiCSRFToken()];\n                    case 1:\n                        antiCsrf = _a.sent();\n                        if (antiCsrf === null) {\n                            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning undefined\");\n                            return [2 /*return*/, undefined];\n                        }\n                        AntiCsrfToken.tokenInfo = {\n                            antiCsrf: antiCsrf,\n                            associatedAccessTokenUpdate: associatedAccessTokenUpdate\n                        };\n                        return [3 /*break*/, 4];\n                    case 2:\n                        if (!(AntiCsrfToken.tokenInfo.associatedAccessTokenUpdate !== associatedAccessTokenUpdate))\n                            return [3 /*break*/, 4];\n                        // csrf token has changed.\n                        AntiCsrfToken.tokenInfo = undefined;\n                        return [4 /*yield*/, AntiCsrfToken.getToken(associatedAccessTokenUpdate)];\n                    case 3:\n                        return [2 /*return*/, _a.sent()];\n                    case 4:\n                        (0,\n                        logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning: \" + AntiCsrfToken.tokenInfo.antiCsrf);\n                        return [2 /*return*/, AntiCsrfToken.tokenInfo.antiCsrf];\n                }\n            });\n        });\n    };\n    AntiCsrfToken.removeToken = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"AntiCsrfToken.removeToken: called\");\n                        AntiCsrfToken.tokenInfo = undefined;\n                        return [4 /*yield*/, setAntiCSRF(undefined)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AntiCsrfToken.setItem = function (associatedAccessTokenUpdate, antiCsrf) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (associatedAccessTokenUpdate === undefined) {\n                            AntiCsrfToken.tokenInfo = undefined;\n                            return [2 /*return*/];\n                        }\n                        (0, logger_1.logDebugMessage)(\"AntiCsrfToken.setItem: called\");\n                        return [4 /*yield*/, setAntiCSRF(antiCsrf)];\n                    case 1:\n                        _a.sent();\n                        AntiCsrfToken.tokenInfo = {\n                            antiCsrf: antiCsrf,\n                            associatedAccessTokenUpdate: associatedAccessTokenUpdate\n                        };\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return AntiCsrfToken;\n})();\nexports.AntiCsrfToken = AntiCsrfToken;\n// Note: We do not store this in memory because another tab may have\n// modified this value, and if so, we may not know about it in this tab\nvar FrontToken = /** @class */ (function () {\n    function FrontToken() {}\n    FrontToken.getTokenInfo = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var frontToken, response;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: called\");\n                        return [4 /*yield*/, getFrontToken()];\n                    case 1:\n                        frontToken = _a.sent();\n                        if (!(frontToken === null)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, getLocalSessionState(false)];\n                    case 2:\n                        if (!(_a.sent().status === \"EXISTS\")) return [3 /*break*/, 4];\n                        // this means that the id refresh token has been set, so we must\n                        // wait for this to be set or removed\n                        return [\n                            4 /*yield*/,\n                            new Promise(function (resolve) {\n                                FrontToken.waiters.push(resolve);\n                            })\n                        ];\n                    case 3:\n                        // this means that the id refresh token has been set, so we must\n                        // wait for this to be set or removed\n                        _a.sent();\n                        return [2 /*return*/, FrontToken.getTokenInfo()];\n                    case 4:\n                        return [2 /*return*/, undefined];\n                    case 5:\n                        response = parseFrontToken(frontToken);\n                        (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning ate: \" + response.ate);\n                        (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning uid: \" + response.uid);\n                        (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning up: \" + response.up);\n                        return [2 /*return*/, response];\n                }\n            });\n        });\n    };\n    FrontToken.removeToken = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"FrontToken.removeToken: called\");\n                        return [4 /*yield*/, setFrontToken(undefined)];\n                    case 1:\n                        _a.sent();\n                        FrontToken.waiters.forEach(function (f) {\n                            return f(undefined);\n                        });\n                        FrontToken.waiters = [];\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FrontToken.setItem = function (frontToken) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // We update the refresh attempt info here as well, since this means that we've updated the session in some way\n                        // This could be both by a refresh call or if the access token was updated in a custom endpoint\n                        // By saving every time the access token has been updated, we cause an early retry if\n                        // another request has failed with a 401 with the previous access token and the token still exists.\n                        // Check the start and end of onUnauthorisedResponse\n                        // As a side-effect we reload the anti-csrf token to check if it was changed by another tab.\n                        return [4 /*yield*/, saveLastAccessTokenUpdate()];\n                    case 1:\n                        // We update the refresh attempt info here as well, since this means that we've updated the session in some way\n                        // This could be both by a refresh call or if the access token was updated in a custom endpoint\n                        // By saving every time the access token has been updated, we cause an early retry if\n                        // another request has failed with a 401 with the previous access token and the token still exists.\n                        // Check the start and end of onUnauthorisedResponse\n                        // As a side-effect we reload the anti-csrf token to check if it was changed by another tab.\n                        _a.sent();\n                        if (frontToken === \"remove\") {\n                            return [2 /*return*/, FrontToken.removeToken()];\n                        }\n                        (0, logger_1.logDebugMessage)(\"FrontToken.setItem: called\");\n                        return [4 /*yield*/, setFrontToken(frontToken)];\n                    case 2:\n                        _a.sent();\n                        FrontToken.waiters.forEach(function (f) {\n                            return f(undefined);\n                        });\n                        FrontToken.waiters = [];\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FrontToken.doesTokenExists = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var frontToken;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        return [4 /*yield*/, getFrontTokenFromCookie()];\n                    case 1:\n                        frontToken = _a.sent();\n                        return [2 /*return*/, frontToken !== null];\n                }\n            });\n        });\n    };\n    // these are waiters for when the idRefreshToken has been set, but this token has\n    // not yet been set. Once this token is set or removed, the waiters are resolved.\n    FrontToken.waiters = [];\n    return FrontToken;\n})();\nexports.FrontToken = FrontToken;\n/**\n * @class AuthHttpRequest\n * @description wrapper for common http methods.\n */\nvar AuthHttpRequest = /** @class */ (function () {\n    function AuthHttpRequest() {}\n    AuthHttpRequest.init = function (config, recipeImpl) {\n        (0, logger_1.logDebugMessage)(\"init: called\");\n        (0, logger_1.logDebugMessage)(\"init: Input apiBasePath: \" + config.apiBasePath);\n        (0, logger_1.logDebugMessage)(\"init: Input apiDomain: \" + config.apiDomain);\n        (0, logger_1.logDebugMessage)(\"init: Input autoAddCredentials: \" + config.autoAddCredentials);\n        (0, logger_1.logDebugMessage)(\"init: Input sessionTokenBackendDomain: \" + config.sessionTokenBackendDomain);\n        (0, logger_1.logDebugMessage)(\"init: Input isInIframe: \" + config.isInIframe);\n        (0, logger_1.logDebugMessage)(\"init: Input sessionExpiredStatusCode: \" + config.sessionExpiredStatusCode);\n        (0, logger_1.logDebugMessage)(\"init: Input sessionTokenFrontendDomain: \" + config.sessionTokenFrontendDomain);\n        (0, logger_1.logDebugMessage)(\"init: Input tokenTransferMethod: \" + config.tokenTransferMethod);\n        var fetchedWindow = windowHandler_1.default.getReferenceOrThrow().windowHandler.getWindowUnsafe();\n        AuthHttpRequest.env = fetchedWindow === undefined || fetchedWindow.fetch === undefined ? global : fetchedWindow;\n        AuthHttpRequest.refreshTokenUrl = config.apiDomain + config.apiBasePath + \"/session/refresh\";\n        AuthHttpRequest.signOutUrl = config.apiDomain + config.apiBasePath + \"/signout\";\n        AuthHttpRequest.rid = \"session\";\n        AuthHttpRequest.config = config;\n        if (AuthHttpRequest.env.__supertokensOriginalFetch === undefined) {\n            (0, logger_1.logDebugMessage)(\"init: __supertokensOriginalFetch is undefined\");\n            // this block contains code that is run just once per page load..\n            // all items in this block are attached to the global env so that\n            // even if the init function is called more than once (maybe across JS scripts),\n            // things will not get created multiple times.\n            AuthHttpRequest.env.__supertokensOriginalFetch = AuthHttpRequest.env.fetch.bind(AuthHttpRequest.env);\n            AuthHttpRequest.env.__supertokensSessionRecipe = recipeImpl;\n            AuthHttpRequest.env.fetch =\n                AuthHttpRequest.env.__supertokensSessionRecipe.addFetchInterceptorsAndReturnModifiedFetch({\n                    originalFetch: AuthHttpRequest.env.__supertokensOriginalFetch,\n                    userContext: {}\n                });\n            AuthHttpRequest.env.__supertokensSessionRecipe.addXMLHttpRequestInterceptor({\n                userContext: {}\n            });\n        }\n        AuthHttpRequest.recipeImpl = AuthHttpRequest.env.__supertokensSessionRecipe;\n        AuthHttpRequest.initCalled = true;\n    };\n    var _a;\n    _a = AuthHttpRequest;\n    AuthHttpRequest.initCalled = false;\n    AuthHttpRequest.doRequest = function (httpCall, config, url) {\n        return __awaiter(void 0, void 0, void 0, function () {\n            var doNotDoInterception,\n                origHeaders,\n                accessToken,\n                returnObj,\n                preRequestLSS,\n                clonedHeaders,\n                configWithAntiCsrf,\n                antiCsrfToken,\n                transferMethod,\n                response,\n                retry,\n                postRequestIdToken;\n            return __generator(_a, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!AuthHttpRequest.initCalled) {\n                            throw Error(\"init function not called\");\n                        }\n                        (0, logger_1.logDebugMessage)(\"doRequest: start of fetch interception\");\n                        doNotDoInterception = false;\n                        try {\n                            doNotDoInterception =\n                                (typeof url === \"string\" &&\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        url,\n                                        AuthHttpRequest.config.apiDomain,\n                                        AuthHttpRequest.config.sessionTokenBackendDomain\n                                    )) ||\n                                (url !== undefined &&\n                                    typeof url.url === \"string\" && // this is because url can be an object like {method: ..., url: ...}\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        url.url,\n                                        AuthHttpRequest.config.apiDomain,\n                                        AuthHttpRequest.config.sessionTokenBackendDomain\n                                    ));\n                        } catch (err) {\n                            if (err.message === \"Please provide a valid domain name\") {\n                                (0, logger_1.logDebugMessage)(\n                                    \"doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                                );\n                                // .origin gives the port as well..\n                                doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                    windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),\n                                    AuthHttpRequest.config.apiDomain,\n                                    AuthHttpRequest.config.sessionTokenBackendDomain\n                                );\n                            } else {\n                                throw err;\n                            }\n                        }\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: Value of doNotDoInterception: \" + doNotDoInterception);\n                        if (!doNotDoInterception) return [3 /*break*/, 2];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Returning without interception\");\n                        return [4 /*yield*/, httpCall(config)];\n                    case 1:\n                        return [2 /*return*/, _b.sent()];\n                    case 2:\n                        origHeaders = new Headers(\n                            config !== undefined && config.headers !== undefined ? config.headers : url.headers\n                        );\n                        if (!origHeaders.has(\"Authorization\")) return [3 /*break*/, 4];\n                        return [4 /*yield*/, getTokenForHeaderAuth(\"access\")];\n                    case 3:\n                        accessToken = _b.sent();\n                        if (\n                            accessToken !== undefined &&\n                            origHeaders.get(\"Authorization\") === \"Bearer \".concat(accessToken)\n                        ) {\n                            // We are ignoring the Authorization header set by the user in this case, because it would cause issues\n                            // If we do not ignore this, then this header would be used even if the request is being retried after a refresh, even though it contains an outdated access token.\n                            // This causes an infinite refresh loop.\n                            (0, logger_1.logDebugMessage)(\n                                \"doRequest: Removing Authorization from user provided headers because it contains our access token\"\n                            );\n                            origHeaders.delete(\"Authorization\");\n                        }\n                        _b.label = 4;\n                    case 4:\n                        (0, logger_1.logDebugMessage)(\"doRequest: Interception started\");\n                        processState_1.ProcessState.getInstance().addState(\n                            processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST\n                        );\n                        _b.label = 5;\n                    case 5:\n                        _b.trys.push([5, , 19, 24]);\n                        returnObj = undefined;\n                        _b.label = 6;\n                    case 6:\n                        if (!true) return [3 /*break*/, 18];\n                        return [4 /*yield*/, getLocalSessionState(true)];\n                    case 7:\n                        preRequestLSS = _b.sent();\n                        clonedHeaders = new Headers(origHeaders);\n                        configWithAntiCsrf = __assign(__assign({}, config), { headers: clonedHeaders });\n                        if (!(preRequestLSS.status === \"EXISTS\")) return [3 /*break*/, 9];\n                        return [4 /*yield*/, AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n                    case 8:\n                        antiCsrfToken = _b.sent();\n                        if (antiCsrfToken !== undefined) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding anti-csrf token to request\");\n                            clonedHeaders.set(\"anti-csrf\", antiCsrfToken);\n                        }\n                        _b.label = 9;\n                    case 9:\n                        if (AuthHttpRequest.config.autoAddCredentials) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding credentials include\");\n                            if (configWithAntiCsrf === undefined) {\n                                configWithAntiCsrf = {\n                                    credentials: \"include\"\n                                };\n                            } else if (configWithAntiCsrf.credentials === undefined) {\n                                configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                                    credentials: \"include\"\n                                });\n                            }\n                        }\n                        // adding rid for anti-csrf protection: Anti-csrf via custom header\n                        if (!clonedHeaders.has(\"rid\")) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding rid header: anti-csrf\");\n                            clonedHeaders.set(\"rid\", \"anti-csrf\");\n                        } else {\n                            (0, logger_1.logDebugMessage)(\"doRequest: rid header was already there in request\");\n                        }\n                        transferMethod = AuthHttpRequest.config.tokenTransferMethod;\n                        (0, logger_1.logDebugMessage)(\"doRequest: Adding st-auth-mode header: \" + transferMethod);\n                        clonedHeaders.set(\"st-auth-mode\", transferMethod);\n                        return [4 /*yield*/, setAuthorizationHeaderIfRequired(clonedHeaders)];\n                    case 10:\n                        _b.sent();\n                        (0, logger_1.logDebugMessage)(\"doRequest: Making user's http call\");\n                        return [4 /*yield*/, httpCall(configWithAntiCsrf)];\n                    case 11:\n                        response = _b.sent();\n                        (0, logger_1.logDebugMessage)(\"doRequest: User's http call ended\");\n                        return [4 /*yield*/, saveTokensFromHeaders(response)];\n                    case 12:\n                        _b.sent();\n                        fireSessionUpdateEventsIfNecessary(\n                            preRequestLSS.status === \"EXISTS\",\n                            response.status,\n                            response.headers.get(\"front-token\")\n                        );\n                        if (!(response.status === AuthHttpRequest.config.sessionExpiredStatusCode))\n                            return [3 /*break*/, 14];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n                        return [4 /*yield*/, onUnauthorisedResponse(preRequestLSS)];\n                    case 13:\n                        retry = _b.sent();\n                        if (retry.result !== \"RETRY\") {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n                            returnObj = retry.error !== undefined ? retry.error : response;\n                            return [3 /*break*/, 18];\n                        }\n                        (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n                        return [3 /*break*/, 17];\n                    case 14:\n                        if (!(response.status === AuthHttpRequest.config.invalidClaimStatusCode))\n                            return [3 /*break*/, 16];\n                        return [4 /*yield*/, onInvalidClaimResponse(response)];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16:\n                        return [2 /*return*/, response];\n                    case 17:\n                        return [3 /*break*/, 6];\n                    case 18:\n                        // if it comes here, means we breaked. which happens only if we have logged out.\n                        return [2 /*return*/, returnObj];\n                    case 19:\n                        return [4 /*yield*/, getLocalSessionState(false)];\n                    case 20:\n                        postRequestIdToken = _b.sent();\n                        if (!(postRequestIdToken.status === \"NOT_EXISTS\")) return [3 /*break*/, 23];\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n                        return [4 /*yield*/, AntiCsrfToken.removeToken()];\n                    case 21:\n                        _b.sent();\n                        return [4 /*yield*/, FrontToken.removeToken()];\n                    case 22:\n                        _b.sent();\n                        _b.label = 23;\n                    case 23:\n                        return [7 /*endfinally*/];\n                    case 24:\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AuthHttpRequest.attemptRefreshingSession = function () {\n        return __awaiter(void 0, void 0, void 0, function () {\n            var preRequestLSS, refresh;\n            return __generator(_a, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!AuthHttpRequest.initCalled) {\n                            throw Error(\"init function not called\");\n                        }\n                        return [4 /*yield*/, getLocalSessionState(false)];\n                    case 1:\n                        preRequestLSS = _b.sent();\n                        return [4 /*yield*/, onUnauthorisedResponse(preRequestLSS)];\n                    case 2:\n                        refresh = _b.sent();\n                        if (refresh.result === \"API_ERROR\") {\n                            throw refresh.error;\n                        }\n                        return [2 /*return*/, refresh.result === \"RETRY\"];\n                }\n            });\n        });\n    };\n    return AuthHttpRequest;\n})();\nexports.default = AuthHttpRequest;\nvar LAST_ACCESS_TOKEN_UPDATE = \"st-last-access-token-update\";\nvar REFRESH_TOKEN_NAME = \"st-refresh-token\";\nvar ACCESS_TOKEN_NAME = \"st-access-token\";\nvar ANTI_CSRF_NAME = \"sAntiCsrf\";\nvar FRONT_TOKEN_NAME = \"sFrontToken\";\n/**\n * @description attempts to call the refresh token API each time we are sure the session has expired, or it throws an error or,\n * or the ID_COOKIE_NAME has changed value -> which may mean that we have a new set of tokens.\n */\nfunction onUnauthorisedResponse(preRequestLSS) {\n    return __awaiter(this, void 0, void 0, function () {\n        var lock,\n            postLockLSS,\n            headers,\n            antiCsrfToken,\n            transferMethod,\n            preAPIResult,\n            response,\n            isUnauthorised,\n            error_1,\n            postRequestLSS;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    return [4 /*yield*/, lockFactory_1.default.getReferenceOrThrow().lockFactory()];\n                case 1:\n                    lock = _b.sent();\n                    _b.label = 2;\n                case 2:\n                    if (!true) return [3 /*break*/, 24];\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: trying to acquire lock\");\n                    return [4 /*yield*/, lock.acquireLock(\"REFRESH_TOKEN_USE\", 1000)];\n                case 3:\n                    if (!_b.sent()) return [3 /*break*/, 22];\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: lock acquired\");\n                    _b.label = 4;\n                case 4:\n                    _b.trys.push([4, 14, 16, 22]);\n                    return [4 /*yield*/, getLocalSessionState(false)];\n                case 5:\n                    postLockLSS = _b.sent();\n                    if (postLockLSS.status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: Not refreshing because local session state is NOT_EXISTS\"\n                        );\n                        // if it comes here, it means a request was made thinking\n                        // that the session exists, but it doesn't actually exist.\n                        AuthHttpRequest.config.onHandleEvent({\n                            action: \"UNAUTHORISED\",\n                            sessionExpiredOrRevoked: false,\n                            userContext: {}\n                        });\n                        return [2 /*return*/, { result: \"SESSION_EXPIRED\" }];\n                    }\n                    if (\n                        postLockLSS.status !== preRequestLSS.status ||\n                        (postLockLSS.status === \"EXISTS\" &&\n                            preRequestLSS.status === \"EXISTS\" &&\n                            postLockLSS.lastAccessTokenUpdate !== preRequestLSS.lastAccessTokenUpdate)\n                    ) {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: Retrying early because pre and post id refresh tokens don't match\"\n                        );\n                        // means that some other process has already called this API and succeeded. so we need to call it again\n                        return [2 /*return*/, { result: \"RETRY\" }];\n                    }\n                    headers = new Headers();\n                    if (!(preRequestLSS.status === \"EXISTS\")) return [3 /*break*/, 7];\n                    return [4 /*yield*/, AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n                case 6:\n                    antiCsrfToken = _b.sent();\n                    if (antiCsrfToken !== undefined) {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: Adding anti-csrf token to refresh API call\"\n                        );\n                        headers.set(\"anti-csrf\", antiCsrfToken);\n                    }\n                    _b.label = 7;\n                case 7:\n                    (0,\n                    logger_1.logDebugMessage)(\"onUnauthorisedResponse: Adding rid and fdi-versions to refresh call header\");\n                    headers.set(\"rid\", AuthHttpRequest.rid);\n                    headers.set(\"fdi-version\", version_1.supported_fdi.join(\",\"));\n                    transferMethod = AuthHttpRequest.config.tokenTransferMethod;\n                    (0,\n                    logger_1.logDebugMessage)(\"onUnauthorisedResponse: Adding st-auth-mode header: \" + transferMethod);\n                    headers.set(\"st-auth-mode\", transferMethod);\n                    return [4 /*yield*/, setAuthorizationHeaderIfRequired(headers, true)];\n                case 8:\n                    _b.sent();\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Calling refresh pre API hook\");\n                    return [\n                        4 /*yield*/,\n                        AuthHttpRequest.config.preAPIHook({\n                            action: \"REFRESH_SESSION\",\n                            requestInit: {\n                                method: \"post\",\n                                credentials: \"include\",\n                                headers: headers\n                            },\n                            url: AuthHttpRequest.refreshTokenUrl,\n                            userContext: {}\n                        })\n                    ];\n                case 9:\n                    preAPIResult = _b.sent();\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Making refresh call\");\n                    return [\n                        4 /*yield*/,\n                        AuthHttpRequest.env.__supertokensOriginalFetch(preAPIResult.url, preAPIResult.requestInit)\n                    ];\n                case 10:\n                    response = _b.sent();\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Refresh call ended\");\n                    return [4 /*yield*/, saveTokensFromHeaders(response)];\n                case 11:\n                    _b.sent();\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Refresh status code is: \" + response.status);\n                    isUnauthorised = response.status === AuthHttpRequest.config.sessionExpiredStatusCode;\n                    // There is a case where the FE thinks the session is valid, but backend doesn't get the tokens.\n                    // In this event, session expired error will be thrown and the frontend should remove this token\n                    if (isUnauthorised && response.headers.get(\"front-token\") === null) {\n                        FrontToken.setItem(\"remove\");\n                    }\n                    fireSessionUpdateEventsIfNecessary(\n                        preRequestLSS.status === \"EXISTS\",\n                        response.status,\n                        isUnauthorised && response.headers.get(\"front-token\") === null\n                            ? \"remove\"\n                            : response.headers.get(\"front-token\")\n                    );\n                    if (response.status >= 300) {\n                        throw response;\n                    }\n                    return [\n                        4 /*yield*/,\n                        AuthHttpRequest.config.postAPIHook({\n                            action: \"REFRESH_SESSION\",\n                            fetchResponse: response.clone(),\n                            requestInit: preAPIResult.requestInit,\n                            url: preAPIResult.url,\n                            userContext: {}\n                        })\n                    ];\n                case 12:\n                    _b.sent();\n                    return [4 /*yield*/, getLocalSessionState(false)];\n                case 13:\n                    if (_b.sent().status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: local session doesn't exist, so returning session expired\"\n                        );\n                        // The execution should never come here.. but just in case.\n                        // removed by server during refresh. So we logout\n                        // we do not send \"UNAUTHORISED\" event here because\n                        // this is a result of the refresh API returning a session expiry, which\n                        // means that the frontend did not know for sure that the session existed\n                        // in the first place.\n                        return [2 /*return*/, { result: \"SESSION_EXPIRED\" }];\n                    }\n                    AuthHttpRequest.config.onHandleEvent({\n                        action: \"REFRESH_SESSION\",\n                        userContext: {}\n                    });\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Sending RETRY signal\");\n                    return [2 /*return*/, { result: \"RETRY\" }];\n                case 14:\n                    error_1 = _b.sent();\n                    return [4 /*yield*/, getLocalSessionState(false)];\n                case 15:\n                    if (_b.sent().status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: local session doesn't exist, so returning session expired\"\n                        );\n                        // removed by server.\n                        // we do not send \"UNAUTHORISED\" event here because\n                        // this is a result of the refresh API returning a session expiry, which\n                        // means that the frontend did not know for sure that the session existed\n                        // in the first place.\n                        return [2 /*return*/, { result: \"SESSION_EXPIRED\", error: error_1 }];\n                    }\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: sending API_ERROR\");\n                    return [2 /*return*/, { result: \"API_ERROR\", error: error_1 }];\n                case 16:\n                    return [4 /*yield*/, lock.releaseLock(\"REFRESH_TOKEN_USE\")];\n                case 17:\n                    _b.sent();\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Released lock\");\n                    return [4 /*yield*/, getLocalSessionState(false)];\n                case 18:\n                    if (!(_b.sent().status === \"NOT_EXISTS\")) return [3 /*break*/, 21];\n                    (0,\n                    logger_1.logDebugMessage)(\"onUnauthorisedResponse: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n                    return [4 /*yield*/, AntiCsrfToken.removeToken()];\n                case 19:\n                    _b.sent();\n                    return [4 /*yield*/, FrontToken.removeToken()];\n                case 20:\n                    _b.sent();\n                    _b.label = 21;\n                case 21:\n                    return [7 /*endfinally*/];\n                case 22:\n                    return [4 /*yield*/, getLocalSessionState(false)];\n                case 23:\n                    postRequestLSS = _b.sent();\n                    if (postRequestLSS.status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: lock acquired failed and local session doesn't exist, so sending SESSION_EXPIRED\"\n                        );\n                        // removed by server. So we logout\n                        return [2 /*return*/, { result: \"SESSION_EXPIRED\" }];\n                    } else {\n                        if (\n                            postRequestLSS.status !== preRequestLSS.status ||\n                            (postRequestLSS.status === \"EXISTS\" &&\n                                preRequestLSS.status === \"EXISTS\" &&\n                                postRequestLSS.lastAccessTokenUpdate !== preRequestLSS.lastAccessTokenUpdate)\n                        ) {\n                            (0, logger_1.logDebugMessage)(\n                                \"onUnauthorisedResponse: lock acquired failed and retrying early because pre and post id refresh tokens don't match\"\n                            );\n                            return [2 /*return*/, { result: \"RETRY\" }];\n                        }\n                        // here we try to call the API again since we probably failed to acquire lock and nothing has changed.\n                    }\n                    return [3 /*break*/, 2];\n                case 24:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.onUnauthorisedResponse = onUnauthorisedResponse;\nfunction onTokenUpdate() {\n    (0, logger_1.logDebugMessage)(\"onTokenUpdate: firing ACCESS_TOKEN_PAYLOAD_UPDATED event\");\n    AuthHttpRequest.config.onHandleEvent({\n        action: \"ACCESS_TOKEN_PAYLOAD_UPDATED\",\n        userContext: {}\n    });\n}\nexports.onTokenUpdate = onTokenUpdate;\nfunction onInvalidClaimResponse(response) {\n    return __awaiter(this, void 0, void 0, function () {\n        var claimValidationErrors, _b;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    _c.trys.push([0, 2, , 3]);\n                    return [\n                        4 /*yield*/,\n                        AuthHttpRequest.recipeImpl.getInvalidClaimsFromResponse({\n                            response: response,\n                            userContext: {}\n                        })\n                    ];\n                case 1:\n                    claimValidationErrors = _c.sent();\n                    // This shouldn't be undefined normally, but since we can't be certain about the shape of the response object so we check it like this.\n                    // It could still be something else, but chance of that happening by accident is really low.\n                    if (claimValidationErrors) {\n                        AuthHttpRequest.config.onHandleEvent({\n                            action: \"API_INVALID_CLAIM\",\n                            claimValidationErrors: claimValidationErrors,\n                            userContext: {}\n                        });\n                    }\n                    return [3 /*break*/, 3];\n                case 2:\n                    _b = _c.sent();\n                    return [3 /*break*/, 3];\n                case 3:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.onInvalidClaimResponse = onInvalidClaimResponse;\n// if tryRefresh is true & this token doesn't exist, we try and refresh the session\n// else we return undefined.\nfunction getLocalSessionState(tryRefresh) {\n    return __awaiter(this, void 0, void 0, function () {\n        var lastAccessTokenUpdate, frontTokenExists, response, res;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"getLocalSessionState: called\");\n                    return [4 /*yield*/, getFromCookies(LAST_ACCESS_TOKEN_UPDATE)];\n                case 1:\n                    lastAccessTokenUpdate = _b.sent();\n                    return [4 /*yield*/, FrontToken.doesTokenExists()];\n                case 2:\n                    frontTokenExists = _b.sent();\n                    if (!(frontTokenExists && lastAccessTokenUpdate !== undefined)) return [3 /*break*/, 3];\n                    (0,\n                    logger_1.logDebugMessage)(\"getLocalSessionState: returning EXISTS since both frontToken and lastAccessTokenUpdate exists\");\n                    return [2 /*return*/, { status: \"EXISTS\", lastAccessTokenUpdate: lastAccessTokenUpdate }];\n                case 3:\n                    if (!lastAccessTokenUpdate) return [3 /*break*/, 4];\n                    (0,\n                    logger_1.logDebugMessage)(\"getLocalSessionState: returning NOT_EXISTS since frontToken was cleared but lastAccessTokenUpdate exists\");\n                    return [2 /*return*/, { status: \"NOT_EXISTS\" }];\n                case 4:\n                    response = {\n                        status: \"MAY_EXIST\"\n                    };\n                    if (!tryRefresh) return [3 /*break*/, 7];\n                    (0, logger_1.logDebugMessage)(\"getLocalSessionState: trying to refresh\");\n                    return [4 /*yield*/, onUnauthorisedResponse(response)];\n                case 5:\n                    res = _b.sent();\n                    if (res.result !== \"RETRY\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"getLocalSessionState: return NOT_EXISTS in case error from backend\" + res.result\n                        );\n                        // in case the backend is not working, we treat it as the session not existing...\n                        return [\n                            2 /*return*/,\n                            {\n                                status: \"NOT_EXISTS\"\n                            }\n                        ];\n                    }\n                    (0, logger_1.logDebugMessage)(\"getLocalSessionState: Retrying post refresh\");\n                    return [4 /*yield*/, getLocalSessionState(tryRefresh)];\n                case 6:\n                    return [2 /*return*/, _b.sent()];\n                case 7:\n                    (0, logger_1.logDebugMessage)(\"getLocalSessionState: returning: \" + response.status);\n                    return [2 /*return*/, response];\n            }\n        });\n    });\n}\nexports.getLocalSessionState = getLocalSessionState;\nfunction getStorageNameForToken(tokenType) {\n    switch (tokenType) {\n        case \"access\":\n            return ACCESS_TOKEN_NAME;\n        case \"refresh\":\n            return REFRESH_TOKEN_NAME;\n    }\n}\nexports.getStorageNameForToken = getStorageNameForToken;\nfunction setToken(tokenType, value) {\n    var name = getStorageNameForToken(tokenType);\n    if (value !== \"\") {\n        (0, logger_1.logDebugMessage)(\"setToken: saved \".concat(tokenType, \" token into cookies\"));\n        // We save the tokens with a 100-year expiration time\n        return storeInCookies(name, value, Date.now() + 3153600000);\n    } else {\n        (0, logger_1.logDebugMessage)(\"setToken: cleared \".concat(tokenType, \" token from cookies\"));\n        return storeInCookies(name, value, 0);\n    }\n}\nexports.setToken = setToken;\nfunction storeInCookies(name, value, expiry) {\n    var expires = \"Fri, 31 Dec 9999 23:59:59 GMT\";\n    if (expiry !== Number.MAX_SAFE_INTEGER) {\n        // We should respect the storage expirations set by the backend, even though tokens will also be checked elsewhere.\n        // We check them locally in case of front-token, and on the backend enforces the validity period for access and refresh tokens.\n        expires = new Date(expiry).toUTCString();\n    }\n    var domain = AuthHttpRequest.config.sessionTokenFrontendDomain;\n    if (\n        domain === \"localhost\" ||\n        domain === windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getHostName()\n    ) {\n        // since some browsers ignore cookies with domain set to localhost\n        // see https://github.com/supertokens/supertokens-website/issues/25\n        return cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n            \"\"\n                .concat(name, \"=\")\n                .concat(value, \";expires=\")\n                .concat(expires, \";path=/;samesite=\")\n                .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n        );\n    } else {\n        return cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n            \"\"\n                .concat(name, \"=\")\n                .concat(value, \";expires=\")\n                .concat(expires, \";domain=\")\n                .concat(domain, \";path=/;samesite=\")\n                .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n        );\n    }\n}\nfunction getTokenForHeaderAuth(tokenType) {\n    return __awaiter(this, void 0, void 0, function () {\n        var name;\n        return __generator(this, function (_b) {\n            name = getStorageNameForToken(tokenType);\n            return [2 /*return*/, getFromCookies(name)];\n        });\n    });\n}\nexports.getTokenForHeaderAuth = getTokenForHeaderAuth;\nfunction getFromCookies(name) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, _b, parts, last;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    _b = \"; \";\n                    return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()];\n                case 1:\n                    value = _b + _c.sent();\n                    parts = value.split(\"; \" + name + \"=\");\n                    if (parts.length >= 2) {\n                        last = parts.pop();\n                        if (last !== undefined) {\n                            return [2 /*return*/, last.split(\";\").shift()];\n                        }\n                    }\n                    return [2 /*return*/, undefined];\n            }\n        });\n    });\n}\nfunction setAuthorizationHeaderIfRequired(clonedHeaders, addRefreshToken) {\n    if (addRefreshToken === void 0) {\n        addRefreshToken = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n        var accessToken, refreshToken;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"setTokenHeaders: adding existing tokens as header\");\n                    return [4 /*yield*/, getTokenForHeaderAuth(\"access\")];\n                case 1:\n                    accessToken = _b.sent();\n                    return [4 /*yield*/, getTokenForHeaderAuth(\"refresh\")];\n                case 2:\n                    refreshToken = _b.sent();\n                    // We don't always need the refresh token because that's only required by the refresh call\n                    // Still, we only add the Authorization header if both are present, because we are planning to add an option to expose the\n                    // access token to the frontend while using cookie based auth - so that users can get the access token to use\n                    if (accessToken !== undefined && refreshToken !== undefined) {\n                        // the Headers class normalizes header names so we don't have to worry about casing\n                        if (clonedHeaders.has(\"Authorization\")) {\n                            (0, logger_1.logDebugMessage)(\n                                \"setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding\"\n                            );\n                        } else {\n                            (0, logger_1.logDebugMessage)(\n                                \"setAuthorizationHeaderIfRequired: added authorization header\"\n                            );\n                            clonedHeaders.set(\n                                \"Authorization\",\n                                \"Bearer \".concat(addRefreshToken ? refreshToken : accessToken)\n                            );\n                        }\n                    } else {\n                        (0, logger_1.logDebugMessage)(\n                            \"setAuthorizationHeaderIfRequired: token for header based auth not found\"\n                        );\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction saveTokensFromHeaders(response) {\n    return __awaiter(this, void 0, void 0, function () {\n        var refreshToken, accessToken, frontToken, antiCsrfToken, tok;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0,\n                    logger_1.logDebugMessage)(\"saveTokensFromHeaders: Saving updated tokens from the response headers\");\n                    refreshToken = response.headers.get(\"st-refresh-token\");\n                    if (!(refreshToken !== null)) return [3 /*break*/, 2];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new refresh token\");\n                    return [4 /*yield*/, setToken(\"refresh\", refreshToken)];\n                case 1:\n                    _b.sent();\n                    _b.label = 2;\n                case 2:\n                    accessToken = response.headers.get(\"st-access-token\");\n                    if (!(accessToken !== null)) return [3 /*break*/, 4];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new access token\");\n                    return [4 /*yield*/, setToken(\"access\", accessToken)];\n                case 3:\n                    _b.sent();\n                    _b.label = 4;\n                case 4:\n                    frontToken = response.headers.get(\"front-token\");\n                    if (!(frontToken !== null)) return [3 /*break*/, 6];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Setting sFrontToken: \" + frontToken);\n                    return [4 /*yield*/, FrontToken.setItem(frontToken)];\n                case 5:\n                    _b.sent();\n                    _b.label = 6;\n                case 6:\n                    antiCsrfToken = response.headers.get(\"anti-csrf\");\n                    if (!(antiCsrfToken !== null)) return [3 /*break*/, 9];\n                    return [4 /*yield*/, getLocalSessionState(true)];\n                case 7:\n                    tok = _b.sent();\n                    if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 9];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Setting anti-csrf token\");\n                    return [4 /*yield*/, AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];\n                case 8:\n                    _b.sent();\n                    _b.label = 9;\n                case 9:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction saveLastAccessTokenUpdate() {\n    return __awaiter(this, void 0, void 0, function () {\n        var now;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"saveLastAccessTokenUpdate: called\");\n                    now = Date.now().toString();\n                    (0, logger_1.logDebugMessage)(\"saveLastAccessTokenUpdate: setting \" + now);\n                    return [4 /*yield*/, storeInCookies(LAST_ACCESS_TOKEN_UPDATE, now, Number.MAX_SAFE_INTEGER)];\n                case 1:\n                    _b.sent();\n                    // We clear the sIRTFrontend cookie\n                    // We are handling this as a special case here because we want to limit the scope of legacy code\n                    return [4 /*yield*/, storeInCookies(\"sIRTFrontend\", \"\", 0)];\n                case 2:\n                    // We clear the sIRTFrontend cookie\n                    // We are handling this as a special case here because we want to limit the scope of legacy code\n                    _b.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.saveLastAccessTokenUpdate = saveLastAccessTokenUpdate;\nfunction getAntiCSRFToken() {\n    return __awaiter(this, void 0, void 0, function () {\n        function getAntiCSRFromCookie() {\n            return __awaiter(this, void 0, void 0, function () {\n                var value, _b, parts, last, temp;\n                return __generator(this, function (_c) {\n                    switch (_c.label) {\n                        case 0:\n                            _b = \"; \";\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()\n                            ];\n                        case 1:\n                            value = _b + _c.sent();\n                            parts = value.split(\"; \" + ANTI_CSRF_NAME + \"=\");\n                            if (parts.length >= 2) {\n                                last = parts.pop();\n                                if (last !== undefined) {\n                                    temp = last.split(\";\").shift();\n                                    if (temp === undefined) {\n                                        return [2 /*return*/, null];\n                                    }\n                                    return [2 /*return*/, temp];\n                                }\n                            }\n                            return [2 /*return*/, null];\n                    }\n                });\n            });\n        }\n        var fromCookie;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: called\");\n                    return [4 /*yield*/, getLocalSessionState(true)];\n                case 1:\n                    // we do not call doesSessionExist here cause the user might override that\n                    // function here and then it may break the logic of our original implementation.\n                    if (!(_b.sent().status === \"EXISTS\")) {\n                        (0, logger_1.logDebugMessage)(\n                            \"getAntiCSRFToken: Returning because local session state != EXISTS\"\n                        );\n                        return [2 /*return*/, null];\n                    }\n                    return [4 /*yield*/, getAntiCSRFromCookie()];\n                case 2:\n                    fromCookie = _b.sent();\n                    (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: returning: \" + fromCookie);\n                    return [2 /*return*/, fromCookie];\n            }\n        });\n    });\n}\n// give antiCSRFToken as undefined to remove it.\nfunction setAntiCSRF(antiCSRFToken) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"setAntiCSRF: called: \" + antiCSRFToken);\n                    if (!(antiCSRFToken !== undefined)) return [3 /*break*/, 2];\n                    return [4 /*yield*/, storeInCookies(ANTI_CSRF_NAME, antiCSRFToken, Number.MAX_SAFE_INTEGER)];\n                case 1:\n                    _b.sent();\n                    return [3 /*break*/, 4];\n                case 2:\n                    return [4 /*yield*/, storeInCookies(ANTI_CSRF_NAME, \"\", 0)];\n                case 3:\n                    _b.sent();\n                    _b.label = 4;\n                case 4:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.setAntiCSRF = setAntiCSRF;\nfunction getFrontTokenFromCookie() {\n    return __awaiter(this, void 0, void 0, function () {\n        var val;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"getFrontTokenFromCookie: called\");\n                    return [4 /*yield*/, getFromCookies(FRONT_TOKEN_NAME)];\n                case 1:\n                    val = _b.sent();\n                    return [2 /*return*/, val === undefined ? null : val];\n            }\n        });\n    });\n}\nfunction parseFrontToken(frontToken) {\n    return JSON.parse(decodeURIComponent(escape(atob(frontToken))));\n}\nfunction getFrontToken() {\n    return __awaiter(this, void 0, void 0, function () {\n        var fromCookie;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"getFrontToken: called\");\n                    return [4 /*yield*/, getLocalSessionState(true)];\n                case 1:\n                    // we do not call doesSessionExist here because that directly calls this function.\n                    if (!(_b.sent().status === \"EXISTS\")) {\n                        (0, logger_1.logDebugMessage)(\"getFrontToken: Returning because sIRTFrontend != EXISTS\");\n                        return [2 /*return*/, null];\n                    }\n                    return [4 /*yield*/, getFrontTokenFromCookie()];\n                case 2:\n                    fromCookie = _b.sent();\n                    (0, logger_1.logDebugMessage)(\"getFrontToken: returning: \" + fromCookie);\n                    return [2 /*return*/, fromCookie];\n            }\n        });\n    });\n}\nexports.getFrontToken = getFrontToken;\nfunction setFrontToken(frontToken) {\n    return __awaiter(this, void 0, void 0, function () {\n        var oldToken, oldPayload, newPayload;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"setFrontToken: called\");\n                    return [4 /*yield*/, getFrontTokenFromCookie()];\n                case 1:\n                    oldToken = _b.sent();\n                    if (oldToken !== null && frontToken !== undefined) {\n                        oldPayload = parseFrontToken(oldToken).up;\n                        newPayload = parseFrontToken(frontToken).up;\n                        if (JSON.stringify(oldPayload) !== JSON.stringify(newPayload)) {\n                            onTokenUpdate();\n                        }\n                    }\n                    if (!(frontToken === undefined)) return [3 /*break*/, 3];\n                    // clear the cookie\n                    return [4 /*yield*/, storeInCookies(FRONT_TOKEN_NAME, \"\", 0)];\n                case 2:\n                    // clear the cookie\n                    _b.sent();\n                    return [3 /*break*/, 5];\n                case 3:\n                    return [4 /*yield*/, storeInCookies(FRONT_TOKEN_NAME, frontToken, Number.MAX_SAFE_INTEGER)];\n                case 4:\n                    _b.sent();\n                    _b.label = 5;\n                case 5:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.setFrontToken = setFrontToken;\nfunction fireSessionUpdateEventsIfNecessary(wasLoggedIn, status, frontTokenHeaderFromResponse) {\n    // In case we've received a 401 that didn't clear the session (e.g.: we've sent no session token, or we should try refreshing)\n    // then onUnauthorised will handle firing the UNAUTHORISED event if necessary\n    // In some rare cases (where we receive a 401 that also clears the session) this will fire the event twice.\n    // This may be considered a bug, but it is the existing behaviour before the rework\n    if (frontTokenHeaderFromResponse === undefined || frontTokenHeaderFromResponse === null) {\n        // The access token (and the session) hasn't been updated.\n        (0, logger_1.logDebugMessage)(\n            \"fireSessionUpdateEventsIfNecessary returning early because the front token was not updated\"\n        );\n        return;\n    }\n    // if the current endpoint clears the session it'll set the front-token to remove\n    // any other update means it's created or updated.\n    var frontTokenExistsAfter = frontTokenHeaderFromResponse !== \"remove\";\n    (0, logger_1.logDebugMessage)(\n        \"fireSessionUpdateEventsIfNecessary wasLoggedIn: \"\n            .concat(wasLoggedIn, \" frontTokenExistsAfter: \")\n            .concat(frontTokenExistsAfter, \" status: \")\n            .concat(status)\n    );\n    if (wasLoggedIn) {\n        // we check for wasLoggedIn cause we don't want to fire an event\n        // unnecessarily on first app load or if the user tried\n        // to query an API that returned 401 while the user was not logged in...\n        if (!frontTokenExistsAfter) {\n            if (status === AuthHttpRequest.config.sessionExpiredStatusCode) {\n                (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: firing UNAUTHORISED event\");\n                AuthHttpRequest.config.onHandleEvent({\n                    action: \"UNAUTHORISED\",\n                    sessionExpiredOrRevoked: true,\n                    userContext: {}\n                });\n            } else {\n                (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: firing SIGN_OUT event\");\n                AuthHttpRequest.config.onHandleEvent({\n                    action: \"SIGN_OUT\",\n                    userContext: {}\n                });\n            }\n        }\n    } else if (frontTokenExistsAfter) {\n        (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: firing SESSION_CREATED event\");\n        AuthHttpRequest.config.onHandleEvent({\n            action: \"SESSION_CREATED\",\n            userContext: {}\n        });\n    }\n}\nexports.fireSessionUpdateEventsIfNecessary = fireSessionUpdateEventsIfNecessary;\n"]},"metadata":{},"sourceType":"script"}
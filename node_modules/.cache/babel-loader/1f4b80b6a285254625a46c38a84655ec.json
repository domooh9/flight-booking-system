{"ast":null,"code":"\"use strict\";\n\nvar sessionAuth = require(\"./session-shared.js\");\n\nvar jsxRuntime = require(\"react/jsx-runtime\");\n\nvar translationContext = require(\"./translationContext.js\");\n\nvar postSuperTokensInitCallbacks = require(\"supertokens-web-js/utils/postSuperTokensInitCallbacks\");\n\nvar React = require(\"react\");\n\nvar session = require(\"./session-shared2.js\");\n\nfunction SuperTokensBranding() {\n  var t = translationContext.useTranslation();\n  return jsxRuntime.jsxs(\"a\", sessionAuth.__assign({\n    \"data-supertokens\": \"superTokensBranding\",\n    href: \"https://supertokens.com?utm_campaign=poweredby\",\n    target: \"_blank\"\n  }, {\n    children: [t(\"BRANDING_POWERED_BY_START\"), jsxRuntime.jsx(\"strong\", {\n      children: \"SuperTokens\"\n    }), t(\"BRANDING_POWERED_BY_END\")]\n  }));\n}\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n\nvar AuthRecipe =\n/** @class */\nfunction (_super) {\n  sessionAuth.__extends(AuthRecipe, _super);\n\n  function AuthRecipe(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.getAuthRecipeDefaultRedirectionURL = function (context) {\n      return sessionAuth.__awaiter(_this, void 0, void 0, function () {\n        return sessionAuth.__generator(this, function (_a) {\n          if (context.action === \"SUCCESS\") {\n            return [2\n            /*return*/\n            , context.redirectToPath === undefined ? \"/\" : context.redirectToPath];\n          } else {\n            throw new Error(\"Should never come here\");\n          }\n        });\n      });\n    };\n\n    _this.signOut = function (input) {\n      return sessionAuth.__awaiter(_this, void 0, void 0, function () {\n        return sessionAuth.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , sessionAuth.Session.getInstanceOrThrow().signOut({\n                userContext: sessionAuth.getNormalisedUserContext(input === null || input === void 0 ? void 0 : input.userContext)\n              })];\n\n            case 1:\n              return [2\n              /*return*/\n              , _a.sent()];\n          }\n        });\n      });\n    };\n\n    _this.doesSessionExist = function (input) {\n      return sessionAuth.__awaiter(_this, void 0, void 0, function () {\n        return sessionAuth.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , sessionAuth.Session.getInstanceOrThrow().doesSessionExist({\n                userContext: sessionAuth.getNormalisedUserContext(input === null || input === void 0 ? void 0 : input.userContext)\n              })];\n\n            case 1:\n              return [2\n              /*return*/\n              , _a.sent()];\n          }\n        });\n      });\n    };\n\n    postSuperTokensInitCallbacks.PostSuperTokensInitCallbacks.addPostInitCallback(function () {\n      var session = sessionAuth.Session.getInstance();\n\n      if (session !== undefined) {\n        session.addAuthRecipeRedirectionHandler(_this.config.recipeId, _this.redirect.bind(_this));\n      }\n    });\n    return _this;\n  }\n\n  return AuthRecipe;\n}(sessionAuth.RecipeModule);\n/**\n * AuthWidgetWrapper shows the children component only if no session exists,\n * else it calls onSessionAlreadyExists\n */\n\n\nvar AuthWidgetWrapper = function (props) {\n  return jsxRuntime.jsx(session.SessionAuth, sessionAuth.__assign({\n    requireAuth: false,\n    doRedirection: false\n  }, {\n    children: jsxRuntime.jsx(Redirector, sessionAuth.__assign({}, props))\n  }));\n};\n\nvar Redirector = function (props) {\n  var sessionContext = React.useContext(sessionAuth.SessionContext);\n  var userContext = sessionAuth.useUserContext();\n\n  var _a = React.useState(false),\n      alwaysShow = _a[0],\n      updateAlwaysShow = _a[1];\n\n  React.useEffect(function () {\n    // we want to do this just once, so we supply it with only the loading state.\n    // if we supply it with props, sessionContext, then once the user signs in, then this will route the\n    // user to the dashboard, as opposed to the sign up / sign in functions.\n    if (sessionContext.loading === false) {\n      if (sessionContext.doesSessionExist) {\n        if (props.onSessionAlreadyExists !== undefined) {\n          props.onSessionAlreadyExists();\n        } else {\n          props.authRecipe.config.onHandleEvent({\n            action: \"SESSION_ALREADY_EXISTS\"\n          });\n          void sessionAuth.Session.getInstanceOrThrow().validateGlobalClaimsAndHandleSuccessRedirection({\n            rid: props.authRecipe.config.recipeId,\n            successRedirectContext: {\n              action: \"SUCCESS\",\n              isNewUser: false,\n              redirectToPath: sessionAuth.getRedirectToPathFromURL()\n            }\n          }, userContext, props.history);\n        }\n      } else {\n        // this means even if a session exists, we will still show the children\n        // cause the child component will take care of redirecting etc..\n        updateAlwaysShow(true);\n      }\n    }\n  }, [sessionContext.loading]);\n\n  if ((sessionContext.loading === true || sessionContext.doesSessionExist) && !alwaysShow) {\n    return null;\n  } else {\n    return jsxRuntime.jsx(jsxRuntime.Fragment, {\n      children: props.children\n    });\n  }\n};\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction normaliseAuthRecipe(config) {\n  return sessionAuth.normaliseRecipeModuleConfig(config);\n}\n\nexports.AuthRecipe = AuthRecipe;\nexports.AuthWidgetWrapper = AuthWidgetWrapper;\nexports.SuperTokensBranding = SuperTokensBranding;\nexports.normaliseAuthRecipe = normaliseAuthRecipe;","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["\"use strict\";\n\nvar sessionAuth = require(\"./session-shared.js\");\nvar jsxRuntime = require(\"react/jsx-runtime\");\nvar translationContext = require(\"./translationContext.js\");\nvar postSuperTokensInitCallbacks = require(\"supertokens-web-js/utils/postSuperTokensInitCallbacks\");\nvar React = require(\"react\");\nvar session = require(\"./session-shared2.js\");\n\nfunction SuperTokensBranding() {\n    var t = translationContext.useTranslation();\n    return jsxRuntime.jsxs(\n        \"a\",\n        sessionAuth.__assign(\n            {\n                \"data-supertokens\": \"superTokensBranding\",\n                href: \"https://supertokens.com?utm_campaign=poweredby\",\n                target: \"_blank\",\n            },\n            {\n                children: [\n                    t(\"BRANDING_POWERED_BY_START\"),\n                    jsxRuntime.jsx(\"strong\", { children: \"SuperTokens\" }),\n                    t(\"BRANDING_POWERED_BY_END\"),\n                ],\n            }\n        )\n    );\n}\n\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\nvar AuthRecipe = /** @class */ (function (_super) {\n    sessionAuth.__extends(AuthRecipe, _super);\n    function AuthRecipe(config) {\n        var _this = _super.call(this, config) || this;\n        _this.getAuthRecipeDefaultRedirectionURL = function (context) {\n            return sessionAuth.__awaiter(_this, void 0, void 0, function () {\n                return sessionAuth.__generator(this, function (_a) {\n                    if (context.action === \"SUCCESS\") {\n                        return [2 /*return*/, context.redirectToPath === undefined ? \"/\" : context.redirectToPath];\n                    } else {\n                        throw new Error(\"Should never come here\");\n                    }\n                });\n            });\n        };\n        _this.signOut = function (input) {\n            return sessionAuth.__awaiter(_this, void 0, void 0, function () {\n                return sessionAuth.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            return [\n                                4 /*yield*/,\n                                sessionAuth.Session.getInstanceOrThrow().signOut({\n                                    userContext: sessionAuth.getNormalisedUserContext(\n                                        input === null || input === void 0 ? void 0 : input.userContext\n                                    ),\n                                }),\n                            ];\n                        case 1:\n                            return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        _this.doesSessionExist = function (input) {\n            return sessionAuth.__awaiter(_this, void 0, void 0, function () {\n                return sessionAuth.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            return [\n                                4 /*yield*/,\n                                sessionAuth.Session.getInstanceOrThrow().doesSessionExist({\n                                    userContext: sessionAuth.getNormalisedUserContext(\n                                        input === null || input === void 0 ? void 0 : input.userContext\n                                    ),\n                                }),\n                            ];\n                        case 1:\n                            return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        postSuperTokensInitCallbacks.PostSuperTokensInitCallbacks.addPostInitCallback(function () {\n            var session = sessionAuth.Session.getInstance();\n            if (session !== undefined) {\n                session.addAuthRecipeRedirectionHandler(_this.config.recipeId, _this.redirect.bind(_this));\n            }\n        });\n        return _this;\n    }\n    return AuthRecipe;\n})(sessionAuth.RecipeModule);\n\n/**\n * AuthWidgetWrapper shows the children component only if no session exists,\n * else it calls onSessionAlreadyExists\n */\nvar AuthWidgetWrapper = function (props) {\n    return jsxRuntime.jsx(\n        session.SessionAuth,\n        sessionAuth.__assign(\n            { requireAuth: false, doRedirection: false },\n            { children: jsxRuntime.jsx(Redirector, sessionAuth.__assign({}, props)) }\n        )\n    );\n};\nvar Redirector = function (props) {\n    var sessionContext = React.useContext(sessionAuth.SessionContext);\n    var userContext = sessionAuth.useUserContext();\n    var _a = React.useState(false),\n        alwaysShow = _a[0],\n        updateAlwaysShow = _a[1];\n    React.useEffect(\n        function () {\n            // we want to do this just once, so we supply it with only the loading state.\n            // if we supply it with props, sessionContext, then once the user signs in, then this will route the\n            // user to the dashboard, as opposed to the sign up / sign in functions.\n            if (sessionContext.loading === false) {\n                if (sessionContext.doesSessionExist) {\n                    if (props.onSessionAlreadyExists !== undefined) {\n                        props.onSessionAlreadyExists();\n                    } else {\n                        props.authRecipe.config.onHandleEvent({\n                            action: \"SESSION_ALREADY_EXISTS\",\n                        });\n                        void sessionAuth.Session.getInstanceOrThrow().validateGlobalClaimsAndHandleSuccessRedirection(\n                            {\n                                rid: props.authRecipe.config.recipeId,\n                                successRedirectContext: {\n                                    action: \"SUCCESS\",\n                                    isNewUser: false,\n                                    redirectToPath: sessionAuth.getRedirectToPathFromURL(),\n                                },\n                            },\n                            userContext,\n                            props.history\n                        );\n                    }\n                } else {\n                    // this means even if a session exists, we will still show the children\n                    // cause the child component will take care of redirecting etc..\n                    updateAlwaysShow(true);\n                }\n            }\n        },\n        [sessionContext.loading]\n    );\n    if ((sessionContext.loading === true || sessionContext.doesSessionExist) && !alwaysShow) {\n        return null;\n    } else {\n        return jsxRuntime.jsx(jsxRuntime.Fragment, { children: props.children });\n    }\n};\n\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\nfunction normaliseAuthRecipe(config) {\n    return sessionAuth.normaliseRecipeModuleConfig(config);\n}\n\nexports.AuthRecipe = AuthRecipe;\nexports.AuthWidgetWrapper = AuthWidgetWrapper;\nexports.SuperTokensBranding = SuperTokensBranding;\nexports.normaliseAuthRecipe = normaliseAuthRecipe;\n"]},"metadata":{},"sourceType":"script"}
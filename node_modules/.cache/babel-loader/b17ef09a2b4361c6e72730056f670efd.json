{"ast":null,"code":"\"use strict\";\n\nvar jsxRuntime = require(\"react/jsx-runtime\");\n\nvar React = require(\"react\");\n\nvar cookieHandler = require(\"supertokens-web-js/utils/cookieHandler\");\n\nvar postSuperTokensInitCallbacks = require(\"supertokens-web-js/utils/postSuperTokensInitCallbacks\");\n\nvar windowHandler = require(\"supertokens-web-js/utils/windowHandler\");\n\nvar NormalisedURLPath = require(\"supertokens-web-js/utils/normalisedURLPath\");\n\nvar NormalisedURLDomain = require(\"supertokens-web-js/utils/normalisedURLDomain\");\n\nvar recipe = require(\"supertokens-web-js/recipe/session/recipe\");\n\nfunction _interopDefault(e) {\n  return e && e.__esModule ? e : {\n    default: e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== \"default\") {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nvar NormalisedURLPath__default = /*#__PURE__*/_interopDefault(NormalisedURLPath);\n\nvar NormalisedURLDomain__default = /*#__PURE__*/_interopDefault(NormalisedURLDomain);\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexports.__assign = function () {\n  exports.__assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return exports.__assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    throw: verb(1),\n    return: verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction RoutingComponent(props) {\n  var _a;\n\n  var stInstance = props.supertokensInstance;\n  var path = props.path;\n  var componentToRender = React__namespace.default.useMemo(function () {\n    // During development, this runs twice so as to warn devs of if there\n    // are any side effects that happen here. So in tests, it will result in\n    // the console log twice\n    return stInstance.getMatchingComponentForRouteAndRecipeId(new NormalisedURLPath__default.default(path));\n  }, [stInstance, path]);\n  var history = (_a = props.supertokensInstance.getReactRouterDomWithCustomHistory()) === null || _a === void 0 ? void 0 : _a.useHistoryCustom();\n\n  if (componentToRender === undefined) {\n    return null;\n  }\n\n  return jsxRuntime.jsx(componentToRender.component, {\n    history: history\n  });\n}\n/*\n * Component.\n */\n\n\nfunction getSuperTokensRoutesForReactRouterDom(supertokensInstance) {\n  var routerInfo = supertokensInstance.getReactRouterDomWithCustomHistory();\n\n  if (routerInfo === undefined) {\n    return [];\n  }\n\n  var Route = routerInfo.router.Route;\n  var pathsToFeatureComponentWithRecipeIdMap = supertokensInstance.getPathsToFeatureComponentWithRecipeIdMap();\n  return Object.keys(pathsToFeatureComponentWithRecipeIdMap).map(function (path) {\n    path = path === \"\" ? \"/\" : path;\n    return jsxRuntime.jsx(Route, exports.__assign({\n      exact: true,\n      path: path\n    }, {\n      children: jsxRuntime.jsx(RoutingComponent, {\n        supertokensInstance: supertokensInstance,\n        path: path\n      })\n    }), \"st-\".concat(path));\n  });\n}\n/*\n * Component.\n */\n\n\nfunction getSuperTokensRoutesForReactRouterDomV6(supertokensInstance) {\n  var routerInfo = supertokensInstance.getReactRouterDomWithCustomHistory();\n\n  if (routerInfo === undefined) {\n    return [];\n  }\n\n  var Route = routerInfo.router.Route;\n  var pathsToFeatureComponentWithRecipeIdMap = supertokensInstance.getPathsToFeatureComponentWithRecipeIdMap();\n  return Object.keys(pathsToFeatureComponentWithRecipeIdMap).map(function (path) {\n    path = path === \"\" ? \"/\" : path;\n    return jsxRuntime.jsx(Route, {\n      path: path,\n      element: jsxRuntime.jsx(RoutingComponent, {\n        supertokensInstance: supertokensInstance,\n        path: path\n      })\n    }, \"st-\".concat(path));\n  });\n}\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n/*\n * Consts.\n */\n\n\nvar RECIPE_ID_QUERY_PARAM = \"rid\";\nvar DEFAULT_API_BASE_PATH = \"/auth\";\nvar DEFAULT_WEBSITE_BASE_PATH = \"/auth\";\nvar ST_ROOT_ID = \"supertokens-root\";\nvar SSR_ERROR = \"\\nIf you are trying to use this method doing server-side-rendering, please make sure you move this method inside a componentDidMount method or useEffect hook.\";\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n/*\n * getRecipeIdFromPath\n * Input:\n * Output: The \"rid\" query param if present, null otherwise.\n */\n\nfunction getRecipeIdFromSearch(search) {\n  var urlParams = new URLSearchParams(search);\n  return urlParams.get(RECIPE_ID_QUERY_PARAM);\n}\n\nfunction clearQueryParams(paramNames) {\n  var newURL = new URL(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHref());\n\n  for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {\n    var param = paramNames_1[_i];\n    newURL.searchParams.delete(param);\n  }\n\n  windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.history.replaceState(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.history.getState(), \"\", windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHref());\n}\n\nfunction clearErrorQueryParam() {\n  clearQueryParams([\"error\", \"message\"]);\n}\n\nfunction getQueryParams(param) {\n  var urlParams = new URLSearchParams(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getSearch());\n  return urlParams.get(param);\n}\n\nfunction getURLHash() {\n  // By default it is returined with the \"#\" at the beginning, we cut that off here.\n  return windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHash().substr(1);\n}\n\nfunction getRedirectToPathFromURL() {\n  var param = getQueryParams(\"redirectToPath\");\n\n  if (param === null) {\n    return undefined;\n  } else {\n    // Prevent Open redirects by normalising path.\n    try {\n      var normalisedURLPath = new NormalisedURLPath__default.default(param).getAsStringDangerous();\n      var pathQueryParams = param.split(\"?\")[1] !== undefined ? \"?\".concat(param.split(\"?\")[1]) : \"\";\n      return normalisedURLPath + pathQueryParams;\n    } catch (_a) {\n      return undefined;\n    }\n  }\n}\n/*\n * isTest\n */\n\n\nfunction isTest() {\n  try {\n    return process.env.TEST_MODE === \"testing\";\n  } catch (err) {\n    // can get Uncaught ReferenceError: process is not defined error\n    return false;\n  }\n}\n\nfunction normaliseInputAppInfoOrThrowError(appInfo) {\n  if (appInfo === undefined) {\n    throw new Error(\"Please provide the appInfo object when calling supertokens.init\");\n  }\n\n  if (appInfo.apiDomain === undefined) {\n    throw new Error(\"Please provide your apiDomain inside the appInfo object when calling supertokens.init\");\n  }\n\n  if (appInfo.appName === undefined) {\n    throw new Error(\"Please provide your appName inside the appInfo object when calling supertokens.init\");\n  }\n\n  if (appInfo.websiteDomain === undefined) {\n    throw new Error(\"Please provide your websiteDomain inside the appInfo object when calling supertokens.init\");\n  }\n\n  var apiGatewayPath = new NormalisedURLPath__default.default(\"\");\n\n  if (appInfo.apiGatewayPath !== undefined) {\n    apiGatewayPath = new NormalisedURLPath__default.default(appInfo.apiGatewayPath);\n  }\n\n  return {\n    appName: appInfo.appName,\n    apiDomain: new NormalisedURLDomain__default.default(appInfo.apiDomain),\n    websiteDomain: new NormalisedURLDomain__default.default(appInfo.websiteDomain),\n    apiBasePath: apiGatewayPath.appendPath(getNormalisedURLPathOrDefault(DEFAULT_API_BASE_PATH, appInfo.apiBasePath)),\n    websiteBasePath: getNormalisedURLPathOrDefault(DEFAULT_WEBSITE_BASE_PATH, appInfo.websiteBasePath)\n  };\n}\n\nfunction getNormalisedURLPathOrDefault(defaultPath, path) {\n  if (path !== undefined) {\n    return new NormalisedURLPath__default.default(path);\n  } else {\n    return new NormalisedURLPath__default.default(defaultPath);\n  }\n}\n/*\n * validateForm\n */\n// We check that the number of fields in input and config form field is the same.\n// We check that each item in the config form field is also present in the input form field\n\n\nfunction validateForm(inputs, configFormFields) {\n  return __awaiter(this, void 0, void 0, function () {\n    var validationErrors, _loop_1, i;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          validationErrors = [];\n\n          if (configFormFields.length !== inputs.length) {\n            throw Error(\"Are you sending too many / too few formFields?\");\n          }\n\n          _loop_1 = function (i) {\n            var field, input, value, error;\n            return __generator(this, function (_b) {\n              switch (_b.label) {\n                case 0:\n                  field = configFormFields[i];\n                  input = inputs.find(function (i) {\n                    return i.id === field.id;\n                  });\n                  value = input.value;\n\n                  if (input.id === \"email\") {\n                    value = value.trim();\n                  }\n\n                  return [4\n                  /*yield*/\n                  , field.validate(value)];\n\n                case 1:\n                  error = _b.sent(); // If error, add it.\n\n                  if (error !== undefined) {\n                    validationErrors.push({\n                      error: error,\n                      id: field.id\n                    });\n                  }\n\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          };\n\n          i = 0;\n          _a.label = 1;\n\n        case 1:\n          if (!(i < configFormFields.length)) return [3\n          /*break*/\n          , 4];\n          return [5\n          /*yield**/\n          , _loop_1(i)];\n\n        case 2:\n          _a.sent();\n\n          _a.label = 3;\n\n        case 3:\n          i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          return [2\n          /*return*/\n          , validationErrors];\n      }\n    });\n  });\n}\n/*\n * getCurrentNormalisedUrlPath\n */\n\n\nfunction getCurrentNormalisedUrlPath() {\n  return new NormalisedURLPath__default.default(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getPathName());\n}\n\nfunction appendQueryParamsToURL(stringUrl, queryParams) {\n  if (queryParams === undefined) {\n    return stringUrl;\n  }\n\n  try {\n    var url_1 = new URL(stringUrl);\n    Object.entries(queryParams).forEach(function (_a) {\n      var key = _a[0],\n          value = _a[1];\n      url_1.searchParams.set(key, value);\n    });\n    return url_1.href;\n  } catch (e) {\n    var fakeDomain = stringUrl.startsWith(\"/\") ? \"http:localhost\" : \"http://localhost/\";\n    var url_2 = new URL(\"\".concat(fakeDomain).concat(stringUrl));\n    Object.entries(queryParams).forEach(function (_a) {\n      var key = _a[0],\n          value = _a[1];\n      url_2.searchParams.set(key, value);\n    });\n    return \"\".concat(url_2.pathname).concat(url_2.search);\n  }\n}\n\nfunction appendTrailingSlashToURL(stringUrl) {\n  return stringUrl.endsWith(\"/\") ? stringUrl : stringUrl + \"/\";\n}\n/*\n * Default method for matching recipe route based on query params.\n */\n\n\nfunction matchRecipeIdUsingQueryParams(recipeId) {\n  return function () {\n    var recipeIdFromSearch = getRecipeIdFromSearch(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getSearch());\n    return recipeIdFromSearch === recipeId;\n  };\n}\n\nfunction redirectWithFullPageReload(to) {\n  if (to.trim() === \"\") {\n    to = \"/\";\n  }\n\n  windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.setHref(to);\n}\n\nfunction redirectWithHistory(to, history) {\n  if (to.trim() === \"\") {\n    to = \"/\";\n  }\n\n  if (history.push !== undefined) {\n    // we are using react-router-dom that is before v6\n    history.push(to);\n  } else {\n    // in react-router-dom v6, it is just navigate(to), and we are renaming\n    // naviagte to history, so it becomes history(to).\n    history(to);\n  }\n}\n\nfunction isIE() {\n  return windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.getDocument().documentMode !== undefined;\n}\n\nfunction getOriginOfPage() {\n  return new NormalisedURLDomain__default.default(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getOrigin());\n}\n\nfunction getLocalStorage(key) {\n  return __awaiter(this, void 0, void 0, function () {\n    var res;\n    return __generator(this, function (_a) {\n      res = windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.getItem(key);\n\n      if (res === null || res === undefined) {\n        return [2\n        /*return*/\n        , null];\n      }\n\n      return [2\n      /*return*/\n      , res];\n    });\n  });\n}\n\nfunction setLocalStorage(key, value) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.setItem(key, value)];\n\n        case 1:\n          _a.sent();\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction removeFromLocalStorage(key) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.removeItem(key)];\n\n        case 1:\n          _a.sent();\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction mergeObjects(obj1, obj2) {\n  var res = exports.__assign({}, obj1);\n\n  for (var key in obj2) {\n    if (typeof res[key] === \"object\" && typeof obj2[key] === \"object\") {\n      res[key] = mergeObjects(res[key], obj2[key]);\n    } else {\n      res[key] = obj2[key];\n    }\n  }\n\n  return res;\n}\n\nfunction normaliseCookieScopeOrThrowError(cookieScope) {\n  function helper(cookieScope) {\n    cookieScope = cookieScope.trim().toLowerCase(); // first we convert it to a URL so that we can use the URL class\n\n    if (cookieScope.startsWith(\".\")) {\n      cookieScope = cookieScope.substr(1);\n    }\n\n    if (!cookieScope.startsWith(\"http://\") && !cookieScope.startsWith(\"https://\")) {\n      cookieScope = \"http://\" + cookieScope;\n    }\n\n    try {\n      var urlObj = new URL(cookieScope);\n      cookieScope = urlObj.hostname; // remove leading dot\n\n      if (cookieScope.startsWith(\".\")) {\n        cookieScope = cookieScope.substr(1);\n      }\n\n      return cookieScope;\n    } catch (err) {\n      throw new Error(\"Please provide a valid cookie scope\");\n    }\n  }\n\n  function isAnIpAddress(ipaddress) {\n    return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ipaddress);\n  }\n\n  var noDotNormalised = helper(cookieScope);\n\n  if (noDotNormalised === \"localhost\" || isAnIpAddress(noDotNormalised)) {\n    return noDotNormalised;\n  }\n\n  if (cookieScope.startsWith(\".\")) {\n    return \".\" + noDotNormalised;\n  }\n\n  return noDotNormalised;\n}\n\nfunction getDefaultCookieScope() {\n  try {\n    return normaliseCookieScopeOrThrowError(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHostName());\n  } catch (_a) {\n    return undefined;\n  }\n}\n\nfunction getCookieValue(name) {\n  return __awaiter(this, void 0, void 0, function () {\n    var value, _a, parts, last, temp;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _a = \"; \";\n          return [4\n          /*yield*/\n          , cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.getCookie()];\n\n        case 1:\n          value = _a + _b.sent();\n          parts = value.split(\"; \" + name + \"=\");\n\n          if (parts.length >= 2) {\n            last = parts.pop();\n\n            if (last !== undefined) {\n              temp = last.split(\";\").shift();\n\n              if (temp === undefined) {\n                return [2\n                /*return*/\n                , null];\n              }\n\n              return [2\n              /*return*/\n              , temp];\n            }\n          }\n\n          return [2\n          /*return*/\n          , null];\n      }\n    });\n  });\n} // undefined value will remove the cookie\n\n\nfunction setFrontendCookie(name, value, scope) {\n  return __awaiter(this, void 0, void 0, function () {\n    var expires, cookieVal;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          expires = \"Thu, 01 Jan 1970 00:00:01 GMT\";\n          cookieVal = \"\";\n\n          if (value !== undefined) {\n            cookieVal = value;\n            expires = undefined; // set cookie without expiry\n          }\n\n          if (!(scope === \"localhost\" || scope === windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHostName() || scope === undefined)) return [3\n          /*break*/\n          , 5];\n          if (!(expires !== undefined)) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(name, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";path=/;samesite=lax\"))];\n\n        case 1:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 4];\n\n        case 2:\n          return [4\n          /*yield*/\n          , cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(name, \"=\").concat(cookieVal, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=lax\"))];\n\n        case 3:\n          _a.sent();\n\n          _a.label = 4;\n\n        case 4:\n          return [3\n          /*break*/\n          , 9];\n\n        case 5:\n          if (!(expires !== undefined)) return [3\n          /*break*/\n          , 7];\n          return [4\n          /*yield*/\n          , cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(name, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";domain=\").concat(scope, \";path=/;samesite=lax\"))];\n\n        case 6:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 9];\n\n        case 7:\n          return [4\n          /*yield*/\n          , cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(name, \"=\").concat(cookieVal, \";domain=\").concat(scope, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=lax\"))];\n\n        case 8:\n          _a.sent();\n\n          _a.label = 9;\n\n        case 9:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction getNormalisedUserContext(userContext) {\n  return userContext === undefined ? {} : userContext;\n}\n/**\n * This function handles calling APIs that should only be called once during mount (mostly on mount of a route/feature component).\n * It's split into multiple callbacks (fetch + handleResponse/handleError) because we expect fetch to take longer and\n * and the component may be unmounted during the first fetch, in which case we want to avoid updating state/redirecting.\n * This is especially relevant for development in strict mode with React 18 (and in the future for concurrent rendering).\n *\n * @param fetch This is a callback that is only called once on mount. Mostly it's for consuming tokens/doing one time only API calls\n * @param handleResponse This is called with the result of the first (fetch) call if it succeeds.\n * @param handleError This is called with the error of the first (fetch) call if it rejects.\n * @param startLoading Will start the whole process if this is set to true (or omitted). Mostly used to wait for session loading.\n */\n\n\nvar useOnMountAPICall = function (fetch, handleResponse, handleError, startLoading) {\n  if (startLoading === void 0) {\n    startLoading = true;\n  }\n\n  var consumeReq = React.useRef();\n\n  var _a = React.useState(undefined),\n      error = _a[0],\n      setError = _a[1];\n\n  React.useEffect(function () {\n    var effect = function (signal) {\n      return __awaiter(void 0, void 0, void 0, function () {\n        var resp, err_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              if (consumeReq.current === undefined) {\n                consumeReq.current = fetch();\n              }\n\n              return [4\n              /*yield*/\n              , consumeReq.current];\n\n            case 1:\n              resp = _a.sent();\n\n              if (!signal.aborted) {\n                void handleResponse(resp);\n              }\n\n              return [3\n              /*break*/\n              , 3];\n\n            case 2:\n              err_1 = _a.sent();\n\n              if (!signal.aborted) {\n                if (handleError !== undefined) {\n                  handleError(err_1, resp);\n                } else {\n                  setError(err_1);\n                }\n              }\n\n              return [3\n              /*break*/\n              , 3];\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    if (startLoading) {\n      var ctrl_1 = new AbortController();\n      void effect(ctrl_1.signal);\n      return function () {\n        ctrl_1.abort();\n      };\n    }\n\n    return;\n  }, [setError, consumeReq, fetch, handleResponse, handleError, startLoading]);\n\n  if (error) {\n    throw error;\n  }\n};\n\nfunction saveInvalidClaimRedirectPathInContext(userContext, invalidClaimRedirectPath) {\n  if (userContext[\"_default\"] === undefined) {\n    userContext[\"_default\"] = {};\n  }\n\n  if (userContext[\"_default\"].redirectPath === undefined) {\n    userContext[\"_default\"] = exports.__assign(exports.__assign({}, userContext[\"_default\"]), {\n      invalidClaimRedirectPath: invalidClaimRedirectPath\n    });\n  }\n}\n\nfunction popInvalidClaimRedirectPathFromContext(userContext) {\n  var _a;\n\n  var res = (_a = userContext[\"_default\"]) === null || _a === void 0 ? void 0 : _a.invalidClaimRedirectPath;\n\n  if (res !== undefined) {\n    delete userContext[\"_default\"].invalidClaimRedirectPath;\n  }\n\n  return res;\n}\n\nvar TranslationController =\n/** @class */\nfunction () {\n  function TranslationController() {\n    this.handlers = new Map();\n  }\n\n  TranslationController.prototype.emit = function (event, detail) {\n    var handlerList = this.handlers.get(event) || [];\n\n    for (var _i = 0, handlerList_1 = handlerList; _i < handlerList_1.length; _i++) {\n      var h = handlerList_1[_i];\n      h(event, detail);\n    }\n  };\n\n  TranslationController.prototype.on = function (event, handler) {\n    var handlerList = this.handlers.get(event) || [];\n    this.handlers.set(event, handlerList.concat(handler));\n  };\n\n  TranslationController.prototype.off = function (event, handler) {\n    var handlerList = this.handlers.get(event) || [];\n    this.handlers.set(event, handlerList.filter(function (h) {\n      return h !== handler;\n    }));\n  };\n\n  return TranslationController;\n}();\n\nvar CURRENT_LANGUAGE_COOKIE_NAME = \"sCurrLanguage\";\n\nfunction saveCurrentLanguage(language, cookieDomain) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _b.trys.push([0, 2,, 3]);\n\n          return [4\n          /*yield*/\n          , setFrontendCookie(CURRENT_LANGUAGE_COOKIE_NAME, language, cookieDomain)];\n\n        case 1:\n          _b.sent();\n\n          return [3\n          /*break*/\n          , 3];\n\n        case 2:\n          _b.sent();\n\n          return [3\n          /*break*/\n          , 3];\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction getCurrentLanguageFromCookie() {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _b.trys.push([0, 2,, 3]);\n\n          return [4\n          /*yield*/\n          , getCookieValue(CURRENT_LANGUAGE_COOKIE_NAME)];\n\n        case 1:\n          return [2\n          /*return*/\n          , _b.sent()];\n\n        case 2:\n          _b.sent(); // This can throw if we are not in a browser\n          // Since this is just loading a preference we can safely ignore the exception\n\n\n          return [2\n          /*return*/\n          , null];\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n/*\n * Class.\n */\n\n\nvar SuperTokens =\n/** @class */\nfunction () {\n  /*\n   * Constructor.\n   */\n  function SuperTokens(config) {\n    var _this = this;\n\n    this.recipeList = [];\n    /*\n     * Instance Methods.\n     */\n\n    this.canHandleRoute = function () {\n      return _this.getMatchingComponentForRouteAndRecipeId(getCurrentNormalisedUrlPath()) !== undefined;\n    };\n\n    this.getRoutingComponent = function () {\n      return jsxRuntime.jsx(RoutingComponent, {\n        path: getCurrentNormalisedUrlPath().getAsStringDangerous(),\n        supertokensInstance: _this\n      });\n    };\n\n    this.getPathsToFeatureComponentWithRecipeIdMap = function () {\n      // Memoized version of the map.\n      if (_this.pathsToFeatureComponentWithRecipeIdMap !== undefined) {\n        return _this.pathsToFeatureComponentWithRecipeIdMap;\n      }\n\n      var pathsToFeatureComponentWithRecipeIdMap = {};\n\n      for (var i = 0; i < _this.recipeList.length; i++) {\n        var recipe = _this.recipeList[i];\n        var features = recipe.getFeatures();\n        var featurePaths = Object.keys(features);\n\n        for (var j = 0; j < featurePaths.length; j++) {\n          // If no components yet for this route, initialize empty array.\n          var featurePath = featurePaths[j];\n\n          if (pathsToFeatureComponentWithRecipeIdMap[featurePath] === undefined) {\n            pathsToFeatureComponentWithRecipeIdMap[featurePath] = [];\n          }\n\n          pathsToFeatureComponentWithRecipeIdMap[featurePath].push(features[featurePath]);\n        }\n      }\n\n      _this.pathsToFeatureComponentWithRecipeIdMap = pathsToFeatureComponentWithRecipeIdMap;\n      return _this.pathsToFeatureComponentWithRecipeIdMap;\n    };\n\n    this.getMatchingComponentForRouteAndRecipeId = function (normalisedUrl) {\n      var path = normalisedUrl.getAsStringDangerous();\n\n      var routeComponents = _this.getPathsToFeatureComponentWithRecipeIdMap()[path];\n\n      if (routeComponents === undefined) {\n        return undefined;\n      }\n\n      var component = routeComponents.find(function (c) {\n        return c.matches();\n      });\n\n      if (component !== undefined) {\n        return component;\n      } // Otherwise, If no recipe Id provided, or if no recipe id matches, return the first matching component.\n\n\n      return routeComponents[0];\n    };\n\n    this.getReactRouterDomWithCustomHistory = function () {\n      return SuperTokens.reactRouterDom;\n    };\n\n    this.changeLanguage = function (lang) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , saveCurrentLanguage(lang, this.languageTranslations.currentLanguageCookieScope)];\n\n            case 1:\n              _a.sent();\n\n              this.languageTranslations.translationEventSource.emit(\"LanguageChange\", lang);\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.redirectToAuth = function (options) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var queryParams, redirectUrl;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              queryParams = options.queryParams === undefined ? {} : options.queryParams;\n\n              if (options.show !== undefined) {\n                queryParams.show = options.show;\n              }\n\n              if (options.redirectBack === true) {\n                queryParams.redirectToPath = getCurrentNormalisedUrlPath().getAsStringDangerous();\n              }\n\n              return [4\n              /*yield*/\n              , this.getRedirectUrl({\n                action: \"TO_AUTH\",\n                showSignIn: options.show === \"signin\"\n              })];\n\n            case 1:\n              redirectUrl = _a.sent();\n              redirectUrl = appendQueryParamsToURL(redirectUrl, queryParams);\n              return [2\n              /*return*/\n              , this.redirectToUrl(redirectUrl, options.history)];\n          }\n        });\n      });\n    };\n\n    this.redirectToUrl = function (redirectUrl, history) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var origin_1;\n        return __generator(this, function (_a) {\n          try {\n            new URL(redirectUrl); // If full URL, no error thrown, skip in app redirection.\n          } catch (e) {\n            origin_1 = getOriginOfPage().getAsStringDangerous();\n\n            if (origin_1 !== this.appInfo.websiteDomain.getAsStringDangerous()) {\n              redirectUrl = \"\".concat(this.appInfo.websiteDomain.getAsStringDangerous()).concat(redirectUrl);\n              redirectWithFullPageReload(redirectUrl);\n              return [2\n              /*return*/\n              ];\n            } // If history was provided, use to redirect without reloading.\n\n\n            if (history !== undefined) {\n              redirectWithHistory(redirectUrl, history);\n              return [2\n              /*return*/\n              ];\n            }\n          } // Otherwise, redirect in app.\n\n\n          redirectWithFullPageReload(redirectUrl);\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    };\n\n    this.appInfo = normaliseInputAppInfoOrThrowError(config.appInfo);\n\n    if (config.recipeList === undefined || config.recipeList.length === 0) {\n      throw new Error(\"Please provide at least one recipe to the supertokens.init function call. See https://supertokens.io/docs/emailpassword/quick-setup/frontend\");\n    }\n\n    var translationConfig = config.languageTranslations === undefined ? {} : config.languageTranslations;\n    this.languageTranslations = {\n      defaultLanguage: translationConfig.defaultLanguage === undefined ? \"en\" : translationConfig.defaultLanguage,\n      currentLanguageCookieScope: translationConfig.currentLanguageCookieScope !== undefined ? normaliseCookieScopeOrThrowError(translationConfig.currentLanguageCookieScope) : getDefaultCookieScope(),\n      userTranslationStore: translationConfig.translations !== undefined ? translationConfig.translations : {},\n      translationEventSource: new TranslationController(),\n      userTranslationFunc: translationConfig.translationFunc\n    };\n    var enableDebugLogs = false;\n\n    if (config.enableDebugLogs !== undefined) {\n      enableDebugLogs = config.enableDebugLogs;\n    }\n\n    this.userGetRedirectionURL = config.getRedirectionURL;\n    this.recipeList = config.recipeList.map(function (recipe) {\n      return recipe(_this.appInfo, enableDebugLogs);\n    });\n  }\n  /*\n   * Static Methods.\n   */\n\n\n  SuperTokens.init = function (config) {\n    cookieHandler.CookieHandlerReference.init(config.cookieHandler);\n    windowHandler.WindowHandlerReference.init(config.windowHandler);\n\n    if (SuperTokens.instance !== undefined) {\n      console.warn(\"SuperTokens was already initialized\");\n      return;\n    }\n\n    SuperTokens.instance = new SuperTokens(config);\n    postSuperTokensInitCallbacks.PostSuperTokensInitCallbacks.runPostInitCallbacks();\n  };\n\n  SuperTokens.getInstanceOrThrow = function () {\n    if (SuperTokens.instance === undefined) {\n      var error = \"SuperTokens must be initialized before calling this method.\"; // eslint-disable-next-line supertokens-auth-react/no-direct-window-object\n\n      if (typeof window === \"undefined\") {\n        error = error + SSR_ERROR;\n      }\n\n      throw new Error(error);\n    }\n\n    return SuperTokens.instance;\n  };\n\n  SuperTokens.canHandleRoute = function () {\n    return SuperTokens.getInstanceOrThrow().canHandleRoute();\n  };\n\n  SuperTokens.getRoutingComponent = function () {\n    return SuperTokens.getInstanceOrThrow().getRoutingComponent();\n  };\n\n  SuperTokens.getSuperTokensRoutesForReactRouterDom = function (reactRouterDom) {\n    if (reactRouterDom === undefined) {\n      throw new Error( // eslint-disable-next-line @typescript-eslint/quotes\n      'Please use getSuperTokensRoutesForReactRouterDom like getSuperTokensRoutesForReactRouterDom(require(\"react-router-dom\")) in your render function');\n    }\n\n    SuperTokens.reactRouterDom = reactRouterDom;\n\n    if (SuperTokens.reactRouterDomIsV6 === undefined) {\n      SuperTokens.reactRouterDomIsV6 = reactRouterDom.withRouter === undefined;\n    }\n\n    if (SuperTokens.reactRouterDomIsV6) {\n      // this function wraps the react-router-dom v6 useNavigate function in a way\n      // that enforces that it runs within a useEffect. The reason we do this is\n      // cause of https://github.com/remix-run/react-router/issues/7460\n      // which gets shown when visiting a social auth callback url like\n      // /auth/callback/github, without a valid code or state. This then\n      // doesn't navigate the user to the auth page.\n      var useNavigateHookForRRDV6 = function () {\n        var navigateHook = reactRouterDom.useNavigate();\n\n        var _a = React__namespace.useState(undefined),\n            to = _a[0],\n            setTo = _a[1];\n\n        React__namespace.useEffect(function () {\n          if (to !== undefined) {\n            setTo(undefined);\n            navigateHook(to);\n          }\n        }, [to, navigateHook, setTo]);\n        return setTo;\n      };\n\n      SuperTokens.reactRouterDom = {\n        router: reactRouterDom,\n        useHistoryCustom: useNavigateHookForRRDV6\n      };\n      return getSuperTokensRoutesForReactRouterDomV6(SuperTokens.getInstanceOrThrow());\n    }\n\n    SuperTokens.reactRouterDom = {\n      router: reactRouterDom,\n      useHistoryCustom: reactRouterDom.useHistory\n    };\n    return getSuperTokensRoutesForReactRouterDom(SuperTokens.getInstanceOrThrow());\n  };\n\n  SuperTokens.getReactRouterDomWithCustomHistory = function () {\n    return this.instance !== undefined ? this.instance.getReactRouterDomWithCustomHistory() : undefined;\n  };\n\n  SuperTokens.prototype.getRecipeOrThrow = function (recipeId) {\n    var recipe = this.recipeList.find(function (recipe) {\n      return recipe.config.recipeId === recipeId;\n    });\n\n    if (recipe === undefined) {\n      throw new Error(\"Missing recipe: \".concat(recipeId));\n    }\n\n    return recipe;\n  };\n\n  SuperTokens.prototype.loadTranslation = function (store) {\n    this.languageTranslations.translationEventSource.emit(\"TranslationLoaded\", store);\n  };\n\n  SuperTokens.prototype.getRedirectUrl = function (context) {\n    return __awaiter(this, void 0, void 0, function () {\n      var userRes, redirectUrl;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.userGetRedirectionURL) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.userGetRedirectionURL(context)];\n\n          case 1:\n            userRes = _a.sent();\n\n            if (userRes !== undefined) {\n              return [2\n              /*return*/\n              , userRes];\n            }\n\n            _a.label = 2;\n\n          case 2:\n            if (context.action === \"TO_AUTH\") {\n              redirectUrl = this.appInfo.websiteBasePath.getAsStringDangerous();\n              return [2\n              /*return*/\n              , appendTrailingSlashToURL(redirectUrl)];\n            }\n\n            throw new Error(\"Should never come here: unexpected redirection context\");\n        }\n      });\n    });\n  };\n  /*\n   * Tests methods.\n   */\n\n\n  SuperTokens.reset = function () {\n    if (!isTest()) {\n      return;\n    }\n\n    SuperTokens.instance = undefined;\n    return;\n  };\n\n  SuperTokens.reactRouterDomIsV6 = undefined;\n  return SuperTokens;\n}();\n\nvar UserContextContext = React__namespace.default.createContext(undefined);\n\nvar useUserContext = function () {\n  return React__namespace.default.useContext(UserContextContext);\n};\n\nvar UserContextProvider = function (_a) {\n  var children = _a.children,\n      userContext = _a.userContext;\n  var currentUserContext = React.useState(getNormalisedUserContext(userContext))[0];\n  return jsxRuntime.jsx(UserContextContext.Provider, exports.__assign({\n    value: currentUserContext\n  }, {\n    children: children\n  }));\n};\n\nfunction UserContextWrapper(props) {\n  /**\n   * If we recieve a userContext as a props we should assume that the user\n   * is either trying to use a theme component as standalone or that they\n   * want to override an existing value for userContext.\n   *\n   * In this case we should always return a Provider with the value of userContext\n   */\n  if (props.userContext !== undefined) {\n    return jsxRuntime.jsx(UserContextProvider, exports.__assign({\n      userContext: props.userContext\n    }, {\n      children: props.children\n    }));\n  }\n\n  return jsxRuntime.jsx(UserContextContext.Consumer, {\n    children: function (value) {\n      /**\n       * value is undefined only if there is no Provider in the tree. In this case it is safe to\n       * assume that the theme component is not being rendered by the SDK and that the user is not\n       * using this as a child of one of the pre-built feature components.\n       *\n       * In this case we return a provider so that the userContext hook can be used by the children\n       * of this theme component\n       */\n      if (value === undefined) {\n        return jsxRuntime.jsx(UserContextProvider, {\n          children: props.children\n        });\n      }\n      /**\n       * If value is not undefined then a provider exists in the tree. This means that this component\n       * is either being rendered by the SDK or the user has added it as a child of the pre-built\n       * feature components. In either case the userContext hook will be available so simply\n       * return the theme component.\n       */\n\n\n      return props.children;\n    }\n  });\n}\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n/*\n * Class.\n */\n\n\nvar RecipeModule =\n/** @class */\nfunction () {\n  /*\n   * Constructor.\n   */\n  function RecipeModule(config) {\n    var _this = this;\n\n    this.redirect = function (context, history, queryParams) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var redirectUrl;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.getRedirectUrl(context)];\n\n            case 1:\n              redirectUrl = _a.sent();\n              redirectUrl = appendQueryParamsToURL(redirectUrl, queryParams);\n              return [2\n              /*return*/\n              , SuperTokens.getInstanceOrThrow().redirectToUrl(redirectUrl, history)];\n          }\n        });\n      });\n    }; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n\n    this.getRedirectUrl = function (context) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var redirectUrl;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.config.getRedirectionURL(context)];\n\n            case 1:\n              redirectUrl = _a.sent();\n\n              if (redirectUrl !== undefined) {\n                return [2\n                /*return*/\n                , redirectUrl];\n              }\n\n              return [4\n              /*yield*/\n              , this.getDefaultRedirectionURL(context)];\n\n            case 2:\n              // Otherwise, use default.\n              return [2\n              /*return*/\n              , _a.sent()];\n          }\n        });\n      });\n    };\n\n    this.config = config;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  RecipeModule.prototype.getDefaultRedirectionURL = function (_) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error(\"getDefaultRedirectionURL is not implemented.\");\n      });\n    });\n  };\n\n  return RecipeModule;\n}();\n\nfunction normaliseRecipeModuleConfig(config) {\n  var _this = this;\n\n  var onHandleEvent = config.onHandleEvent,\n      getRedirectionURL = config.getRedirectionURL,\n      preAPIHook = config.preAPIHook,\n      postAPIHook = config.postAPIHook;\n\n  if (onHandleEvent === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n    onHandleEvent = function (_) {};\n  }\n\n  if (getRedirectionURL === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    getRedirectionURL = function (_) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , undefined];\n        });\n      });\n    };\n  }\n\n  if (preAPIHook === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    preAPIHook = function (context) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , context];\n        });\n      });\n    };\n  }\n\n  if (postAPIHook === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    postAPIHook = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    };\n  }\n\n  var useShadowDom = config.useShadowDom === undefined ? true : config.useShadowDom;\n  useShadowDom = getShouldUseShadowDomBasedOnBrowser(useShadowDom);\n  var rootStyle = config.style === undefined ? \"\" : config.style;\n  return exports.__assign(exports.__assign({}, config), {\n    getRedirectionURL: getRedirectionURL,\n    onHandleEvent: onHandleEvent,\n    preAPIHook: preAPIHook,\n    postAPIHook: postAPIHook,\n    useShadowDom: useShadowDom,\n    rootStyle: rootStyle,\n    recipeId: config.recipeId,\n    appInfo: config.appInfo\n  });\n}\n\nfunction getShouldUseShadowDomBasedOnBrowser(useShadowDom) {\n  /*\n   * Detect if browser is IE\n   * In order to disable unsupported shadowDom\n   * https://github.com/supertokens/supertokens-auth-react/issues/99\n   */\n  // If browser is Internet Explorer, always disable shadow dom.\n  if (isIE() === true) {\n    return false;\n  } // Otherwise, use provided config or default to true.\n\n\n  return useShadowDom !== undefined ? useShadowDom : true;\n}\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n\nvar Session =\n/** @class */\nfunction (_super) {\n  __extends(Session, _super);\n\n  function Session(config) {\n    var _this = this;\n\n    var normalizedConfig = exports.__assign(exports.__assign({}, config), normaliseRecipeModuleConfig(config));\n\n    _this = _super.call(this, normalizedConfig) || this;\n    _this.eventListeners = new Set();\n    _this.redirectionHandlersFromAuthRecipes = new Map(); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    _this.getFeatureComponent = function (_) {\n      throw new Error(\"should never come here\");\n    };\n\n    _this.getFeatures = function () {\n      return {};\n    };\n\n    _this.getUserId = function (input) {\n      return _this.webJsRecipe.getUserId(input);\n    };\n\n    _this.getAccessToken = function (input) {\n      return _this.webJsRecipe.getAccessToken(input);\n    };\n\n    _this.getClaimValue = function (input) {\n      return _this.webJsRecipe.getClaimValue(input);\n    };\n\n    _this.getAccessTokenPayloadSecurely = function (input) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , this.webJsRecipe.getAccessTokenPayloadSecurely(input)];\n        });\n      });\n    };\n\n    _this.doesSessionExist = function (input) {\n      return _this.webJsRecipe.doesSessionExist(input);\n    };\n\n    _this.signOut = function (input) {\n      return _this.webJsRecipe.signOut(input);\n    };\n\n    _this.attemptRefreshingSession = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , this.webJsRecipe.attemptRefreshingSession()];\n        });\n      });\n    };\n\n    _this.validateClaims = function (input) {\n      return _this.webJsRecipe.validateClaims(input);\n    };\n\n    _this.getInvalidClaimsFromResponse = function (input) {\n      return _this.webJsRecipe.getInvalidClaimsFromResponse(input);\n    };\n    /**\n     * @returns Function to remove event listener\n     */\n\n\n    _this.addEventListener = function (listener) {\n      _this.eventListeners.add(listener);\n\n      return function () {\n        return _this.eventListeners.delete(listener);\n      };\n    };\n\n    _this.addAuthRecipeRedirectionHandler = function (rid, redirect) {\n      _this.redirectionHandlersFromAuthRecipes.set(rid, redirect);\n    };\n\n    _this.validateGlobalClaimsAndHandleSuccessRedirection = function (redirectInfo, userContext, history) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var invalidClaims, invalidClaimRedirectPath, jsonContext, successContextStr, authRecipeRedirectHandler;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.doesSessionExist({\n                userContext: userContext\n              })];\n\n            case 1:\n              // First we check if there is an active session\n              if (!_a.sent()) {\n                // If there is none, we have no way of checking claims, so we redirect to the auth page\n                // This can happen e.g.: if the user clicked on the email verification link in a browser without an active session\n                return [2\n                /*return*/\n                , SuperTokens.getInstanceOrThrow().redirectToAuth({\n                  history: history,\n                  redirectBack: false\n                })];\n              }\n\n              return [4\n              /*yield*/\n              , this.validateClaims({\n                userContext: userContext\n              })];\n\n            case 2:\n              invalidClaims = _a.sent();\n              invalidClaimRedirectPath = popInvalidClaimRedirectPathFromContext(userContext);\n              if (!(invalidClaims.length > 0 && invalidClaimRedirectPath !== undefined)) return [3\n              /*break*/\n              , 5];\n              if (!(redirectInfo !== undefined)) return [3\n              /*break*/\n              , 4];\n              jsonContext = JSON.stringify(redirectInfo);\n              return [4\n              /*yield*/\n              , setLocalStorage(\"supertokens-success-redirection-context\", jsonContext)];\n\n            case 3:\n              _a.sent();\n\n              _a.label = 4;\n\n            case 4:\n              // then we do the redirection.\n              return [2\n              /*return*/\n              , SuperTokens.getInstanceOrThrow().redirectToUrl(invalidClaimRedirectPath, history)];\n\n            case 5:\n              if (!(redirectInfo === undefined)) return [3\n              /*break*/\n              , 12];\n              return [4\n              /*yield*/\n              , getLocalStorage(\"supertokens-success-redirection-context\")];\n\n            case 6:\n              successContextStr = _a.sent();\n              if (!(successContextStr !== null)) return [3\n              /*break*/\n              , 11];\n              _a.label = 7;\n\n            case 7:\n              _a.trys.push([7,, 8, 10]);\n\n              redirectInfo = JSON.parse(successContextStr);\n              return [3\n              /*break*/\n              , 10];\n\n            case 8:\n              return [4\n              /*yield*/\n              , removeFromLocalStorage(\"supertokens-success-redirection-context\")];\n\n            case 9:\n              _a.sent();\n\n              return [7\n              /*endfinally*/\n              ];\n\n            case 10:\n              return [3\n              /*break*/\n              , 12];\n\n            case 11:\n              // If there was nothing in localstorage we set a default\n              // this can happen if the user visited email verification screen without an auth recipe redirecting them there\n              // but already had the email verified and an active session\n              redirectInfo = {\n                rid: Session.RECIPE_ID,\n                successRedirectContext: {\n                  action: \"SUCCESS\",\n                  isNewUser: false\n                }\n              };\n              _a.label = 12;\n\n            case 12:\n              authRecipeRedirectHandler = this.redirectionHandlersFromAuthRecipes.get(redirectInfo.rid);\n\n              if (authRecipeRedirectHandler !== undefined) {\n                // and call it with the saved info\n                return [2\n                /*return*/\n                , authRecipeRedirectHandler(redirectInfo.successRedirectContext, history)];\n              } // This should only happen if the configuration changed between saving the context and finishing the sign in process\n              // or if the user navigated to a page where they were expected to have a stored redirectInfo but didn't\n              // (e.g.: pressed back after email verification)\n\n\n              return [2\n              /*return*/\n              , this.redirect(redirectInfo.successRedirectContext, history)];\n          }\n        });\n      });\n    };\n    /**\n     * This should only get called if validateGlobalClaimsAndHandleSuccessRedirection couldn't get a redirectInfo\n     * @returns \"/\"\n     */\n\n\n    _this.getDefaultRedirectionURL = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , \"/\"];\n        });\n      });\n    };\n\n    _this.notifyListeners = function (event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var sessionContext;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.getSessionContext(event)];\n\n            case 1:\n              sessionContext = _a.sent(); // We copy this.eventListeners into a new array to \"freeze\" it for the loop\n              // We do this to avoid an infinite loop in case one of the listeners causes a new listener to be added (e.g.: through re-rendering)\n\n              Array.from(this.eventListeners).forEach(function (listener) {\n                return listener(exports.__assign({\n                  sessionContext: sessionContext\n                }, event));\n              });\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    _this.webJsRecipe = new recipe.Recipe(exports.__assign(exports.__assign({}, normalizedConfig), {\n      onHandleEvent: function (event) {\n        if (config.onHandleEvent !== undefined) {\n          config.onHandleEvent(event);\n        }\n\n        void _this.notifyListeners(event);\n      },\n      preAPIHook: function (context) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var headers, response;\n          return __generator(this, function (_a) {\n            headers = new Headers(context.requestInit.headers);\n            headers.set(\"rid\", config.recipeId);\n            response = exports.__assign(exports.__assign({}, context), {\n              requestInit: exports.__assign(exports.__assign({}, context.requestInit), {\n                headers: headers\n              })\n            });\n\n            if (config.preAPIHook === undefined) {\n              return [2\n              /*return*/\n              , response];\n            } else {\n              return [2\n              /*return*/\n              , config.preAPIHook(context)];\n            }\n          });\n        });\n      }\n    }));\n    return _this;\n  }\n\n  Session.prototype.getSessionContext = function (_a) {\n    var action = _a.action,\n        userContext = _a.userContext;\n    return __awaiter(this, void 0, void 0, function () {\n      var _b, userId, accessTokenPayload;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(action === \"SESSION_CREATED\" || action === \"REFRESH_SESSION\" || action === \"API_INVALID_CLAIM\" || action === \"ACCESS_TOKEN_PAYLOAD_UPDATED\")) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.all([this.getUserId({\n              userContext: userContext\n            }), this.getAccessTokenPayloadSecurely({\n              userContext: userContext\n            })])];\n\n          case 1:\n            _b = _c.sent(), userId = _b[0], accessTokenPayload = _b[1];\n            return [2\n            /*return*/\n            , {\n              doesSessionExist: true,\n              accessTokenPayload: accessTokenPayload,\n              userId: userId\n            }];\n\n          case 2:\n            if (action === \"SIGN_OUT\" || action === \"UNAUTHORISED\") {\n              return [2\n              /*return*/\n              , {\n                doesSessionExist: false,\n                accessTokenPayload: {},\n                userId: \"\"\n              }];\n            }\n\n            throw new Error(\"Unhandled recipe event: \".concat(action));\n        }\n      });\n    });\n  }; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n\n  Session.addAxiosInterceptors = function (axiosInstance, userContext) {\n    return recipe.Recipe.addAxiosInterceptors(axiosInstance, userContext);\n  };\n\n  Session.init = function (config) {\n    return function (appInfo, enableDebugLogs) {\n      Session.instance = new Session(exports.__assign(exports.__assign({}, config), {\n        appInfo: appInfo,\n        recipeId: Session.RECIPE_ID,\n        enableDebugLogs: enableDebugLogs\n      }));\n      return Session.instance;\n    };\n  };\n\n  Session.getInstanceOrThrow = function () {\n    if (Session.instance === undefined) {\n      throw Error(\"No instance of Session found. Make sure to call the Session.init method. See https://supertokens.io/docs/emailpassword/quick-setup/frontend\");\n    }\n\n    return Session.instance;\n  };\n\n  Session.getInstance = function () {\n    return Session.instance;\n  };\n\n  Session.reset = function () {\n    if (!isTest()) {\n      return;\n    }\n\n    Session.instance = undefined;\n    return;\n  };\n\n  Session.RECIPE_ID = \"session\";\n  return Session;\n}(RecipeModule);\n\nvar SessionContext = React__namespace.default.createContext({\n  loading: true,\n  isDefault: true\n});\n\nvar SessionAuth = function (_a) {\n  var _b;\n\n  var children = _a.children,\n      props = __rest(_a, [\"children\"]);\n\n  var requireAuth = React.useRef(props.requireAuth);\n\n  if (props.requireAuth !== requireAuth.current) {\n    throw new Error( // eslint-disable-next-line @typescript-eslint/quotes\n    'requireAuth prop should not change. If you are seeing this, it probably means that you are using SessionAuth in multiple routes with different values for requireAuth. To solve this, try adding the \"key\" prop to all uses of SessionAuth like <SessionAuth key=\"someUniqueKeyPerRoute\" requireAuth={...}>');\n  } // Reusing the parent context was removed because it caused a redirect loop in an edge case\n  // because it'd also reuse the invalid claims part until it loaded.\n\n\n  var _c = React.useState({\n    loading: true\n  }),\n      context = _c[0],\n      setContext = _c[1];\n\n  var session = React.useRef(); // We store this here, to prevent the list of called hooks changing even if a history hook is added later to SuperTokens.\n\n  var historyHookRef = React.useRef((_b = SuperTokens.getReactRouterDomWithCustomHistory()) === null || _b === void 0 ? void 0 : _b.useHistoryCustom);\n  var history;\n\n  try {\n    if (historyHookRef.current) {\n      history = historyHookRef.current();\n    }\n  } catch (_d) {// We catch and ignore errors here, because if this is may throw if\n    // the app is using react-router-dom but added a session auth outside of the router.\n  }\n\n  var userContext = useUserContext();\n  var redirectToLogin = React.useCallback(function () {\n    void SuperTokens.getInstanceOrThrow().redirectToAuth({\n      history: history,\n      redirectBack: true\n    });\n  }, []);\n  var buildContext = React.useCallback(function () {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var sessionExists, invalidClaims, err_1, invalidClaimRedirectToPath, err_2;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (session.current === undefined) {\n              session.current = Session.getInstanceOrThrow();\n            }\n\n            return [4\n            /*yield*/\n            , session.current.doesSessionExist({\n              userContext: userContext\n            })];\n\n          case 1:\n            sessionExists = _b.sent();\n\n            if (sessionExists === false) {\n              return [2\n              /*return*/\n              , {\n                loading: false,\n                doesSessionExist: false,\n                accessTokenPayload: {},\n                invalidClaims: [],\n                userId: \"\"\n              }];\n            }\n\n            _b.label = 2;\n\n          case 2:\n            _b.trys.push([2, 4,, 6]);\n\n            return [4\n            /*yield*/\n            , session.current.validateClaims({\n              overrideGlobalClaimValidators: props.overrideGlobalClaimValidators,\n              userContext: userContext\n            })];\n\n          case 3:\n            invalidClaims = _b.sent();\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            err_1 = _b.sent();\n            return [4\n            /*yield*/\n            , session.current.doesSessionExist({\n              userContext: userContext\n            })];\n\n          case 5:\n            // These errors should only come from getAccessTokenPayloadSecurely inside validateClaims if refreshing a claim cleared the session\n            // Which means that the session was most likely cleared, meaning returning false is right.\n            // This might also happen if the user provides an override or a custom claim validator that throws (or if we have a bug)\n            // In which case the session will not be cleared so we rethrow the error\n            if (_b.sent()) {\n              throw err_1;\n            }\n\n            return [2\n            /*return*/\n            , {\n              loading: false,\n              doesSessionExist: false,\n              accessTokenPayload: {},\n              invalidClaims: [],\n              userId: \"\"\n            }];\n\n          case 6:\n            invalidClaimRedirectToPath = popInvalidClaimRedirectPathFromContext(userContext);\n            _b.label = 7;\n\n          case 7:\n            _b.trys.push([7, 10,, 12]);\n\n            _a = {\n              loading: false,\n              doesSessionExist: true,\n              invalidClaims: invalidClaims,\n              invalidClaimRedirectToPath: invalidClaimRedirectToPath\n            };\n            return [4\n            /*yield*/\n            , session.current.getAccessTokenPayloadSecurely({\n              userContext: userContext\n            })];\n\n          case 8:\n            _a.accessTokenPayload = _b.sent();\n            return [4\n            /*yield*/\n            , session.current.getUserId({\n              userContext: userContext\n            })];\n\n          case 9:\n            return [2\n            /*return*/\n            , (_a.userId = _b.sent(), _a)];\n\n          case 10:\n            err_2 = _b.sent();\n            return [4\n            /*yield*/\n            , session.current.doesSessionExist({\n              userContext: userContext\n            })];\n\n          case 11:\n            if (_b.sent()) {\n              throw err_2;\n            } // This means that loading the access token or the userId failed\n            // This may happen if the server cleared the error since the validation was done which should be extremely rare\n\n\n            return [2\n            /*return*/\n            , {\n              loading: false,\n              doesSessionExist: false,\n              accessTokenPayload: {},\n              invalidClaims: [],\n              userId: \"\"\n            }];\n\n          case 12:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, []);\n  var setInitialContextAndMaybeRedirect = React.useCallback(function (toSetContext) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (context.loading === false) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (!(props.doRedirection !== false)) return [3\n            /*break*/\n            , 3];\n            if (!(!toSetContext.doesSessionExist && props.requireAuth !== false)) return [3\n            /*break*/\n            , 1];\n            redirectToLogin();\n            return [2\n            /*return*/\n            ];\n\n          case 1:\n            if (!(toSetContext.invalidClaimRedirectToPath !== undefined)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , SuperTokens.getInstanceOrThrow().redirectToUrl(toSetContext.invalidClaimRedirectToPath, history)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n\n          case 3:\n            delete toSetContext.invalidClaimRedirectToPath;\n            setContext(toSetContext);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [props.doRedirection, props.requireAuth, redirectToLogin, context]);\n  useOnMountAPICall(buildContext, setInitialContextAndMaybeRedirect); // subscribe to events on mount\n\n  React.useEffect(function () {\n    function onHandleEvent(event) {\n      return __awaiter(this, void 0, void 0, function () {\n        var _a, invalidClaims, redirectPath;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _a = event.action;\n\n              switch (_a) {\n                case \"SESSION_CREATED\":\n                  return [3\n                  /*break*/\n                  , 1];\n\n                case \"REFRESH_SESSION\":\n                  return [3\n                  /*break*/\n                  , 1];\n\n                case \"ACCESS_TOKEN_PAYLOAD_UPDATED\":\n                  return [3\n                  /*break*/\n                  , 1];\n\n                case \"API_INVALID_CLAIM\":\n                  return [3\n                  /*break*/\n                  , 1];\n\n                case \"SIGN_OUT\":\n                  return [3\n                  /*break*/\n                  , 5];\n\n                case \"UNAUTHORISED\":\n                  return [3\n                  /*break*/\n                  , 6];\n              }\n\n              return [3\n              /*break*/\n              , 7];\n\n            case 1:\n              return [4\n              /*yield*/\n              , session.current.validateClaims({\n                overrideGlobalClaimValidators: props.overrideGlobalClaimValidators,\n                userContext: userContext\n              })];\n\n            case 2:\n              invalidClaims = _b.sent();\n              setContext(exports.__assign(exports.__assign({}, event.sessionContext), {\n                loading: false,\n                invalidClaims: invalidClaims\n              }));\n              redirectPath = popInvalidClaimRedirectPathFromContext(userContext);\n              if (!(props.doRedirection !== false && redirectPath)) return [3\n              /*break*/\n              , 4];\n              return [4\n              /*yield*/\n              , SuperTokens.getInstanceOrThrow().redirectToUrl(redirectPath, history)];\n\n            case 3:\n              _b.sent();\n\n              _b.label = 4;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n\n            case 5:\n              setContext(exports.__assign(exports.__assign({}, event.sessionContext), {\n                loading: false,\n                invalidClaims: []\n              }));\n              return [2\n              /*return*/\n              ];\n\n            case 6:\n              setContext(exports.__assign(exports.__assign({}, event.sessionContext), {\n                loading: false,\n                invalidClaims: []\n              }));\n\n              if (props.onSessionExpired !== undefined) {\n                props.onSessionExpired();\n              } else if (props.requireAuth !== false && props.doRedirection !== false) {\n                redirectToLogin();\n              }\n\n              return [2\n              /*return*/\n              ];\n\n            case 7:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n\n    if (session.current === undefined) {\n      session.current = Session.getInstanceOrThrow();\n    }\n\n    if (context.loading === false) {\n      // we return here cause addEventListener returns a function that removes\n      // the listener, and this function will be called by useEffect when\n      // onHandleEvent changes or if the component is unmounting.\n      return session.current.addEventListener(onHandleEvent);\n    }\n\n    return undefined;\n  }, [props, setContext, context.loading]);\n\n  if (props.requireAuth !== false && (context.loading || !context.doesSessionExist)) {\n    return null;\n  }\n\n  return jsxRuntime.jsx(SessionContext.Provider, exports.__assign({\n    value: context\n  }, {\n    children: children\n  }));\n};\n\nvar SessionAuthWrapper = function (props) {\n  return jsxRuntime.jsx(UserContextWrapper, exports.__assign({\n    userContext: props.userContext\n  }, {\n    children: jsxRuntime.jsx(SessionAuth, exports.__assign({}, props))\n  }));\n};\n\nexports.RecipeModule = RecipeModule;\nexports.SSR_ERROR = SSR_ERROR;\nexports.ST_ROOT_ID = ST_ROOT_ID;\nexports.Session = Session;\nexports.SessionAuthWrapper = SessionAuthWrapper;\nexports.SessionContext = SessionContext;\nexports.SuperTokens = SuperTokens;\nexports.UserContextContext = UserContextContext;\nexports.UserContextWrapper = UserContextWrapper;\nexports.__awaiter = __awaiter;\nexports.__extends = __extends;\nexports.__generator = __generator;\nexports.__rest = __rest;\nexports.__spreadArray = __spreadArray;\nexports.clearErrorQueryParam = clearErrorQueryParam;\nexports.clearQueryParams = clearQueryParams;\nexports.getCurrentLanguageFromCookie = getCurrentLanguageFromCookie;\nexports.getNormalisedUserContext = getNormalisedUserContext;\nexports.getQueryParams = getQueryParams;\nexports.getRedirectToPathFromURL = getRedirectToPathFromURL;\nexports.getURLHash = getURLHash;\nexports.isTest = isTest;\nexports.matchRecipeIdUsingQueryParams = matchRecipeIdUsingQueryParams;\nexports.mergeObjects = mergeObjects;\nexports.normaliseRecipeModuleConfig = normaliseRecipeModuleConfig;\nexports.redirectWithFullPageReload = redirectWithFullPageReload;\nexports.saveInvalidClaimRedirectPathInContext = saveInvalidClaimRedirectPathInContext;\nexports.useOnMountAPICall = useOnMountAPICall;\nexports.useUserContext = useUserContext;\nexports.validateForm = validateForm;","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["\"use strict\";\n\nvar jsxRuntime = require(\"react/jsx-runtime\");\nvar React = require(\"react\");\nvar cookieHandler = require(\"supertokens-web-js/utils/cookieHandler\");\nvar postSuperTokensInitCallbacks = require(\"supertokens-web-js/utils/postSuperTokensInitCallbacks\");\nvar windowHandler = require(\"supertokens-web-js/utils/windowHandler\");\nvar NormalisedURLPath = require(\"supertokens-web-js/utils/normalisedURLPath\");\nvar NormalisedURLDomain = require(\"supertokens-web-js/utils/normalisedURLDomain\");\nvar recipe = require(\"supertokens-web-js/recipe/session/recipe\");\n\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : { default: e };\n}\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(\n                    n,\n                    k,\n                    d.get\n                        ? d\n                        : {\n                              enumerable: true,\n                              get: function () {\n                                  return e[k];\n                              },\n                          }\n                );\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/ _interopNamespace(React);\nvar NormalisedURLPath__default = /*#__PURE__*/ _interopDefault(NormalisedURLPath);\nvar NormalisedURLDomain__default = /*#__PURE__*/ _interopDefault(NormalisedURLDomain);\n\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n    extendStatics =\n        Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array &&\n            function (d, b) {\n                d.__proto__ = b;\n            }) ||\n        function (d, b) {\n            for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n    return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n}\n\nexports.__assign = function () {\n    exports.__assign =\n        Object.assign ||\n        function __assign(t) {\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n            return t;\n        };\n    return exports.__assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n        }\n    return t;\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P\n            ? value\n            : new P(function (resolve) {\n                  resolve(value);\n              });\n    }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\n\nfunction __generator(thisArg, body) {\n    var _ = {\n            label: 0,\n            sent: function () {\n                if (t[0] & 1) throw t[1];\n                return t[1];\n            },\n            trys: [],\n            ops: [],\n        },\n        f,\n        y,\n        t,\n        g;\n    return (\n        (g = { next: verb(0), throw: verb(1), return: verb(2) }),\n        typeof Symbol === \"function\" &&\n            (g[Symbol.iterator] = function () {\n                return this;\n            }),\n        g\n    );\n    function verb(n) {\n        return function (v) {\n            return step([n, v]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while ((g && ((g = 0), op[0] && (_ = 0)), _))\n            try {\n                if (\n                    ((f = 1),\n                    y &&\n                        (t =\n                            op[0] & 2\n                                ? y[\"return\"]\n                                : op[0]\n                                ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0)\n                                : y.next) &&\n                        !(t = t.call(y, op[1])).done)\n                )\n                    return t;\n                if (((y = 0), t)) op = [op[0] & 2, t.value];\n                switch (op[0]) {\n                    case 0:\n                    case 1:\n                        t = op;\n                        break;\n                    case 4:\n                        _.label++;\n                        return { value: op[1], done: false };\n                    case 5:\n                        _.label++;\n                        y = op[1];\n                        op = [0];\n                        continue;\n                    case 7:\n                        op = _.ops.pop();\n                        _.trys.pop();\n                        continue;\n                    default:\n                        if (!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {\n                            _ = 0;\n                            continue;\n                        }\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                            _.label = op[1];\n                            break;\n                        }\n                        if (op[0] === 6 && _.label < t[1]) {\n                            _.label = t[1];\n                            t = op;\n                            break;\n                        }\n                        if (t && _.label < t[2]) {\n                            _.label = t[2];\n                            _.ops.push(op);\n                            break;\n                        }\n                        if (t[2]) _.ops.pop();\n                        _.trys.pop();\n                        continue;\n                }\n                op = body.call(thisArg, _);\n            } catch (e) {\n                op = [6, e];\n                y = 0;\n            } finally {\n                f = t = 0;\n            }\n        if (op[0] & 5) throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n    }\n}\n\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n            }\n        }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction RoutingComponent(props) {\n    var _a;\n    var stInstance = props.supertokensInstance;\n    var path = props.path;\n    var componentToRender = React__namespace.default.useMemo(\n        function () {\n            // During development, this runs twice so as to warn devs of if there\n            // are any side effects that happen here. So in tests, it will result in\n            // the console log twice\n            return stInstance.getMatchingComponentForRouteAndRecipeId(new NormalisedURLPath__default.default(path));\n        },\n        [stInstance, path]\n    );\n    var history =\n        (_a = props.supertokensInstance.getReactRouterDomWithCustomHistory()) === null || _a === void 0\n            ? void 0\n            : _a.useHistoryCustom();\n    if (componentToRender === undefined) {\n        return null;\n    }\n    return jsxRuntime.jsx(componentToRender.component, { history: history });\n}\n\n/*\n * Component.\n */\nfunction getSuperTokensRoutesForReactRouterDom(supertokensInstance) {\n    var routerInfo = supertokensInstance.getReactRouterDomWithCustomHistory();\n    if (routerInfo === undefined) {\n        return [];\n    }\n    var Route = routerInfo.router.Route;\n    var pathsToFeatureComponentWithRecipeIdMap = supertokensInstance.getPathsToFeatureComponentWithRecipeIdMap();\n    return Object.keys(pathsToFeatureComponentWithRecipeIdMap).map(function (path) {\n        path = path === \"\" ? \"/\" : path;\n        return jsxRuntime.jsx(\n            Route,\n            exports.__assign(\n                { exact: true, path: path },\n                { children: jsxRuntime.jsx(RoutingComponent, { supertokensInstance: supertokensInstance, path: path }) }\n            ),\n            \"st-\".concat(path)\n        );\n    });\n}\n\n/*\n * Component.\n */\nfunction getSuperTokensRoutesForReactRouterDomV6(supertokensInstance) {\n    var routerInfo = supertokensInstance.getReactRouterDomWithCustomHistory();\n    if (routerInfo === undefined) {\n        return [];\n    }\n    var Route = routerInfo.router.Route;\n    var pathsToFeatureComponentWithRecipeIdMap = supertokensInstance.getPathsToFeatureComponentWithRecipeIdMap();\n    return Object.keys(pathsToFeatureComponentWithRecipeIdMap).map(function (path) {\n        path = path === \"\" ? \"/\" : path;\n        return jsxRuntime.jsx(\n            Route,\n            {\n                path: path,\n                element: jsxRuntime.jsx(RoutingComponent, { supertokensInstance: supertokensInstance, path: path }),\n            },\n            \"st-\".concat(path)\n        );\n    });\n}\n\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n/*\n * Consts.\n */\nvar RECIPE_ID_QUERY_PARAM = \"rid\";\nvar DEFAULT_API_BASE_PATH = \"/auth\";\nvar DEFAULT_WEBSITE_BASE_PATH = \"/auth\";\nvar ST_ROOT_ID = \"supertokens-root\";\nvar SSR_ERROR =\n    \"\\nIf you are trying to use this method doing server-side-rendering, please make sure you move this method inside a componentDidMount method or useEffect hook.\";\n\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n/*\n * getRecipeIdFromPath\n * Input:\n * Output: The \"rid\" query param if present, null otherwise.\n */\nfunction getRecipeIdFromSearch(search) {\n    var urlParams = new URLSearchParams(search);\n    return urlParams.get(RECIPE_ID_QUERY_PARAM);\n}\nfunction clearQueryParams(paramNames) {\n    var newURL = new URL(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHref());\n    for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {\n        var param = paramNames_1[_i];\n        newURL.searchParams.delete(param);\n    }\n    windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.history.replaceState(\n        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.history.getState(),\n        \"\",\n        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHref()\n    );\n}\nfunction clearErrorQueryParam() {\n    clearQueryParams([\"error\", \"message\"]);\n}\nfunction getQueryParams(param) {\n    var urlParams = new URLSearchParams(\n        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getSearch()\n    );\n    return urlParams.get(param);\n}\nfunction getURLHash() {\n    // By default it is returined with the \"#\" at the beginning, we cut that off here.\n    return windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHash().substr(1);\n}\nfunction getRedirectToPathFromURL() {\n    var param = getQueryParams(\"redirectToPath\");\n    if (param === null) {\n        return undefined;\n    } else {\n        // Prevent Open redirects by normalising path.\n        try {\n            var normalisedURLPath = new NormalisedURLPath__default.default(param).getAsStringDangerous();\n            var pathQueryParams = param.split(\"?\")[1] !== undefined ? \"?\".concat(param.split(\"?\")[1]) : \"\";\n            return normalisedURLPath + pathQueryParams;\n        } catch (_a) {\n            return undefined;\n        }\n    }\n}\n/*\n * isTest\n */\nfunction isTest() {\n    try {\n        return process.env.TEST_MODE === \"testing\";\n    } catch (err) {\n        // can get Uncaught ReferenceError: process is not defined error\n        return false;\n    }\n}\nfunction normaliseInputAppInfoOrThrowError(appInfo) {\n    if (appInfo === undefined) {\n        throw new Error(\"Please provide the appInfo object when calling supertokens.init\");\n    }\n    if (appInfo.apiDomain === undefined) {\n        throw new Error(\"Please provide your apiDomain inside the appInfo object when calling supertokens.init\");\n    }\n    if (appInfo.appName === undefined) {\n        throw new Error(\"Please provide your appName inside the appInfo object when calling supertokens.init\");\n    }\n    if (appInfo.websiteDomain === undefined) {\n        throw new Error(\"Please provide your websiteDomain inside the appInfo object when calling supertokens.init\");\n    }\n    var apiGatewayPath = new NormalisedURLPath__default.default(\"\");\n    if (appInfo.apiGatewayPath !== undefined) {\n        apiGatewayPath = new NormalisedURLPath__default.default(appInfo.apiGatewayPath);\n    }\n    return {\n        appName: appInfo.appName,\n        apiDomain: new NormalisedURLDomain__default.default(appInfo.apiDomain),\n        websiteDomain: new NormalisedURLDomain__default.default(appInfo.websiteDomain),\n        apiBasePath: apiGatewayPath.appendPath(\n            getNormalisedURLPathOrDefault(DEFAULT_API_BASE_PATH, appInfo.apiBasePath)\n        ),\n        websiteBasePath: getNormalisedURLPathOrDefault(DEFAULT_WEBSITE_BASE_PATH, appInfo.websiteBasePath),\n    };\n}\nfunction getNormalisedURLPathOrDefault(defaultPath, path) {\n    if (path !== undefined) {\n        return new NormalisedURLPath__default.default(path);\n    } else {\n        return new NormalisedURLPath__default.default(defaultPath);\n    }\n}\n/*\n * validateForm\n */\n// We check that the number of fields in input and config form field is the same.\n// We check that each item in the config form field is also present in the input form field\nfunction validateForm(inputs, configFormFields) {\n    return __awaiter(this, void 0, void 0, function () {\n        var validationErrors, _loop_1, i;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    validationErrors = [];\n                    if (configFormFields.length !== inputs.length) {\n                        throw Error(\"Are you sending too many / too few formFields?\");\n                    }\n                    _loop_1 = function (i) {\n                        var field, input, value, error;\n                        return __generator(this, function (_b) {\n                            switch (_b.label) {\n                                case 0:\n                                    field = configFormFields[i];\n                                    input = inputs.find(function (i) {\n                                        return i.id === field.id;\n                                    });\n                                    value = input.value;\n                                    if (input.id === \"email\") {\n                                        value = value.trim();\n                                    }\n                                    return [4 /*yield*/, field.validate(value)];\n                                case 1:\n                                    error = _b.sent();\n                                    // If error, add it.\n                                    if (error !== undefined) {\n                                        validationErrors.push({\n                                            error: error,\n                                            id: field.id,\n                                        });\n                                    }\n                                    return [2 /*return*/];\n                            }\n                        });\n                    };\n                    i = 0;\n                    _a.label = 1;\n                case 1:\n                    if (!(i < configFormFields.length)) return [3 /*break*/, 4];\n                    return [5 /*yield**/, _loop_1(i)];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 4:\n                    return [2 /*return*/, validationErrors];\n            }\n        });\n    });\n}\n/*\n * getCurrentNormalisedUrlPath\n */\nfunction getCurrentNormalisedUrlPath() {\n    return new NormalisedURLPath__default.default(\n        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getPathName()\n    );\n}\nfunction appendQueryParamsToURL(stringUrl, queryParams) {\n    if (queryParams === undefined) {\n        return stringUrl;\n    }\n    try {\n        var url_1 = new URL(stringUrl);\n        Object.entries(queryParams).forEach(function (_a) {\n            var key = _a[0],\n                value = _a[1];\n            url_1.searchParams.set(key, value);\n        });\n        return url_1.href;\n    } catch (e) {\n        var fakeDomain = stringUrl.startsWith(\"/\") ? \"http:localhost\" : \"http://localhost/\";\n        var url_2 = new URL(\"\".concat(fakeDomain).concat(stringUrl));\n        Object.entries(queryParams).forEach(function (_a) {\n            var key = _a[0],\n                value = _a[1];\n            url_2.searchParams.set(key, value);\n        });\n        return \"\".concat(url_2.pathname).concat(url_2.search);\n    }\n}\nfunction appendTrailingSlashToURL(stringUrl) {\n    return stringUrl.endsWith(\"/\") ? stringUrl : stringUrl + \"/\";\n}\n/*\n * Default method for matching recipe route based on query params.\n */\nfunction matchRecipeIdUsingQueryParams(recipeId) {\n    return function () {\n        var recipeIdFromSearch = getRecipeIdFromSearch(\n            windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getSearch()\n        );\n        return recipeIdFromSearch === recipeId;\n    };\n}\nfunction redirectWithFullPageReload(to) {\n    if (to.trim() === \"\") {\n        to = \"/\";\n    }\n    windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.setHref(to);\n}\nfunction redirectWithHistory(to, history) {\n    if (to.trim() === \"\") {\n        to = \"/\";\n    }\n    if (history.push !== undefined) {\n        // we are using react-router-dom that is before v6\n        history.push(to);\n    } else {\n        // in react-router-dom v6, it is just navigate(to), and we are renaming\n        // naviagte to history, so it becomes history(to).\n        history(to);\n    }\n}\nfunction isIE() {\n    return (\n        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.getDocument().documentMode !==\n        undefined\n    );\n}\nfunction getOriginOfPage() {\n    return new NormalisedURLDomain__default.default(\n        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getOrigin()\n    );\n}\nfunction getLocalStorage(key) {\n    return __awaiter(this, void 0, void 0, function () {\n        var res;\n        return __generator(this, function (_a) {\n            res = windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.getItem(key);\n            if (res === null || res === undefined) {\n                return [2 /*return*/, null];\n            }\n            return [2 /*return*/, res];\n        });\n    });\n}\nfunction setLocalStorage(key, value) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    return [\n                        4 /*yield*/,\n                        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.setItem(\n                            key,\n                            value\n                        ),\n                    ];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction removeFromLocalStorage(key) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    return [\n                        4 /*yield*/,\n                        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.removeItem(\n                            key\n                        ),\n                    ];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction mergeObjects(obj1, obj2) {\n    var res = exports.__assign({}, obj1);\n    for (var key in obj2) {\n        if (typeof res[key] === \"object\" && typeof obj2[key] === \"object\") {\n            res[key] = mergeObjects(res[key], obj2[key]);\n        } else {\n            res[key] = obj2[key];\n        }\n    }\n    return res;\n}\nfunction normaliseCookieScopeOrThrowError(cookieScope) {\n    function helper(cookieScope) {\n        cookieScope = cookieScope.trim().toLowerCase();\n        // first we convert it to a URL so that we can use the URL class\n        if (cookieScope.startsWith(\".\")) {\n            cookieScope = cookieScope.substr(1);\n        }\n        if (!cookieScope.startsWith(\"http://\") && !cookieScope.startsWith(\"https://\")) {\n            cookieScope = \"http://\" + cookieScope;\n        }\n        try {\n            var urlObj = new URL(cookieScope);\n            cookieScope = urlObj.hostname;\n            // remove leading dot\n            if (cookieScope.startsWith(\".\")) {\n                cookieScope = cookieScope.substr(1);\n            }\n            return cookieScope;\n        } catch (err) {\n            throw new Error(\"Please provide a valid cookie scope\");\n        }\n    }\n    function isAnIpAddress(ipaddress) {\n        return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\n            ipaddress\n        );\n    }\n    var noDotNormalised = helper(cookieScope);\n    if (noDotNormalised === \"localhost\" || isAnIpAddress(noDotNormalised)) {\n        return noDotNormalised;\n    }\n    if (cookieScope.startsWith(\".\")) {\n        return \".\" + noDotNormalised;\n    }\n    return noDotNormalised;\n}\nfunction getDefaultCookieScope() {\n    try {\n        return normaliseCookieScopeOrThrowError(\n            windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHostName()\n        );\n    } catch (_a) {\n        return undefined;\n    }\n}\nfunction getCookieValue(name) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, _a, parts, last, temp;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = \"; \";\n                    return [\n                        4 /*yield*/,\n                        cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.getCookie(),\n                    ];\n                case 1:\n                    value = _a + _b.sent();\n                    parts = value.split(\"; \" + name + \"=\");\n                    if (parts.length >= 2) {\n                        last = parts.pop();\n                        if (last !== undefined) {\n                            temp = last.split(\";\").shift();\n                            if (temp === undefined) {\n                                return [2 /*return*/, null];\n                            }\n                            return [2 /*return*/, temp];\n                        }\n                    }\n                    return [2 /*return*/, null];\n            }\n        });\n    });\n}\n// undefined value will remove the cookie\nfunction setFrontendCookie(name, value, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        var expires, cookieVal;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    expires = \"Thu, 01 Jan 1970 00:00:01 GMT\";\n                    cookieVal = \"\";\n                    if (value !== undefined) {\n                        cookieVal = value;\n                        expires = undefined; // set cookie without expiry\n                    }\n                    if (\n                        !(\n                            scope === \"localhost\" ||\n                            scope ===\n                                windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHostName() ||\n                            scope === undefined\n                        )\n                    )\n                        return [3 /*break*/, 5];\n                    if (!(expires !== undefined)) return [3 /*break*/, 2];\n                    return [\n                        4 /*yield*/,\n                        cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(\n                            \"\".concat(name, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";path=/;samesite=lax\")\n                        ),\n                    ];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 4];\n                case 2:\n                    return [\n                        4 /*yield*/,\n                        cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(\n                            \"\"\n                                .concat(name, \"=\")\n                                .concat(cookieVal, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=lax\")\n                        ),\n                    ];\n                case 3:\n                    _a.sent();\n                    _a.label = 4;\n                case 4:\n                    return [3 /*break*/, 9];\n                case 5:\n                    if (!(expires !== undefined)) return [3 /*break*/, 7];\n                    return [\n                        4 /*yield*/,\n                        cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(\n                            \"\"\n                                .concat(name, \"=\")\n                                .concat(cookieVal, \";expires=\")\n                                .concat(expires, \";domain=\")\n                                .concat(scope, \";path=/;samesite=lax\")\n                        ),\n                    ];\n                case 6:\n                    _a.sent();\n                    return [3 /*break*/, 9];\n                case 7:\n                    return [\n                        4 /*yield*/,\n                        cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(\n                            \"\"\n                                .concat(name, \"=\")\n                                .concat(cookieVal, \";domain=\")\n                                .concat(scope, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=lax\")\n                        ),\n                    ];\n                case 8:\n                    _a.sent();\n                    _a.label = 9;\n                case 9:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction getNormalisedUserContext(userContext) {\n    return userContext === undefined ? {} : userContext;\n}\n/**\n * This function handles calling APIs that should only be called once during mount (mostly on mount of a route/feature component).\n * It's split into multiple callbacks (fetch + handleResponse/handleError) because we expect fetch to take longer and\n * and the component may be unmounted during the first fetch, in which case we want to avoid updating state/redirecting.\n * This is especially relevant for development in strict mode with React 18 (and in the future for concurrent rendering).\n *\n * @param fetch This is a callback that is only called once on mount. Mostly it's for consuming tokens/doing one time only API calls\n * @param handleResponse This is called with the result of the first (fetch) call if it succeeds.\n * @param handleError This is called with the error of the first (fetch) call if it rejects.\n * @param startLoading Will start the whole process if this is set to true (or omitted). Mostly used to wait for session loading.\n */\nvar useOnMountAPICall = function (fetch, handleResponse, handleError, startLoading) {\n    if (startLoading === void 0) {\n        startLoading = true;\n    }\n    var consumeReq = React.useRef();\n    var _a = React.useState(undefined),\n        error = _a[0],\n        setError = _a[1];\n    React.useEffect(\n        function () {\n            var effect = function (signal) {\n                return __awaiter(void 0, void 0, void 0, function () {\n                    var resp, err_1;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                _a.trys.push([0, 2, , 3]);\n                                if (consumeReq.current === undefined) {\n                                    consumeReq.current = fetch();\n                                }\n                                return [4 /*yield*/, consumeReq.current];\n                            case 1:\n                                resp = _a.sent();\n                                if (!signal.aborted) {\n                                    void handleResponse(resp);\n                                }\n                                return [3 /*break*/, 3];\n                            case 2:\n                                err_1 = _a.sent();\n                                if (!signal.aborted) {\n                                    if (handleError !== undefined) {\n                                        handleError(err_1, resp);\n                                    } else {\n                                        setError(err_1);\n                                    }\n                                }\n                                return [3 /*break*/, 3];\n                            case 3:\n                                return [2 /*return*/];\n                        }\n                    });\n                });\n            };\n            if (startLoading) {\n                var ctrl_1 = new AbortController();\n                void effect(ctrl_1.signal);\n                return function () {\n                    ctrl_1.abort();\n                };\n            }\n            return;\n        },\n        [setError, consumeReq, fetch, handleResponse, handleError, startLoading]\n    );\n    if (error) {\n        throw error;\n    }\n};\nfunction saveInvalidClaimRedirectPathInContext(userContext, invalidClaimRedirectPath) {\n    if (userContext[\"_default\"] === undefined) {\n        userContext[\"_default\"] = {};\n    }\n    if (userContext[\"_default\"].redirectPath === undefined) {\n        userContext[\"_default\"] = exports.__assign(exports.__assign({}, userContext[\"_default\"]), {\n            invalidClaimRedirectPath: invalidClaimRedirectPath,\n        });\n    }\n}\nfunction popInvalidClaimRedirectPathFromContext(userContext) {\n    var _a;\n    var res = (_a = userContext[\"_default\"]) === null || _a === void 0 ? void 0 : _a.invalidClaimRedirectPath;\n    if (res !== undefined) {\n        delete userContext[\"_default\"].invalidClaimRedirectPath;\n    }\n    return res;\n}\n\nvar TranslationController = /** @class */ (function () {\n    function TranslationController() {\n        this.handlers = new Map();\n    }\n    TranslationController.prototype.emit = function (event, detail) {\n        var handlerList = this.handlers.get(event) || [];\n        for (var _i = 0, handlerList_1 = handlerList; _i < handlerList_1.length; _i++) {\n            var h = handlerList_1[_i];\n            h(event, detail);\n        }\n    };\n    TranslationController.prototype.on = function (event, handler) {\n        var handlerList = this.handlers.get(event) || [];\n        this.handlers.set(event, handlerList.concat(handler));\n    };\n    TranslationController.prototype.off = function (event, handler) {\n        var handlerList = this.handlers.get(event) || [];\n        this.handlers.set(\n            event,\n            handlerList.filter(function (h) {\n                return h !== handler;\n            })\n        );\n    };\n    return TranslationController;\n})();\nvar CURRENT_LANGUAGE_COOKIE_NAME = \"sCurrLanguage\";\nfunction saveCurrentLanguage(language, cookieDomain) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, setFrontendCookie(CURRENT_LANGUAGE_COOKIE_NAME, language, cookieDomain)];\n                case 1:\n                    _b.sent();\n                    return [3 /*break*/, 3];\n                case 2:\n                    _b.sent();\n                    return [3 /*break*/, 3];\n                case 3:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction getCurrentLanguageFromCookie() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, getCookieValue(CURRENT_LANGUAGE_COOKIE_NAME)];\n                case 1:\n                    return [2 /*return*/, _b.sent()];\n                case 2:\n                    _b.sent();\n                    // This can throw if we are not in a browser\n                    // Since this is just loading a preference we can safely ignore the exception\n                    return [2 /*return*/, null];\n                case 3:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n\n/*\n * Class.\n */\nvar SuperTokens = /** @class */ (function () {\n    /*\n     * Constructor.\n     */\n    function SuperTokens(config) {\n        var _this = this;\n        this.recipeList = [];\n        /*\n         * Instance Methods.\n         */\n        this.canHandleRoute = function () {\n            return _this.getMatchingComponentForRouteAndRecipeId(getCurrentNormalisedUrlPath()) !== undefined;\n        };\n        this.getRoutingComponent = function () {\n            return jsxRuntime.jsx(RoutingComponent, {\n                path: getCurrentNormalisedUrlPath().getAsStringDangerous(),\n                supertokensInstance: _this,\n            });\n        };\n        this.getPathsToFeatureComponentWithRecipeIdMap = function () {\n            // Memoized version of the map.\n            if (_this.pathsToFeatureComponentWithRecipeIdMap !== undefined) {\n                return _this.pathsToFeatureComponentWithRecipeIdMap;\n            }\n            var pathsToFeatureComponentWithRecipeIdMap = {};\n            for (var i = 0; i < _this.recipeList.length; i++) {\n                var recipe = _this.recipeList[i];\n                var features = recipe.getFeatures();\n                var featurePaths = Object.keys(features);\n                for (var j = 0; j < featurePaths.length; j++) {\n                    // If no components yet for this route, initialize empty array.\n                    var featurePath = featurePaths[j];\n                    if (pathsToFeatureComponentWithRecipeIdMap[featurePath] === undefined) {\n                        pathsToFeatureComponentWithRecipeIdMap[featurePath] = [];\n                    }\n                    pathsToFeatureComponentWithRecipeIdMap[featurePath].push(features[featurePath]);\n                }\n            }\n            _this.pathsToFeatureComponentWithRecipeIdMap = pathsToFeatureComponentWithRecipeIdMap;\n            return _this.pathsToFeatureComponentWithRecipeIdMap;\n        };\n        this.getMatchingComponentForRouteAndRecipeId = function (normalisedUrl) {\n            var path = normalisedUrl.getAsStringDangerous();\n            var routeComponents = _this.getPathsToFeatureComponentWithRecipeIdMap()[path];\n            if (routeComponents === undefined) {\n                return undefined;\n            }\n            var component = routeComponents.find(function (c) {\n                return c.matches();\n            });\n            if (component !== undefined) {\n                return component;\n            }\n            // Otherwise, If no recipe Id provided, or if no recipe id matches, return the first matching component.\n            return routeComponents[0];\n        };\n        this.getReactRouterDomWithCustomHistory = function () {\n            return SuperTokens.reactRouterDom;\n        };\n        this.changeLanguage = function (lang) {\n            return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            return [\n                                4 /*yield*/,\n                                saveCurrentLanguage(lang, this.languageTranslations.currentLanguageCookieScope),\n                            ];\n                        case 1:\n                            _a.sent();\n                            this.languageTranslations.translationEventSource.emit(\"LanguageChange\", lang);\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        this.redirectToAuth = function (options) {\n            return __awaiter(_this, void 0, void 0, function () {\n                var queryParams, redirectUrl;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            queryParams = options.queryParams === undefined ? {} : options.queryParams;\n                            if (options.show !== undefined) {\n                                queryParams.show = options.show;\n                            }\n                            if (options.redirectBack === true) {\n                                queryParams.redirectToPath = getCurrentNormalisedUrlPath().getAsStringDangerous();\n                            }\n                            return [\n                                4 /*yield*/,\n                                this.getRedirectUrl({\n                                    action: \"TO_AUTH\",\n                                    showSignIn: options.show === \"signin\",\n                                }),\n                            ];\n                        case 1:\n                            redirectUrl = _a.sent();\n                            redirectUrl = appendQueryParamsToURL(redirectUrl, queryParams);\n                            return [2 /*return*/, this.redirectToUrl(redirectUrl, options.history)];\n                    }\n                });\n            });\n        };\n        this.redirectToUrl = function (redirectUrl, history) {\n            return __awaiter(_this, void 0, void 0, function () {\n                var origin_1;\n                return __generator(this, function (_a) {\n                    try {\n                        new URL(redirectUrl); // If full URL, no error thrown, skip in app redirection.\n                    } catch (e) {\n                        origin_1 = getOriginOfPage().getAsStringDangerous();\n                        if (origin_1 !== this.appInfo.websiteDomain.getAsStringDangerous()) {\n                            redirectUrl = \"\"\n                                .concat(this.appInfo.websiteDomain.getAsStringDangerous())\n                                .concat(redirectUrl);\n                            redirectWithFullPageReload(redirectUrl);\n                            return [2 /*return*/];\n                        }\n                        // If history was provided, use to redirect without reloading.\n                        if (history !== undefined) {\n                            redirectWithHistory(redirectUrl, history);\n                            return [2 /*return*/];\n                        }\n                    }\n                    // Otherwise, redirect in app.\n                    redirectWithFullPageReload(redirectUrl);\n                    return [2 /*return*/];\n                });\n            });\n        };\n        this.appInfo = normaliseInputAppInfoOrThrowError(config.appInfo);\n        if (config.recipeList === undefined || config.recipeList.length === 0) {\n            throw new Error(\n                \"Please provide at least one recipe to the supertokens.init function call. See https://supertokens.io/docs/emailpassword/quick-setup/frontend\"\n            );\n        }\n        var translationConfig = config.languageTranslations === undefined ? {} : config.languageTranslations;\n        this.languageTranslations = {\n            defaultLanguage: translationConfig.defaultLanguage === undefined ? \"en\" : translationConfig.defaultLanguage,\n            currentLanguageCookieScope:\n                translationConfig.currentLanguageCookieScope !== undefined\n                    ? normaliseCookieScopeOrThrowError(translationConfig.currentLanguageCookieScope)\n                    : getDefaultCookieScope(),\n            userTranslationStore: translationConfig.translations !== undefined ? translationConfig.translations : {},\n            translationEventSource: new TranslationController(),\n            userTranslationFunc: translationConfig.translationFunc,\n        };\n        var enableDebugLogs = false;\n        if (config.enableDebugLogs !== undefined) {\n            enableDebugLogs = config.enableDebugLogs;\n        }\n        this.userGetRedirectionURL = config.getRedirectionURL;\n        this.recipeList = config.recipeList.map(function (recipe) {\n            return recipe(_this.appInfo, enableDebugLogs);\n        });\n    }\n    /*\n     * Static Methods.\n     */\n    SuperTokens.init = function (config) {\n        cookieHandler.CookieHandlerReference.init(config.cookieHandler);\n        windowHandler.WindowHandlerReference.init(config.windowHandler);\n        if (SuperTokens.instance !== undefined) {\n            console.warn(\"SuperTokens was already initialized\");\n            return;\n        }\n        SuperTokens.instance = new SuperTokens(config);\n        postSuperTokensInitCallbacks.PostSuperTokensInitCallbacks.runPostInitCallbacks();\n    };\n    SuperTokens.getInstanceOrThrow = function () {\n        if (SuperTokens.instance === undefined) {\n            var error = \"SuperTokens must be initialized before calling this method.\";\n            // eslint-disable-next-line supertokens-auth-react/no-direct-window-object\n            if (typeof window === \"undefined\") {\n                error = error + SSR_ERROR;\n            }\n            throw new Error(error);\n        }\n        return SuperTokens.instance;\n    };\n    SuperTokens.canHandleRoute = function () {\n        return SuperTokens.getInstanceOrThrow().canHandleRoute();\n    };\n    SuperTokens.getRoutingComponent = function () {\n        return SuperTokens.getInstanceOrThrow().getRoutingComponent();\n    };\n    SuperTokens.getSuperTokensRoutesForReactRouterDom = function (reactRouterDom) {\n        if (reactRouterDom === undefined) {\n            throw new Error(\n                // eslint-disable-next-line @typescript-eslint/quotes\n                'Please use getSuperTokensRoutesForReactRouterDom like getSuperTokensRoutesForReactRouterDom(require(\"react-router-dom\")) in your render function'\n            );\n        }\n        SuperTokens.reactRouterDom = reactRouterDom;\n        if (SuperTokens.reactRouterDomIsV6 === undefined) {\n            SuperTokens.reactRouterDomIsV6 = reactRouterDom.withRouter === undefined;\n        }\n        if (SuperTokens.reactRouterDomIsV6) {\n            // this function wraps the react-router-dom v6 useNavigate function in a way\n            // that enforces that it runs within a useEffect. The reason we do this is\n            // cause of https://github.com/remix-run/react-router/issues/7460\n            // which gets shown when visiting a social auth callback url like\n            // /auth/callback/github, without a valid code or state. This then\n            // doesn't navigate the user to the auth page.\n            var useNavigateHookForRRDV6 = function () {\n                var navigateHook = reactRouterDom.useNavigate();\n                var _a = React__namespace.useState(undefined),\n                    to = _a[0],\n                    setTo = _a[1];\n                React__namespace.useEffect(\n                    function () {\n                        if (to !== undefined) {\n                            setTo(undefined);\n                            navigateHook(to);\n                        }\n                    },\n                    [to, navigateHook, setTo]\n                );\n                return setTo;\n            };\n            SuperTokens.reactRouterDom = {\n                router: reactRouterDom,\n                useHistoryCustom: useNavigateHookForRRDV6,\n            };\n            return getSuperTokensRoutesForReactRouterDomV6(SuperTokens.getInstanceOrThrow());\n        }\n        SuperTokens.reactRouterDom = {\n            router: reactRouterDom,\n            useHistoryCustom: reactRouterDom.useHistory,\n        };\n        return getSuperTokensRoutesForReactRouterDom(SuperTokens.getInstanceOrThrow());\n    };\n    SuperTokens.getReactRouterDomWithCustomHistory = function () {\n        return this.instance !== undefined ? this.instance.getReactRouterDomWithCustomHistory() : undefined;\n    };\n    SuperTokens.prototype.getRecipeOrThrow = function (recipeId) {\n        var recipe = this.recipeList.find(function (recipe) {\n            return recipe.config.recipeId === recipeId;\n        });\n        if (recipe === undefined) {\n            throw new Error(\"Missing recipe: \".concat(recipeId));\n        }\n        return recipe;\n    };\n    SuperTokens.prototype.loadTranslation = function (store) {\n        this.languageTranslations.translationEventSource.emit(\"TranslationLoaded\", store);\n    };\n    SuperTokens.prototype.getRedirectUrl = function (context) {\n        return __awaiter(this, void 0, void 0, function () {\n            var userRes, redirectUrl;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.userGetRedirectionURL) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.userGetRedirectionURL(context)];\n                    case 1:\n                        userRes = _a.sent();\n                        if (userRes !== undefined) {\n                            return [2 /*return*/, userRes];\n                        }\n                        _a.label = 2;\n                    case 2:\n                        if (context.action === \"TO_AUTH\") {\n                            redirectUrl = this.appInfo.websiteBasePath.getAsStringDangerous();\n                            return [2 /*return*/, appendTrailingSlashToURL(redirectUrl)];\n                        }\n                        throw new Error(\"Should never come here: unexpected redirection context\");\n                }\n            });\n        });\n    };\n    /*\n     * Tests methods.\n     */\n    SuperTokens.reset = function () {\n        if (!isTest()) {\n            return;\n        }\n        SuperTokens.instance = undefined;\n        return;\n    };\n    SuperTokens.reactRouterDomIsV6 = undefined;\n    return SuperTokens;\n})();\n\nvar UserContextContext = React__namespace.default.createContext(undefined);\nvar useUserContext = function () {\n    return React__namespace.default.useContext(UserContextContext);\n};\nvar UserContextProvider = function (_a) {\n    var children = _a.children,\n        userContext = _a.userContext;\n    var currentUserContext = React.useState(getNormalisedUserContext(userContext))[0];\n    return jsxRuntime.jsx(\n        UserContextContext.Provider,\n        exports.__assign({ value: currentUserContext }, { children: children })\n    );\n};\n\nfunction UserContextWrapper(props) {\n    /**\n     * If we recieve a userContext as a props we should assume that the user\n     * is either trying to use a theme component as standalone or that they\n     * want to override an existing value for userContext.\n     *\n     * In this case we should always return a Provider with the value of userContext\n     */\n    if (props.userContext !== undefined) {\n        return jsxRuntime.jsx(\n            UserContextProvider,\n            exports.__assign({ userContext: props.userContext }, { children: props.children })\n        );\n    }\n    return jsxRuntime.jsx(UserContextContext.Consumer, {\n        children: function (value) {\n            /**\n             * value is undefined only if there is no Provider in the tree. In this case it is safe to\n             * assume that the theme component is not being rendered by the SDK and that the user is not\n             * using this as a child of one of the pre-built feature components.\n             *\n             * In this case we return a provider so that the userContext hook can be used by the children\n             * of this theme component\n             */\n            if (value === undefined) {\n                return jsxRuntime.jsx(UserContextProvider, { children: props.children });\n            }\n            /**\n             * If value is not undefined then a provider exists in the tree. This means that this component\n             * is either being rendered by the SDK or the user has added it as a child of the pre-built\n             * feature components. In either case the userContext hook will be available so simply\n             * return the theme component.\n             */\n            return props.children;\n        },\n    });\n}\n\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n/*\n * Class.\n */\nvar RecipeModule = /** @class */ (function () {\n    /*\n     * Constructor.\n     */\n    function RecipeModule(config) {\n        var _this = this;\n        this.redirect = function (context, history, queryParams) {\n            return __awaiter(_this, void 0, void 0, function () {\n                var redirectUrl;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            return [4 /*yield*/, this.getRedirectUrl(context)];\n                        case 1:\n                            redirectUrl = _a.sent();\n                            redirectUrl = appendQueryParamsToURL(redirectUrl, queryParams);\n                            return [2 /*return*/, SuperTokens.getInstanceOrThrow().redirectToUrl(redirectUrl, history)];\n                    }\n                });\n            });\n        };\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        this.getRedirectUrl = function (context) {\n            return __awaiter(_this, void 0, void 0, function () {\n                var redirectUrl;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            return [4 /*yield*/, this.config.getRedirectionURL(context)];\n                        case 1:\n                            redirectUrl = _a.sent();\n                            if (redirectUrl !== undefined) {\n                                return [2 /*return*/, redirectUrl];\n                            }\n                            return [4 /*yield*/, this.getDefaultRedirectionURL(context)];\n                        case 2:\n                            // Otherwise, use default.\n                            return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        this.config = config;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    RecipeModule.prototype.getDefaultRedirectionURL = function (_) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error(\"getDefaultRedirectionURL is not implemented.\");\n            });\n        });\n    };\n    return RecipeModule;\n})();\n\nfunction normaliseRecipeModuleConfig(config) {\n    var _this = this;\n    var onHandleEvent = config.onHandleEvent,\n        getRedirectionURL = config.getRedirectionURL,\n        preAPIHook = config.preAPIHook,\n        postAPIHook = config.postAPIHook;\n    if (onHandleEvent === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n        onHandleEvent = function (_) {};\n    }\n    if (getRedirectionURL === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        getRedirectionURL = function (_) {\n            return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    return [2 /*return*/, undefined];\n                });\n            });\n        };\n    }\n    if (preAPIHook === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        preAPIHook = function (context) {\n            return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    return [2 /*return*/, context];\n                });\n            });\n        };\n    }\n    if (postAPIHook === undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        postAPIHook = function () {\n            return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    return [2 /*return*/];\n                });\n            });\n        };\n    }\n    var useShadowDom = config.useShadowDom === undefined ? true : config.useShadowDom;\n    useShadowDom = getShouldUseShadowDomBasedOnBrowser(useShadowDom);\n    var rootStyle = config.style === undefined ? \"\" : config.style;\n    return exports.__assign(exports.__assign({}, config), {\n        getRedirectionURL: getRedirectionURL,\n        onHandleEvent: onHandleEvent,\n        preAPIHook: preAPIHook,\n        postAPIHook: postAPIHook,\n        useShadowDom: useShadowDom,\n        rootStyle: rootStyle,\n        recipeId: config.recipeId,\n        appInfo: config.appInfo,\n    });\n}\nfunction getShouldUseShadowDomBasedOnBrowser(useShadowDom) {\n    /*\n     * Detect if browser is IE\n     * In order to disable unsupported shadowDom\n     * https://github.com/supertokens/supertokens-auth-react/issues/99\n     */\n    // If browser is Internet Explorer, always disable shadow dom.\n    if (isIE() === true) {\n        return false;\n    }\n    // Otherwise, use provided config or default to true.\n    return useShadowDom !== undefined ? useShadowDom : true;\n}\n\n/* Copyright (c) 2021, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\nvar Session = /** @class */ (function (_super) {\n    __extends(Session, _super);\n    function Session(config) {\n        var _this = this;\n        var normalizedConfig = exports.__assign(exports.__assign({}, config), normaliseRecipeModuleConfig(config));\n        _this = _super.call(this, normalizedConfig) || this;\n        _this.eventListeners = new Set();\n        _this.redirectionHandlersFromAuthRecipes = new Map();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        _this.getFeatureComponent = function (_) {\n            throw new Error(\"should never come here\");\n        };\n        _this.getFeatures = function () {\n            return {};\n        };\n        _this.getUserId = function (input) {\n            return _this.webJsRecipe.getUserId(input);\n        };\n        _this.getAccessToken = function (input) {\n            return _this.webJsRecipe.getAccessToken(input);\n        };\n        _this.getClaimValue = function (input) {\n            return _this.webJsRecipe.getClaimValue(input);\n        };\n        _this.getAccessTokenPayloadSecurely = function (input) {\n            return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    return [2 /*return*/, this.webJsRecipe.getAccessTokenPayloadSecurely(input)];\n                });\n            });\n        };\n        _this.doesSessionExist = function (input) {\n            return _this.webJsRecipe.doesSessionExist(input);\n        };\n        _this.signOut = function (input) {\n            return _this.webJsRecipe.signOut(input);\n        };\n        _this.attemptRefreshingSession = function () {\n            return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    return [2 /*return*/, this.webJsRecipe.attemptRefreshingSession()];\n                });\n            });\n        };\n        _this.validateClaims = function (input) {\n            return _this.webJsRecipe.validateClaims(input);\n        };\n        _this.getInvalidClaimsFromResponse = function (input) {\n            return _this.webJsRecipe.getInvalidClaimsFromResponse(input);\n        };\n        /**\n         * @returns Function to remove event listener\n         */\n        _this.addEventListener = function (listener) {\n            _this.eventListeners.add(listener);\n            return function () {\n                return _this.eventListeners.delete(listener);\n            };\n        };\n        _this.addAuthRecipeRedirectionHandler = function (rid, redirect) {\n            _this.redirectionHandlersFromAuthRecipes.set(rid, redirect);\n        };\n        _this.validateGlobalClaimsAndHandleSuccessRedirection = function (redirectInfo, userContext, history) {\n            return __awaiter(_this, void 0, void 0, function () {\n                var invalidClaims, invalidClaimRedirectPath, jsonContext, successContextStr, authRecipeRedirectHandler;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            return [4 /*yield*/, this.doesSessionExist({ userContext: userContext })];\n                        case 1:\n                            // First we check if there is an active session\n                            if (!_a.sent()) {\n                                // If there is none, we have no way of checking claims, so we redirect to the auth page\n                                // This can happen e.g.: if the user clicked on the email verification link in a browser without an active session\n                                return [\n                                    2 /*return*/,\n                                    SuperTokens.getInstanceOrThrow().redirectToAuth({\n                                        history: history,\n                                        redirectBack: false,\n                                    }),\n                                ];\n                            }\n                            return [4 /*yield*/, this.validateClaims({ userContext: userContext })];\n                        case 2:\n                            invalidClaims = _a.sent();\n                            invalidClaimRedirectPath = popInvalidClaimRedirectPathFromContext(userContext);\n                            if (!(invalidClaims.length > 0 && invalidClaimRedirectPath !== undefined))\n                                return [3 /*break*/, 5];\n                            if (!(redirectInfo !== undefined)) return [3 /*break*/, 4];\n                            jsonContext = JSON.stringify(redirectInfo);\n                            return [\n                                4 /*yield*/,\n                                setLocalStorage(\"supertokens-success-redirection-context\", jsonContext),\n                            ];\n                        case 3:\n                            _a.sent();\n                            _a.label = 4;\n                        case 4:\n                            // then we do the redirection.\n                            return [\n                                2 /*return*/,\n                                SuperTokens.getInstanceOrThrow().redirectToUrl(invalidClaimRedirectPath, history),\n                            ];\n                        case 5:\n                            if (!(redirectInfo === undefined)) return [3 /*break*/, 12];\n                            return [4 /*yield*/, getLocalStorage(\"supertokens-success-redirection-context\")];\n                        case 6:\n                            successContextStr = _a.sent();\n                            if (!(successContextStr !== null)) return [3 /*break*/, 11];\n                            _a.label = 7;\n                        case 7:\n                            _a.trys.push([7, , 8, 10]);\n                            redirectInfo = JSON.parse(successContextStr);\n                            return [3 /*break*/, 10];\n                        case 8:\n                            return [4 /*yield*/, removeFromLocalStorage(\"supertokens-success-redirection-context\")];\n                        case 9:\n                            _a.sent();\n                            return [7 /*endfinally*/];\n                        case 10:\n                            return [3 /*break*/, 12];\n                        case 11:\n                            // If there was nothing in localstorage we set a default\n                            // this can happen if the user visited email verification screen without an auth recipe redirecting them there\n                            // but already had the email verified and an active session\n                            redirectInfo = {\n                                rid: Session.RECIPE_ID,\n                                successRedirectContext: {\n                                    action: \"SUCCESS\",\n                                    isNewUser: false,\n                                },\n                            };\n                            _a.label = 12;\n                        case 12:\n                            authRecipeRedirectHandler = this.redirectionHandlersFromAuthRecipes.get(redirectInfo.rid);\n                            if (authRecipeRedirectHandler !== undefined) {\n                                // and call it with the saved info\n                                return [\n                                    2 /*return*/,\n                                    authRecipeRedirectHandler(redirectInfo.successRedirectContext, history),\n                                ];\n                            }\n                            // This should only happen if the configuration changed between saving the context and finishing the sign in process\n                            // or if the user navigated to a page where they were expected to have a stored redirectInfo but didn't\n                            // (e.g.: pressed back after email verification)\n                            return [2 /*return*/, this.redirect(redirectInfo.successRedirectContext, history)];\n                    }\n                });\n            });\n        };\n        /**\n         * This should only get called if validateGlobalClaimsAndHandleSuccessRedirection couldn't get a redirectInfo\n         * @returns \"/\"\n         */\n        _this.getDefaultRedirectionURL = function () {\n            return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    return [2 /*return*/, \"/\"];\n                });\n            });\n        };\n        _this.notifyListeners = function (event) {\n            return __awaiter(_this, void 0, void 0, function () {\n                var sessionContext;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            return [4 /*yield*/, this.getSessionContext(event)];\n                        case 1:\n                            sessionContext = _a.sent();\n                            // We copy this.eventListeners into a new array to \"freeze\" it for the loop\n                            // We do this to avoid an infinite loop in case one of the listeners causes a new listener to be added (e.g.: through re-rendering)\n                            Array.from(this.eventListeners).forEach(function (listener) {\n                                return listener(exports.__assign({ sessionContext: sessionContext }, event));\n                            });\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        _this.webJsRecipe = new recipe.Recipe(\n            exports.__assign(exports.__assign({}, normalizedConfig), {\n                onHandleEvent: function (event) {\n                    if (config.onHandleEvent !== undefined) {\n                        config.onHandleEvent(event);\n                    }\n                    void _this.notifyListeners(event);\n                },\n                preAPIHook: function (context) {\n                    return __awaiter(_this, void 0, void 0, function () {\n                        var headers, response;\n                        return __generator(this, function (_a) {\n                            headers = new Headers(context.requestInit.headers);\n                            headers.set(\"rid\", config.recipeId);\n                            response = exports.__assign(exports.__assign({}, context), {\n                                requestInit: exports.__assign(exports.__assign({}, context.requestInit), {\n                                    headers: headers,\n                                }),\n                            });\n                            if (config.preAPIHook === undefined) {\n                                return [2 /*return*/, response];\n                            } else {\n                                return [2 /*return*/, config.preAPIHook(context)];\n                            }\n                        });\n                    });\n                },\n            })\n        );\n        return _this;\n    }\n    Session.prototype.getSessionContext = function (_a) {\n        var action = _a.action,\n            userContext = _a.userContext;\n        return __awaiter(this, void 0, void 0, function () {\n            var _b, userId, accessTokenPayload;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (\n                            !(\n                                action === \"SESSION_CREATED\" ||\n                                action === \"REFRESH_SESSION\" ||\n                                action === \"API_INVALID_CLAIM\" ||\n                                action === \"ACCESS_TOKEN_PAYLOAD_UPDATED\"\n                            )\n                        )\n                            return [3 /*break*/, 2];\n                        return [\n                            4 /*yield*/,\n                            Promise.all([\n                                this.getUserId({\n                                    userContext: userContext,\n                                }),\n                                this.getAccessTokenPayloadSecurely({\n                                    userContext: userContext,\n                                }),\n                            ]),\n                        ];\n                    case 1:\n                        (_b = _c.sent()), (userId = _b[0]), (accessTokenPayload = _b[1]);\n                        return [\n                            2 /*return*/,\n                            {\n                                doesSessionExist: true,\n                                accessTokenPayload: accessTokenPayload,\n                                userId: userId,\n                            },\n                        ];\n                    case 2:\n                        if (action === \"SIGN_OUT\" || action === \"UNAUTHORISED\") {\n                            return [\n                                2 /*return*/,\n                                {\n                                    doesSessionExist: false,\n                                    accessTokenPayload: {},\n                                    userId: \"\",\n                                },\n                            ];\n                        }\n                        throw new Error(\"Unhandled recipe event: \".concat(action));\n                }\n            });\n        });\n    };\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    Session.addAxiosInterceptors = function (axiosInstance, userContext) {\n        return recipe.Recipe.addAxiosInterceptors(axiosInstance, userContext);\n    };\n    Session.init = function (config) {\n        return function (appInfo, enableDebugLogs) {\n            Session.instance = new Session(\n                exports.__assign(exports.__assign({}, config), {\n                    appInfo: appInfo,\n                    recipeId: Session.RECIPE_ID,\n                    enableDebugLogs: enableDebugLogs,\n                })\n            );\n            return Session.instance;\n        };\n    };\n    Session.getInstanceOrThrow = function () {\n        if (Session.instance === undefined) {\n            throw Error(\n                \"No instance of Session found. Make sure to call the Session.init method. See https://supertokens.io/docs/emailpassword/quick-setup/frontend\"\n            );\n        }\n        return Session.instance;\n    };\n    Session.getInstance = function () {\n        return Session.instance;\n    };\n    Session.reset = function () {\n        if (!isTest()) {\n            return;\n        }\n        Session.instance = undefined;\n        return;\n    };\n    Session.RECIPE_ID = \"session\";\n    return Session;\n})(RecipeModule);\n\nvar SessionContext = React__namespace.default.createContext({\n    loading: true,\n    isDefault: true,\n});\n\nvar SessionAuth = function (_a) {\n    var _b;\n    var children = _a.children,\n        props = __rest(_a, [\"children\"]);\n    var requireAuth = React.useRef(props.requireAuth);\n    if (props.requireAuth !== requireAuth.current) {\n        throw new Error(\n            // eslint-disable-next-line @typescript-eslint/quotes\n            'requireAuth prop should not change. If you are seeing this, it probably means that you are using SessionAuth in multiple routes with different values for requireAuth. To solve this, try adding the \"key\" prop to all uses of SessionAuth like <SessionAuth key=\"someUniqueKeyPerRoute\" requireAuth={...}>'\n        );\n    }\n    // Reusing the parent context was removed because it caused a redirect loop in an edge case\n    // because it'd also reuse the invalid claims part until it loaded.\n    var _c = React.useState({ loading: true }),\n        context = _c[0],\n        setContext = _c[1];\n    var session = React.useRef();\n    // We store this here, to prevent the list of called hooks changing even if a history hook is added later to SuperTokens.\n    var historyHookRef = React.useRef(\n        (_b = SuperTokens.getReactRouterDomWithCustomHistory()) === null || _b === void 0 ? void 0 : _b.useHistoryCustom\n    );\n    var history;\n    try {\n        if (historyHookRef.current) {\n            history = historyHookRef.current();\n        }\n    } catch (_d) {\n        // We catch and ignore errors here, because if this is may throw if\n        // the app is using react-router-dom but added a session auth outside of the router.\n    }\n    var userContext = useUserContext();\n    var redirectToLogin = React.useCallback(function () {\n        void SuperTokens.getInstanceOrThrow().redirectToAuth({ history: history, redirectBack: true });\n    }, []);\n    var buildContext = React.useCallback(function () {\n        return __awaiter(void 0, void 0, void 0, function () {\n            var sessionExists, invalidClaims, err_1, invalidClaimRedirectToPath, err_2;\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (session.current === undefined) {\n                            session.current = Session.getInstanceOrThrow();\n                        }\n                        return [\n                            4 /*yield*/,\n                            session.current.doesSessionExist({\n                                userContext: userContext,\n                            }),\n                        ];\n                    case 1:\n                        sessionExists = _b.sent();\n                        if (sessionExists === false) {\n                            return [\n                                2 /*return*/,\n                                {\n                                    loading: false,\n                                    doesSessionExist: false,\n                                    accessTokenPayload: {},\n                                    invalidClaims: [],\n                                    userId: \"\",\n                                },\n                            ];\n                        }\n                        _b.label = 2;\n                    case 2:\n                        _b.trys.push([2, 4, , 6]);\n                        return [\n                            4 /*yield*/,\n                            session.current.validateClaims({\n                                overrideGlobalClaimValidators: props.overrideGlobalClaimValidators,\n                                userContext: userContext,\n                            }),\n                        ];\n                    case 3:\n                        invalidClaims = _b.sent();\n                        return [3 /*break*/, 6];\n                    case 4:\n                        err_1 = _b.sent();\n                        return [\n                            4 /*yield*/,\n                            session.current.doesSessionExist({\n                                userContext: userContext,\n                            }),\n                        ];\n                    case 5:\n                        // These errors should only come from getAccessTokenPayloadSecurely inside validateClaims if refreshing a claim cleared the session\n                        // Which means that the session was most likely cleared, meaning returning false is right.\n                        // This might also happen if the user provides an override or a custom claim validator that throws (or if we have a bug)\n                        // In which case the session will not be cleared so we rethrow the error\n                        if (_b.sent()) {\n                            throw err_1;\n                        }\n                        return [\n                            2 /*return*/,\n                            {\n                                loading: false,\n                                doesSessionExist: false,\n                                accessTokenPayload: {},\n                                invalidClaims: [],\n                                userId: \"\",\n                            },\n                        ];\n                    case 6:\n                        invalidClaimRedirectToPath = popInvalidClaimRedirectPathFromContext(userContext);\n                        _b.label = 7;\n                    case 7:\n                        _b.trys.push([7, 10, , 12]);\n                        _a = {\n                            loading: false,\n                            doesSessionExist: true,\n                            invalidClaims: invalidClaims,\n                            invalidClaimRedirectToPath: invalidClaimRedirectToPath,\n                        };\n                        return [\n                            4 /*yield*/,\n                            session.current.getAccessTokenPayloadSecurely({\n                                userContext: userContext,\n                            }),\n                        ];\n                    case 8:\n                        _a.accessTokenPayload = _b.sent();\n                        return [\n                            4 /*yield*/,\n                            session.current.getUserId({\n                                userContext: userContext,\n                            }),\n                        ];\n                    case 9:\n                        return [2 /*return*/, ((_a.userId = _b.sent()), _a)];\n                    case 10:\n                        err_2 = _b.sent();\n                        return [\n                            4 /*yield*/,\n                            session.current.doesSessionExist({\n                                userContext: userContext,\n                            }),\n                        ];\n                    case 11:\n                        if (_b.sent()) {\n                            throw err_2;\n                        }\n                        // This means that loading the access token or the userId failed\n                        // This may happen if the server cleared the error since the validation was done which should be extremely rare\n                        return [\n                            2 /*return*/,\n                            {\n                                loading: false,\n                                doesSessionExist: false,\n                                accessTokenPayload: {},\n                                invalidClaims: [],\n                                userId: \"\",\n                            },\n                        ];\n                    case 12:\n                        return [2 /*return*/];\n                }\n            });\n        });\n    }, []);\n    var setInitialContextAndMaybeRedirect = React.useCallback(\n        function (toSetContext) {\n            return __awaiter(void 0, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (context.loading === false) {\n                                return [2 /*return*/];\n                            }\n                            if (!(props.doRedirection !== false)) return [3 /*break*/, 3];\n                            if (!(!toSetContext.doesSessionExist && props.requireAuth !== false))\n                                return [3 /*break*/, 1];\n                            redirectToLogin();\n                            return [2 /*return*/];\n                        case 1:\n                            if (!(toSetContext.invalidClaimRedirectToPath !== undefined)) return [3 /*break*/, 3];\n                            return [\n                                4 /*yield*/,\n                                SuperTokens.getInstanceOrThrow().redirectToUrl(\n                                    toSetContext.invalidClaimRedirectToPath,\n                                    history\n                                ),\n                            ];\n                        case 2:\n                            _a.sent();\n                            return [2 /*return*/];\n                        case 3:\n                            delete toSetContext.invalidClaimRedirectToPath;\n                            setContext(toSetContext);\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        },\n        [props.doRedirection, props.requireAuth, redirectToLogin, context]\n    );\n    useOnMountAPICall(buildContext, setInitialContextAndMaybeRedirect);\n    // subscribe to events on mount\n    React.useEffect(\n        function () {\n            function onHandleEvent(event) {\n                return __awaiter(this, void 0, void 0, function () {\n                    var _a, invalidClaims, redirectPath;\n                    return __generator(this, function (_b) {\n                        switch (_b.label) {\n                            case 0:\n                                _a = event.action;\n                                switch (_a) {\n                                    case \"SESSION_CREATED\":\n                                        return [3 /*break*/, 1];\n                                    case \"REFRESH_SESSION\":\n                                        return [3 /*break*/, 1];\n                                    case \"ACCESS_TOKEN_PAYLOAD_UPDATED\":\n                                        return [3 /*break*/, 1];\n                                    case \"API_INVALID_CLAIM\":\n                                        return [3 /*break*/, 1];\n                                    case \"SIGN_OUT\":\n                                        return [3 /*break*/, 5];\n                                    case \"UNAUTHORISED\":\n                                        return [3 /*break*/, 6];\n                                }\n                                return [3 /*break*/, 7];\n                            case 1:\n                                return [\n                                    4 /*yield*/,\n                                    session.current.validateClaims({\n                                        overrideGlobalClaimValidators: props.overrideGlobalClaimValidators,\n                                        userContext: userContext,\n                                    }),\n                                ];\n                            case 2:\n                                invalidClaims = _b.sent();\n                                setContext(\n                                    exports.__assign(exports.__assign({}, event.sessionContext), {\n                                        loading: false,\n                                        invalidClaims: invalidClaims,\n                                    })\n                                );\n                                redirectPath = popInvalidClaimRedirectPathFromContext(userContext);\n                                if (!(props.doRedirection !== false && redirectPath)) return [3 /*break*/, 4];\n                                return [\n                                    4 /*yield*/,\n                                    SuperTokens.getInstanceOrThrow().redirectToUrl(redirectPath, history),\n                                ];\n                            case 3:\n                                _b.sent();\n                                _b.label = 4;\n                            case 4:\n                                return [2 /*return*/];\n                            case 5:\n                                setContext(\n                                    exports.__assign(exports.__assign({}, event.sessionContext), {\n                                        loading: false,\n                                        invalidClaims: [],\n                                    })\n                                );\n                                return [2 /*return*/];\n                            case 6:\n                                setContext(\n                                    exports.__assign(exports.__assign({}, event.sessionContext), {\n                                        loading: false,\n                                        invalidClaims: [],\n                                    })\n                                );\n                                if (props.onSessionExpired !== undefined) {\n                                    props.onSessionExpired();\n                                } else if (props.requireAuth !== false && props.doRedirection !== false) {\n                                    redirectToLogin();\n                                }\n                                return [2 /*return*/];\n                            case 7:\n                                return [2 /*return*/];\n                        }\n                    });\n                });\n            }\n            if (session.current === undefined) {\n                session.current = Session.getInstanceOrThrow();\n            }\n            if (context.loading === false) {\n                // we return here cause addEventListener returns a function that removes\n                // the listener, and this function will be called by useEffect when\n                // onHandleEvent changes or if the component is unmounting.\n                return session.current.addEventListener(onHandleEvent);\n            }\n            return undefined;\n        },\n        [props, setContext, context.loading]\n    );\n    if (props.requireAuth !== false && (context.loading || !context.doesSessionExist)) {\n        return null;\n    }\n    return jsxRuntime.jsx(SessionContext.Provider, exports.__assign({ value: context }, { children: children }));\n};\nvar SessionAuthWrapper = function (props) {\n    return jsxRuntime.jsx(\n        UserContextWrapper,\n        exports.__assign(\n            { userContext: props.userContext },\n            { children: jsxRuntime.jsx(SessionAuth, exports.__assign({}, props)) }\n        )\n    );\n};\n\nexports.RecipeModule = RecipeModule;\nexports.SSR_ERROR = SSR_ERROR;\nexports.ST_ROOT_ID = ST_ROOT_ID;\nexports.Session = Session;\nexports.SessionAuthWrapper = SessionAuthWrapper;\nexports.SessionContext = SessionContext;\nexports.SuperTokens = SuperTokens;\nexports.UserContextContext = UserContextContext;\nexports.UserContextWrapper = UserContextWrapper;\nexports.__awaiter = __awaiter;\nexports.__extends = __extends;\nexports.__generator = __generator;\nexports.__rest = __rest;\nexports.__spreadArray = __spreadArray;\nexports.clearErrorQueryParam = clearErrorQueryParam;\nexports.clearQueryParams = clearQueryParams;\nexports.getCurrentLanguageFromCookie = getCurrentLanguageFromCookie;\nexports.getNormalisedUserContext = getNormalisedUserContext;\nexports.getQueryParams = getQueryParams;\nexports.getRedirectToPathFromURL = getRedirectToPathFromURL;\nexports.getURLHash = getURLHash;\nexports.isTest = isTest;\nexports.matchRecipeIdUsingQueryParams = matchRecipeIdUsingQueryParams;\nexports.mergeObjects = mergeObjects;\nexports.normaliseRecipeModuleConfig = normaliseRecipeModuleConfig;\nexports.redirectWithFullPageReload = redirectWithFullPageReload;\nexports.saveInvalidClaimRedirectPathInContext = saveInvalidClaimRedirectPathInContext;\nexports.useOnMountAPICall = useOnMountAPICall;\nexports.useUserContext = useUserContext;\nexports.validateForm = validateForm;\n"]},"metadata":{},"sourceType":"script"}
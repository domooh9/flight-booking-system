{"ast":null,"code":"// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\nconst assert = require('assert');\n\nconst normalize = require('./normalize-unicode.js');\n\nconst stripSlashes = require('./strip-trailing-slashes.js');\n\nconst {\n  join\n} = require('path');\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map(); // fn => {paths:[path,...], dirs:[path, ...]}\n\n  const reservations = new Map(); // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length) {\n        path = join(set[set.length - 1], path);\n      }\n\n      set.push(path || '/');\n      return set;\n    }, []);\n    return dirs;\n  }; // functions currently running\n\n\n  const running = new Set(); // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n\n  const getQueues = fn => {\n    const res = reservations.get(fn);\n    /* istanbul ignore if - unpossible */\n\n    if (!res) {\n      throw new Error('function does not have any path reservations');\n    }\n\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path))\n    };\n  }; // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n\n\n  const check = fn => {\n    const {\n      paths,\n      dirs\n    } = getQueues(fn);\n    return paths.every(q => q[0] === fn) && dirs.every(q => q[0] instanceof Set && q[0].has(fn));\n  }; // run the function if it's first in line and not already running\n\n\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) {\n      return false;\n    }\n\n    running.add(fn);\n    fn(() => clear(fn));\n    return true;\n  };\n\n  const clear = fn => {\n    if (!running.has(fn)) {\n      return false;\n    }\n\n    const {\n      paths,\n      dirs\n    } = reservations.get(fn);\n    const next = new Set();\n    paths.forEach(path => {\n      const q = queues.get(path);\n      assert.equal(q[0], fn);\n\n      if (q.length === 1) {\n        queues.delete(path);\n      } else {\n        q.shift();\n\n        if (typeof q[0] === 'function') {\n          next.add(q[0]);\n        } else {\n          q[0].forEach(fn => next.add(fn));\n        }\n      }\n    });\n    dirs.forEach(dir => {\n      const q = queues.get(dir);\n      assert(q[0] instanceof Set);\n\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir);\n      } else if (q[0].size === 1) {\n        q.shift(); // must be a function or else the Set would've been reused\n\n        next.add(q[0]);\n      } else {\n        q[0].delete(fn);\n      }\n    });\n    running.delete(fn);\n    next.forEach(fn => run(fn));\n    return true;\n  };\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return normalize(stripSlashes(join(p))).toLowerCase();\n    });\n    const dirs = new Set(paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b)));\n    reservations.set(fn, {\n      dirs,\n      paths\n    });\n    paths.forEach(path => {\n      const q = queues.get(path);\n\n      if (!q) {\n        queues.set(path, [fn]);\n      } else {\n        q.push(fn);\n      }\n    });\n    dirs.forEach(dir => {\n      const q = queues.get(dir);\n\n      if (!q) {\n        queues.set(dir, [new Set([fn])]);\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn);\n      } else {\n        q.push(new Set([fn]));\n      }\n    });\n    return run(fn);\n  };\n\n  return {\n    check,\n    reserve\n  };\n};","map":{"version":3,"sources":["/home/dom/Videos/FlyM/node_modules/tar/lib/path-reservations.js"],"names":["assert","require","normalize","stripSlashes","join","platform","process","env","TESTING_TAR_FAKE_PLATFORM","isWindows","module","exports","queues","Map","reservations","getDirs","path","dirs","split","slice","reduce","set","length","push","running","Set","getQueues","fn","res","get","Error","paths","map","check","every","q","has","run","add","clear","next","forEach","equal","delete","shift","dir","size","reserve","p","toLowerCase","a","b","concat"],"mappings":"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","sourcesContent":["// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = require('assert')\nconst normalize = require('./normalize-unicode.js')\nconst stripSlashes = require('./strip-trailing-slashes.js')\nconst { join } = require('path')\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length) {\n        path = join(set[set.length - 1], path)\n      }\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations')\n    }\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const { paths, dirs } = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) {\n      return false\n    }\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn)) {\n      return false\n    }\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1) {\n        queues.delete(path)\n      } else {\n        q.shift()\n        if (typeof q[0] === 'function') {\n          next.add(q[0])\n        } else {\n          q[0].forEach(fn => next.add(fn))\n        }\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else {\n        q[0].delete(fn)\n      }\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return normalize(stripSlashes(join(p))).toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, { dirs, paths })\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q) {\n        queues.set(path, [fn])\n      } else {\n        q.push(fn)\n      }\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q) {\n        queues.set(dir, [new Set([fn])])\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn)\n      } else {\n        q.push(new Set([fn]))\n      }\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n"]},"metadata":{},"sourceType":"script"}
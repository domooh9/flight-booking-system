{"ast":null,"code":"'use strict';\n\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\n\nconst EE = require('events');\n\nconst Stream = require('stream');\n\nconst stringdecoder = require('string_decoder');\n\nconst SD = stringdecoder.StringDecoder;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode'); // internal event when stream is destroyed\n\nconst DESTROYED = Symbol('destroyed'); // internal event when stream has an error\n\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\n\nconst defer = fn => Promise.resolve().then(fn); // TODO remove when Node v8 support drops\n\n\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\n\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n\n    this.ondrain = () => src[RESUME]();\n\n    dest.on('drain', this.ondrain);\n  }\n\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain);\n  } // istanbul ignore next - only here for the prototype\n\n\n  proxyErrors() {}\n\n  end() {\n    this.unpipe();\n    if (this.opts.end) this.dest.end();\n  }\n\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors);\n    super.unpipe();\n  }\n\n  constructor(src, dest, opts) {\n    super(src, dest, opts);\n\n    this.proxyErrors = er => dest.emit('error', er);\n\n    src.on('error', this.proxyErrors);\n  }\n\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super();\n    this[FLOWING] = false; // whether we're explicitly paused\n\n    this[PAUSED] = false;\n    this[PIPES] = [];\n    this[BUFFER] = [];\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[ASYNC] = options && !!options.async || false;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[EMITTING_END] = false;\n    this[CLOSED] = false;\n    this[EMITTED_ERROR] = null;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n    this[DESTROYED] = false;\n\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', {\n        get: () => this[BUFFER]\n      });\n    }\n\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', {\n        get: () => this[PIPES]\n      });\n    }\n\n    this[SIGNAL] = options && options.signal;\n    this[ABORTED] = false;\n\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]());\n\n      if (this[SIGNAL].aborted) {\n        this[ABORT]();\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n\n  get encoding() {\n    return this[ENCODING];\n  }\n\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this[BUFFER].length) this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk));\n    }\n\n    this[ENCODING] = enc;\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n  }\n\n  get ['async']() {\n    return this[ASYNC];\n  }\n\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a;\n  } // drop everything and get out of the flow completely\n\n\n  [ABORT]() {\n    this[ABORTED] = true;\n    this.emit('abort', this[SIGNAL].reason);\n    this.destroy(this[SIGNAL].reason);\n  }\n\n  get aborted() {\n    return this[ABORTED];\n  }\n\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false;\n    if (this[EOF]) throw new Error('write after end');\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n    const fn = this[ASYNC] ? defer : f => f(); // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set\n        this.objectMode = true;\n    } // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n\n\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    } // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n\n\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    } // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n\n\n    if (typeof chunk === 'string' && // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk); // Note: flushing CAN potentially switch us into not-flowing mode\n\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n    if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) fn(cb);\n    return this.flowing;\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null;\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]();\n      return null;\n    }\n\n    if (this[OBJECTMODE]) n = null;\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')];else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0]);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this[BUFFER][0] = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false; // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  } // don't let the internal resume be overwritten\n\n\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this[BUFFER].length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n\n  resume() {\n    return this[RESUME]();\n  }\n\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n  }\n\n  get destroyed() {\n    return this[DESTROYED];\n  }\n\n  get flowing() {\n    return this[FLOWING];\n  }\n\n  get paused() {\n    return this[PAUSED];\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    this[BUFFER].push(chunk);\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n    return this[BUFFER].shift();\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk);\n    return this.flowing;\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n    opts.proxyErrors = !!opts.proxyErrors; // piping an ended stream ends immediately\n\n    if (ended) {\n      if (opts.end) dest.end();\n    } else {\n      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n      if (this[ASYNC]) defer(() => this[RESUME]());else this[RESUME]();\n    }\n\n    return dest;\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest);\n\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1);\n      p.unpipe();\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn);\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]();else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev);\n      this.removeAllListeners(ev);\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));else fn.call(this, this[EMITTED_ERROR]);\n    }\n    return ret;\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n\n  emit(ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);\n    } else if (ev === 'end') {\n      return this[EMITEND]();\n    } else if (ev === 'close') {\n      this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n      if (!this[EMITTED_END] && !this[DESTROYED]) return;\n      const ret = super.emit('close');\n      this.removeAllListeners('close');\n      return ret;\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data;\n      super.emit(ERROR, data);\n      const ret = !this[SIGNAL] || this.listeners('error').length ? super.emit('error', data) : false;\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume');\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev);\n      this.removeAllListeners(ev);\n      return ret;\n    } // Some other unknown event\n\n    for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      extra[_key - 2] = arguments[_key];\n    }\n\n    const ret = super.emit(ev, data, ...extra);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause();\n    }\n\n    const ret = super.emit('data', data);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return;\n    this[EMITTED_END] = true;\n    this.readable = false;\n    if (this[ASYNC]) defer(() => this[EMITEND2]());else this[EMITEND2]();\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end();\n\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data);\n        }\n\n        super.emit('data', data);\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end();\n    }\n\n    const ret = super.emit('end');\n    this.removeAllListeners('end');\n    return ret;\n  } // const all = await stream.collect()\n\n\n  collect() {\n    const buf = [];\n    if (!this[OBJECTMODE]) buf.dataLength = 0; // set the promise first, in case an error is raised\n    // by triggering the flow here.\n\n    const p = this.promise();\n    this.on('data', c => {\n      buf.push(c);\n      if (!this[OBJECTMODE]) buf.dataLength += c.length;\n    });\n    return p.then(() => buf);\n  } // const data = await stream.concat()\n\n\n  concat() {\n    return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(buf => this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength));\n  } // stream.promise().then(() => done, er => emitted error)\n\n\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('error', er => reject(er));\n      this.on('end', () => resolve());\n    });\n  } // for await (let chunk of stream)\n\n\n  [ASYNCITERATOR]() {\n    let stopped = false;\n\n    const stop = () => {\n      this.pause();\n      stopped = true;\n      return Promise.resolve({\n        done: true\n      });\n    };\n\n    const next = () => {\n      if (stopped) return stop();\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return stop();\n      let resolve = null;\n      let reject = null;\n\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        this.removeListener(DESTROYED, ondestroy);\n        stop();\n        reject(er);\n      };\n\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.removeListener(DESTROYED, ondestroy);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        this.removeListener(DESTROYED, ondestroy);\n        stop();\n        resolve({\n          done: true\n        });\n      };\n\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n\n      [ASYNCITERATOR]() {\n        return this;\n      }\n\n    };\n  } // for (let chunk of stream)\n\n\n  [ITERATOR]() {\n    let stopped = false;\n\n    const stop = () => {\n      this.pause();\n      this.removeListener(ERROR, stop);\n      this.removeListener(DESTROYED, stop);\n      this.removeListener('end', stop);\n      stopped = true;\n      return {\n        done: true\n      };\n    };\n\n    const next = () => {\n      if (stopped) return stop();\n      const value = this.read();\n      return value === null ? stop() : {\n        value\n      };\n    };\n\n    this.once('end', stop);\n    this.once(ERROR, stop);\n    this.once(DESTROYED, stop);\n    return {\n      next,\n      throw: stop,\n      return: stop,\n\n      [ITERATOR]() {\n        return this;\n      }\n\n    };\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n\n    this[DESTROYED] = true; // throw away all buffered data, it's never coming out\n\n    this[BUFFER].length = 0;\n    this[BUFFERLENGTH] = 0;\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n    if (er) this.emit('error', er); // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED);\n    return this;\n  }\n\n  static isStream(s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && ( // readable\n    typeof s.pipe === 'function' || // writable\n    typeof s.write === 'function' && typeof s.end === 'function'));\n  }\n\n}\n\nmodule.exports = Minipass;","map":{"version":3,"sources":["/home/dom/Videos/FlyM/node_modules/tar/node_modules/minipass/index.js"],"names":["proc","process","stdout","stderr","EE","require","Stream","stringdecoder","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","ERROR","EMITDATA","EMITEND","EMITEND2","ASYNC","ABORT","ABORTED","SIGNAL","defer","fn","Promise","resolve","then","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","Pipe","src","dest","opts","ondrain","on","unpipe","removeListener","proxyErrors","end","PipeProxyErrors","er","emit","Minipass","options","objectMode","encoding","async","writable","readable","debugExposeBuffer","Object","defineProperty","get","debugExposePipes","signal","addEventListener","aborted","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","om","a","reason","destroy","_","cb","assign","code","f","from","buffer","byteOffset","flowing","read","n","join","concat","ret","slice","once","resume","pause","destroyed","paused","push","shift","noDrain","pipe","ended","p","find","splice","indexOf","addListener","removeAllListeners","call","emittedEnd","data","listeners","extra","collect","buf","dataLength","promise","c","reject","stopped","stop","done","next","res","value","onerr","ondata","onend","ondestroy","rej","throw","return","close","isStream","s","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nconst EE = require('events')\nconst Stream = require('stream')\nconst stringdecoder = require('string_decoder')\nconst SD = stringdecoder.StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'\nconst ASYNCITERATOR =\n  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')\nconst ITERATOR =\n  (doIter && Symbol.iterator) || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBuffer = b =>\n  b instanceof ArrayBuffer ||\n  (typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = (options && options.objectMode) || false\n    if (this[OBJECTMODE]) this[ENCODING] = null\n    else this[ENCODING] = (options && options.encoding) || null\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null\n    this[ASYNC] = (options && !!options.async) || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n    this[SIGNAL] = options && options.signal\n    this[ABORTED] = false\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]())\n      if (this[SIGNAL].aborted) {\n        this[ABORT]()\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  get encoding() {\n    return this[ENCODING]\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')\n\n    if (\n      this[ENCODING] &&\n      enc !== this[ENCODING] &&\n      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])\n    )\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om\n  }\n\n  get ['async']() {\n    return this[ASYNC]\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL].reason)\n    this.destroy(this[SIGNAL].reason)\n  }\n\n  get aborted() {\n    return this[ABORTED]\n  }\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n      if (this.flowing) this.emit('data', chunk)\n      else this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)\n    ) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this.flowing) this.emit('data', chunk)\n    else this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this.flowing\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]\n      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') (cb = chunk), (chunk = null)\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n    if (chunk) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  resume() {\n    return this[RESUME]()\n  }\n\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else this[BUFFERLENGTH] -= this[BUFFER][0].length\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk)\n    return this.flowing\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe(this, dest, opts)\n          : new PipeProxyErrors(this, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC]) defer(() => this[EMITEND2]())\n    else this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = []\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE]) buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength)\n        )\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      stopped = true\n      return Promise.resolve({ done: true })\n    }\n    const next = () => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      this.removeListener(ERROR, stop)\n      this.removeListener(DESTROYED, stop)\n      this.removeListener('end', stop)\n      stopped = true\n      return { done: true }\n    }\n\n    const next = () => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { value }\n    }\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream(s) {\n    return (\n      !!s &&\n      (s instanceof Minipass ||\n        s instanceof Stream ||\n        (s instanceof EE &&\n          // readable\n          (typeof s.pipe === 'function' ||\n            // writable\n            (typeof s.write === 'function' && typeof s.end === 'function'))))\n    )\n  }\n}\n\nmodule.exports = Minipass\n"]},"metadata":{},"sourceType":"script"}
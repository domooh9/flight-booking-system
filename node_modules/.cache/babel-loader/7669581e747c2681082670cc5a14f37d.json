{"ast":null,"code":"const ip = exports;\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst os = require('os');\n\nip.toBuffer = function (ip, buff, offset) {\n  offset = ~~offset;\n  let result;\n\n  if (this.isV4Format(ip)) {\n    result = buff || Buffer.alloc(offset + 4);\n    ip.split(/\\./g).map(byte => {\n      result[offset++] = parseInt(byte, 10) & 0xff;\n    });\n  } else if (this.isV6Format(ip)) {\n    const sections = ip.split(':', 8);\n    let i;\n\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = this.isV4Format(sections[i]);\n      let v4Buffer;\n\n      if (isv4) {\n        v4Buffer = this.toBuffer(sections[i]);\n        sections[i] = v4Buffer.slice(0, 2).toString('hex');\n      }\n\n      if (v4Buffer && ++i < 8) {\n        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0');\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0');\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n\n      const argv = [i, 1];\n\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0');\n      }\n\n      sections.splice(...argv);\n    }\n\n    result = buff || Buffer.alloc(offset + 16);\n\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16);\n      result[offset++] = word >> 8 & 0xff;\n      result[offset++] = word & 0xff;\n    }\n  }\n\n  if (!result) {\n    throw Error(`Invalid ip address: ${ip}`);\n  }\n\n  return result;\n};\n\nip.toString = function (buff, offset, length) {\n  offset = ~~offset;\n  length = length || buff.length - offset;\n  let result = [];\n\n  if (length === 4) {\n    // IPv4\n    for (let i = 0; i < length; i++) {\n      result.push(buff[offset + i]);\n    }\n\n    result = result.join('.');\n  } else if (length === 16) {\n    // IPv6\n    for (let i = 0; i < length; i += 2) {\n      result.push(buff.readUInt16BE(offset + i).toString(16));\n    }\n\n    result = result.join(':');\n    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');\n    result = result.replace(/:{3,4}/, '::');\n  }\n\n  return result;\n};\n\nconst ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nconst ipv6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n\nip.isV4Format = function (ip) {\n  return ipv4Regex.test(ip);\n};\n\nip.isV6Format = function (ip) {\n  return ipv6Regex.test(ip);\n};\n\nfunction _normalizeFamily(family) {\n  if (family === 4) {\n    return 'ipv4';\n  }\n\n  if (family === 6) {\n    return 'ipv6';\n  }\n\n  return family ? family.toLowerCase() : 'ipv4';\n}\n\nip.fromPrefixLen = function (prefixlen, family) {\n  if (prefixlen > 32) {\n    family = 'ipv6';\n  } else {\n    family = _normalizeFamily(family);\n  }\n\n  let len = 4;\n\n  if (family === 'ipv6') {\n    len = 16;\n  }\n\n  const buff = Buffer.alloc(len);\n\n  for (let i = 0, n = buff.length; i < n; ++i) {\n    let bits = 8;\n\n    if (prefixlen < 8) {\n      bits = prefixlen;\n    }\n\n    prefixlen -= bits;\n    buff[i] = ~(0xff >> bits) & 0xff;\n  }\n\n  return ip.toString(buff);\n};\n\nip.mask = function (addr, mask) {\n  addr = ip.toBuffer(addr);\n  mask = ip.toBuffer(mask);\n  const result = Buffer.alloc(Math.max(addr.length, mask.length)); // Same protocol - do bitwise and\n\n  let i;\n\n  if (addr.length === mask.length) {\n    for (i = 0; i < addr.length; i++) {\n      result[i] = addr[i] & mask[i];\n    }\n  } else if (mask.length === 4) {\n    // IPv6 address and IPv4 mask\n    // (Mask low bits)\n    for (i = 0; i < mask.length; i++) {\n      result[i] = addr[addr.length - 4 + i] & mask[i];\n    }\n  } else {\n    // IPv6 mask and IPv4 addr\n    for (i = 0; i < result.length - 6; i++) {\n      result[i] = 0;\n    } // ::ffff:ipv4\n\n\n    result[10] = 0xff;\n    result[11] = 0xff;\n\n    for (i = 0; i < addr.length; i++) {\n      result[i + 12] = addr[i] & mask[i + 12];\n    }\n\n    i += 12;\n  }\n\n  for (; i < result.length; i++) {\n    result[i] = 0;\n  }\n\n  return ip.toString(result);\n};\n\nip.cidr = function (cidrString) {\n  const cidrParts = cidrString.split('/');\n  const addr = cidrParts[0];\n\n  if (cidrParts.length !== 2) {\n    throw new Error(`invalid CIDR subnet: ${addr}`);\n  }\n\n  const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n  return ip.mask(addr, mask);\n};\n\nip.subnet = function (addr, mask) {\n  const networkAddress = ip.toLong(ip.mask(addr, mask)); // Calculate the mask's length.\n\n  const maskBuffer = ip.toBuffer(mask);\n  let maskLength = 0;\n\n  for (let i = 0; i < maskBuffer.length; i++) {\n    if (maskBuffer[i] === 0xff) {\n      maskLength += 8;\n    } else {\n      let octet = maskBuffer[i] & 0xff;\n\n      while (octet) {\n        octet = octet << 1 & 0xff;\n        maskLength++;\n      }\n    }\n  }\n\n  const numberOfAddresses = 2 ** (32 - maskLength);\n  return {\n    networkAddress: ip.fromLong(networkAddress),\n    firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),\n    lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),\n    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n    subnetMask: mask,\n    subnetMaskLength: maskLength,\n    numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,\n    length: numberOfAddresses,\n\n    contains(other) {\n      return networkAddress === ip.toLong(ip.mask(other, mask));\n    }\n\n  };\n};\n\nip.cidrSubnet = function (cidrString) {\n  const cidrParts = cidrString.split('/');\n  const addr = cidrParts[0];\n\n  if (cidrParts.length !== 2) {\n    throw new Error(`invalid CIDR subnet: ${addr}`);\n  }\n\n  const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n  return ip.subnet(addr, mask);\n};\n\nip.not = function (addr) {\n  const buff = ip.toBuffer(addr);\n\n  for (let i = 0; i < buff.length; i++) {\n    buff[i] = 0xff ^ buff[i];\n  }\n\n  return ip.toString(buff);\n};\n\nip.or = function (a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b); // same protocol\n\n  if (a.length === b.length) {\n    for (let i = 0; i < a.length; ++i) {\n      a[i] |= b[i];\n    }\n\n    return ip.toString(a); // mixed protocols\n  }\n\n  let buff = a;\n  let other = b;\n\n  if (b.length > a.length) {\n    buff = b;\n    other = a;\n  }\n\n  const offset = buff.length - other.length;\n\n  for (let i = offset; i < buff.length; ++i) {\n    buff[i] |= other[i - offset];\n  }\n\n  return ip.toString(buff);\n};\n\nip.isEqual = function (a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b); // Same protocol\n\n  if (a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  } // Swap\n\n\n  if (b.length === 4) {\n    const t = b;\n    b = a;\n    a = t;\n  } // a - IPv4, b - IPv6\n\n\n  for (let i = 0; i < 10; i++) {\n    if (b[i] !== 0) return false;\n  }\n\n  const word = b.readUInt16BE(10);\n  if (word !== 0 && word !== 0xffff) return false;\n\n  for (let i = 0; i < 4; i++) {\n    if (a[i] !== b[i + 12]) return false;\n  }\n\n  return true;\n};\n\nip.isPrivate = function (addr) {\n  return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);\n};\n\nip.isPublic = function (addr) {\n  return !ip.isPrivate(addr);\n};\n\nip.isLoopback = function (addr) {\n  return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);\n};\n\nip.loopback = function (family) {\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  if (family !== 'ipv4' && family !== 'ipv6') {\n    throw new Error('family must be ipv4 or ipv6');\n  }\n\n  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';\n}; //\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\n\n\nip.address = function (name, family) {\n  const interfaces = os.networkInterfaces(); //\n  // Default to `ipv4`\n  //\n\n  family = _normalizeFamily(family); //\n  // If a specific network interface has been named,\n  // return the address.\n  //\n\n  if (name && name !== 'private' && name !== 'public') {\n    const res = interfaces[name].filter(details => {\n      const itemFamily = _normalizeFamily(details.family);\n\n      return itemFamily === family;\n    });\n\n    if (res.length === 0) {\n      return undefined;\n    }\n\n    return res[0].address;\n  }\n\n  const all = Object.keys(interfaces).map(nic => {\n    //\n    // Note: name will only be `public` or `private`\n    // when this is called.\n    //\n    const addresses = interfaces[nic].filter(details => {\n      details.family = _normalizeFamily(details.family);\n\n      if (details.family !== family || ip.isLoopback(details.address)) {\n        return false;\n      }\n\n      if (!name) {\n        return true;\n      }\n\n      return name === 'public' ? ip.isPrivate(details.address) : ip.isPublic(details.address);\n    });\n    return addresses.length ? addresses[0].address : undefined;\n  }).filter(Boolean);\n  return !all.length ? ip.loopback(family) : all[0];\n};\n\nip.toLong = function (ip) {\n  let ipl = 0;\n  ip.split('.').forEach(octet => {\n    ipl <<= 8;\n    ipl += parseInt(octet);\n  });\n  return ipl >>> 0;\n};\n\nip.fromLong = function (ipl) {\n  return `${ipl >>> 24}.${ipl >> 16 & 255}.${ipl >> 8 & 255}.${ipl & 255}`;\n};","map":{"version":3,"sources":["/home/dom/Videos/FlyM/node_modules/ip/lib/ip.js"],"names":["ip","exports","Buffer","require","os","toBuffer","buff","offset","result","isV4Format","alloc","split","map","byte","parseInt","isV6Format","sections","i","length","isv4","v4Buffer","slice","toString","splice","unshift","push","argv","word","Error","join","readUInt16BE","replace","ipv4Regex","ipv6Regex","test","_normalizeFamily","family","toLowerCase","fromPrefixLen","prefixlen","len","n","bits","mask","addr","Math","max","cidr","cidrString","cidrParts","subnet","networkAddress","toLong","maskBuffer","maskLength","octet","numberOfAddresses","fromLong","firstAddress","lastAddress","broadcastAddress","subnetMask","subnetMaskLength","numHosts","contains","other","cidrSubnet","not","or","a","b","isEqual","t","isPrivate","isPublic","isLoopback","loopback","address","name","interfaces","networkInterfaces","res","filter","details","itemFamily","undefined","all","Object","keys","nic","addresses","Boolean","ipl","forEach"],"mappings":"AAAA,MAAMA,EAAE,GAAGC,OAAX;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AAEAH,EAAE,CAACK,QAAH,GAAc,UAAUL,EAAV,EAAcM,IAAd,EAAoBC,MAApB,EAA4B;AACxCA,EAAAA,MAAM,GAAG,CAAC,CAACA,MAAX;AAEA,MAAIC,MAAJ;;AAEA,MAAI,KAAKC,UAAL,CAAgBT,EAAhB,CAAJ,EAAyB;AACvBQ,IAAAA,MAAM,GAAGF,IAAI,IAAIJ,MAAM,CAACQ,KAAP,CAAaH,MAAM,GAAG,CAAtB,CAAjB;AACAP,IAAAA,EAAE,CAACW,KAAH,CAAS,KAAT,EAAgBC,GAAhB,CAAqBC,IAAD,IAAU;AAC5BL,MAAAA,MAAM,CAACD,MAAM,EAAP,CAAN,GAAmBO,QAAQ,CAACD,IAAD,EAAO,EAAP,CAAR,GAAqB,IAAxC;AACD,KAFD;AAGD,GALD,MAKO,IAAI,KAAKE,UAAL,CAAgBf,EAAhB,CAAJ,EAAyB;AAC9B,UAAMgB,QAAQ,GAAGhB,EAAE,CAACW,KAAH,CAAS,GAAT,EAAc,CAAd,CAAjB;AAEA,QAAIM,CAAJ;;AACA,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,QAAQ,CAACE,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,YAAME,IAAI,GAAG,KAAKV,UAAL,CAAgBO,QAAQ,CAACC,CAAD,CAAxB,CAAb;AACA,UAAIG,QAAJ;;AAEA,UAAID,IAAJ,EAAU;AACRC,QAAAA,QAAQ,GAAG,KAAKf,QAAL,CAAcW,QAAQ,CAACC,CAAD,CAAtB,CAAX;AACAD,QAAAA,QAAQ,CAACC,CAAD,CAAR,GAAcG,QAAQ,CAACC,KAAT,CAAe,CAAf,EAAkB,CAAlB,EAAqBC,QAArB,CAA8B,KAA9B,CAAd;AACD;;AAED,UAAIF,QAAQ,IAAI,EAAEH,CAAF,GAAM,CAAtB,EAAyB;AACvBD,QAAAA,QAAQ,CAACO,MAAT,CAAgBN,CAAhB,EAAmB,CAAnB,EAAsBG,QAAQ,CAACC,KAAT,CAAe,CAAf,EAAkB,CAAlB,EAAqBC,QAArB,CAA8B,KAA9B,CAAtB;AACD;AACF;;AAED,QAAIN,QAAQ,CAAC,CAAD,CAAR,KAAgB,EAApB,EAAwB;AACtB,aAAOA,QAAQ,CAACE,MAAT,GAAkB,CAAzB,EAA4BF,QAAQ,CAACQ,OAAT,CAAiB,GAAjB;AAC7B,KAFD,MAEO,IAAIR,QAAQ,CAACA,QAAQ,CAACE,MAAT,GAAkB,CAAnB,CAAR,KAAkC,EAAtC,EAA0C;AAC/C,aAAOF,QAAQ,CAACE,MAAT,GAAkB,CAAzB,EAA4BF,QAAQ,CAACS,IAAT,CAAc,GAAd;AAC7B,KAFM,MAEA,IAAIT,QAAQ,CAACE,MAAT,GAAkB,CAAtB,EAAyB;AAC9B,WAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,QAAQ,CAACE,MAAb,IAAuBF,QAAQ,CAACC,CAAD,CAAR,KAAgB,EAAnD,EAAuDA,CAAC,EAAxD,CAA2D;;AAC3D,YAAMS,IAAI,GAAG,CAACT,CAAD,EAAI,CAAJ,CAAb;;AACA,WAAKA,CAAC,GAAG,IAAID,QAAQ,CAACE,MAAtB,EAA8BD,CAAC,GAAG,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;AACxCS,QAAAA,IAAI,CAACD,IAAL,CAAU,GAAV;AACD;;AACDT,MAAAA,QAAQ,CAACO,MAAT,CAAgB,GAAGG,IAAnB;AACD;;AAEDlB,IAAAA,MAAM,GAAGF,IAAI,IAAIJ,MAAM,CAACQ,KAAP,CAAaH,MAAM,GAAG,EAAtB,CAAjB;;AACA,SAAKU,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,QAAQ,CAACE,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,YAAMU,IAAI,GAAGb,QAAQ,CAACE,QAAQ,CAACC,CAAD,CAAT,EAAc,EAAd,CAArB;AACAT,MAAAA,MAAM,CAACD,MAAM,EAAP,CAAN,GAAoBoB,IAAI,IAAI,CAAT,GAAc,IAAjC;AACAnB,MAAAA,MAAM,CAACD,MAAM,EAAP,CAAN,GAAmBoB,IAAI,GAAG,IAA1B;AACD;AACF;;AAED,MAAI,CAACnB,MAAL,EAAa;AACX,UAAMoB,KAAK,CAAE,uBAAsB5B,EAAG,EAA3B,CAAX;AACD;;AAED,SAAOQ,MAAP;AACD,CAtDD;;AAwDAR,EAAE,CAACsB,QAAH,GAAc,UAAUhB,IAAV,EAAgBC,MAAhB,EAAwBW,MAAxB,EAAgC;AAC5CX,EAAAA,MAAM,GAAG,CAAC,CAACA,MAAX;AACAW,EAAAA,MAAM,GAAGA,MAAM,IAAKZ,IAAI,CAACY,MAAL,GAAcX,MAAlC;AAEA,MAAIC,MAAM,GAAG,EAAb;;AACA,MAAIU,MAAM,KAAK,CAAf,EAAkB;AAChB;AACA,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,MAApB,EAA4BD,CAAC,EAA7B,EAAiC;AAC/BT,MAAAA,MAAM,CAACiB,IAAP,CAAYnB,IAAI,CAACC,MAAM,GAAGU,CAAV,CAAhB;AACD;;AACDT,IAAAA,MAAM,GAAGA,MAAM,CAACqB,IAAP,CAAY,GAAZ,CAAT;AACD,GAND,MAMO,IAAIX,MAAM,KAAK,EAAf,EAAmB;AACxB;AACA,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,MAApB,EAA4BD,CAAC,IAAI,CAAjC,EAAoC;AAClCT,MAAAA,MAAM,CAACiB,IAAP,CAAYnB,IAAI,CAACwB,YAAL,CAAkBvB,MAAM,GAAGU,CAA3B,EAA8BK,QAA9B,CAAuC,EAAvC,CAAZ;AACD;;AACDd,IAAAA,MAAM,GAAGA,MAAM,CAACqB,IAAP,CAAY,GAAZ,CAAT;AACArB,IAAAA,MAAM,GAAGA,MAAM,CAACuB,OAAP,CAAe,oBAAf,EAAqC,QAArC,CAAT;AACAvB,IAAAA,MAAM,GAAGA,MAAM,CAACuB,OAAP,CAAe,QAAf,EAAyB,IAAzB,CAAT;AACD;;AAED,SAAOvB,MAAP;AACD,CAtBD;;AAwBA,MAAMwB,SAAS,GAAG,2BAAlB;AACA,MAAMC,SAAS,GAAG,wEAAlB;;AAEAjC,EAAE,CAACS,UAAH,GAAgB,UAAUT,EAAV,EAAc;AAC5B,SAAOgC,SAAS,CAACE,IAAV,CAAelC,EAAf,CAAP;AACD,CAFD;;AAIAA,EAAE,CAACe,UAAH,GAAgB,UAAUf,EAAV,EAAc;AAC5B,SAAOiC,SAAS,CAACC,IAAV,CAAelC,EAAf,CAAP;AACD,CAFD;;AAIA,SAASmC,gBAAT,CAA0BC,MAA1B,EAAkC;AAChC,MAAIA,MAAM,KAAK,CAAf,EAAkB;AAChB,WAAO,MAAP;AACD;;AACD,MAAIA,MAAM,KAAK,CAAf,EAAkB;AAChB,WAAO,MAAP;AACD;;AACD,SAAOA,MAAM,GAAGA,MAAM,CAACC,WAAP,EAAH,GAA0B,MAAvC;AACD;;AAEDrC,EAAE,CAACsC,aAAH,GAAmB,UAAUC,SAAV,EAAqBH,MAArB,EAA6B;AAC9C,MAAIG,SAAS,GAAG,EAAhB,EAAoB;AAClBH,IAAAA,MAAM,GAAG,MAAT;AACD,GAFD,MAEO;AACLA,IAAAA,MAAM,GAAGD,gBAAgB,CAACC,MAAD,CAAzB;AACD;;AAED,MAAII,GAAG,GAAG,CAAV;;AACA,MAAIJ,MAAM,KAAK,MAAf,EAAuB;AACrBI,IAAAA,GAAG,GAAG,EAAN;AACD;;AACD,QAAMlC,IAAI,GAAGJ,MAAM,CAACQ,KAAP,CAAa8B,GAAb,CAAb;;AAEA,OAAK,IAAIvB,CAAC,GAAG,CAAR,EAAWwB,CAAC,GAAGnC,IAAI,CAACY,MAAzB,EAAiCD,CAAC,GAAGwB,CAArC,EAAwC,EAAExB,CAA1C,EAA6C;AAC3C,QAAIyB,IAAI,GAAG,CAAX;;AACA,QAAIH,SAAS,GAAG,CAAhB,EAAmB;AACjBG,MAAAA,IAAI,GAAGH,SAAP;AACD;;AACDA,IAAAA,SAAS,IAAIG,IAAb;AAEApC,IAAAA,IAAI,CAACW,CAAD,CAAJ,GAAU,EAAE,QAAQyB,IAAV,IAAkB,IAA5B;AACD;;AAED,SAAO1C,EAAE,CAACsB,QAAH,CAAYhB,IAAZ,CAAP;AACD,CAxBD;;AA0BAN,EAAE,CAAC2C,IAAH,GAAU,UAAUC,IAAV,EAAgBD,IAAhB,EAAsB;AAC9BC,EAAAA,IAAI,GAAG5C,EAAE,CAACK,QAAH,CAAYuC,IAAZ,CAAP;AACAD,EAAAA,IAAI,GAAG3C,EAAE,CAACK,QAAH,CAAYsC,IAAZ,CAAP;AAEA,QAAMnC,MAAM,GAAGN,MAAM,CAACQ,KAAP,CAAamC,IAAI,CAACC,GAAL,CAASF,IAAI,CAAC1B,MAAd,EAAsByB,IAAI,CAACzB,MAA3B,CAAb,CAAf,CAJ8B,CAM9B;;AACA,MAAID,CAAJ;;AACA,MAAI2B,IAAI,CAAC1B,MAAL,KAAgByB,IAAI,CAACzB,MAAzB,EAAiC;AAC/B,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG2B,IAAI,CAAC1B,MAArB,EAA6BD,CAAC,EAA9B,EAAkC;AAChCT,MAAAA,MAAM,CAACS,CAAD,CAAN,GAAY2B,IAAI,CAAC3B,CAAD,CAAJ,GAAU0B,IAAI,CAAC1B,CAAD,CAA1B;AACD;AACF,GAJD,MAIO,IAAI0B,IAAI,CAACzB,MAAL,KAAgB,CAApB,EAAuB;AAC5B;AACA;AACA,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0B,IAAI,CAACzB,MAArB,EAA6BD,CAAC,EAA9B,EAAkC;AAChCT,MAAAA,MAAM,CAACS,CAAD,CAAN,GAAY2B,IAAI,CAACA,IAAI,CAAC1B,MAAL,GAAc,CAAd,GAAkBD,CAAnB,CAAJ,GAA4B0B,IAAI,CAAC1B,CAAD,CAA5C;AACD;AACF,GANM,MAMA;AACL;AACA,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGT,MAAM,CAACU,MAAP,GAAgB,CAAhC,EAAmCD,CAAC,EAApC,EAAwC;AACtCT,MAAAA,MAAM,CAACS,CAAD,CAAN,GAAY,CAAZ;AACD,KAJI,CAML;;;AACAT,IAAAA,MAAM,CAAC,EAAD,CAAN,GAAa,IAAb;AACAA,IAAAA,MAAM,CAAC,EAAD,CAAN,GAAa,IAAb;;AACA,SAAKS,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG2B,IAAI,CAAC1B,MAArB,EAA6BD,CAAC,EAA9B,EAAkC;AAChCT,MAAAA,MAAM,CAACS,CAAC,GAAG,EAAL,CAAN,GAAiB2B,IAAI,CAAC3B,CAAD,CAAJ,GAAU0B,IAAI,CAAC1B,CAAC,GAAG,EAAL,CAA/B;AACD;;AACDA,IAAAA,CAAC,IAAI,EAAL;AACD;;AACD,SAAOA,CAAC,GAAGT,MAAM,CAACU,MAAlB,EAA0BD,CAAC,EAA3B,EAA+B;AAC7BT,IAAAA,MAAM,CAACS,CAAD,CAAN,GAAY,CAAZ;AACD;;AAED,SAAOjB,EAAE,CAACsB,QAAH,CAAYd,MAAZ,CAAP;AACD,CArCD;;AAuCAR,EAAE,CAAC+C,IAAH,GAAU,UAAUC,UAAV,EAAsB;AAC9B,QAAMC,SAAS,GAAGD,UAAU,CAACrC,KAAX,CAAiB,GAAjB,CAAlB;AAEA,QAAMiC,IAAI,GAAGK,SAAS,CAAC,CAAD,CAAtB;;AACA,MAAIA,SAAS,CAAC/B,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAIU,KAAJ,CAAW,wBAAuBgB,IAAK,EAAvC,CAAN;AACD;;AAED,QAAMD,IAAI,GAAG3C,EAAE,CAACsC,aAAH,CAAiBxB,QAAQ,CAACmC,SAAS,CAAC,CAAD,CAAV,EAAe,EAAf,CAAzB,CAAb;AAEA,SAAOjD,EAAE,CAAC2C,IAAH,CAAQC,IAAR,EAAcD,IAAd,CAAP;AACD,CAXD;;AAaA3C,EAAE,CAACkD,MAAH,GAAY,UAAUN,IAAV,EAAgBD,IAAhB,EAAsB;AAChC,QAAMQ,cAAc,GAAGnD,EAAE,CAACoD,MAAH,CAAUpD,EAAE,CAAC2C,IAAH,CAAQC,IAAR,EAAcD,IAAd,CAAV,CAAvB,CADgC,CAGhC;;AACA,QAAMU,UAAU,GAAGrD,EAAE,CAACK,QAAH,CAAYsC,IAAZ,CAAnB;AACA,MAAIW,UAAU,GAAG,CAAjB;;AAEA,OAAK,IAAIrC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,UAAU,CAACnC,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,QAAIoC,UAAU,CAACpC,CAAD,CAAV,KAAkB,IAAtB,EAA4B;AAC1BqC,MAAAA,UAAU,IAAI,CAAd;AACD,KAFD,MAEO;AACL,UAAIC,KAAK,GAAGF,UAAU,CAACpC,CAAD,CAAV,GAAgB,IAA5B;;AACA,aAAOsC,KAAP,EAAc;AACZA,QAAAA,KAAK,GAAIA,KAAK,IAAI,CAAV,GAAe,IAAvB;AACAD,QAAAA,UAAU;AACX;AACF;AACF;;AAED,QAAME,iBAAiB,GAAG,MAAM,KAAKF,UAAX,CAA1B;AAEA,SAAO;AACLH,IAAAA,cAAc,EAAEnD,EAAE,CAACyD,QAAH,CAAYN,cAAZ,CADX;AAELO,IAAAA,YAAY,EAAEF,iBAAiB,IAAI,CAArB,GACVxD,EAAE,CAACyD,QAAH,CAAYN,cAAZ,CADU,GAEVnD,EAAE,CAACyD,QAAH,CAAYN,cAAc,GAAG,CAA7B,CAJC;AAKLQ,IAAAA,WAAW,EAAEH,iBAAiB,IAAI,CAArB,GACTxD,EAAE,CAACyD,QAAH,CAAYN,cAAc,GAAGK,iBAAjB,GAAqC,CAAjD,CADS,GAETxD,EAAE,CAACyD,QAAH,CAAYN,cAAc,GAAGK,iBAAjB,GAAqC,CAAjD,CAPC;AAQLI,IAAAA,gBAAgB,EAAE5D,EAAE,CAACyD,QAAH,CAAYN,cAAc,GAAGK,iBAAjB,GAAqC,CAAjD,CARb;AASLK,IAAAA,UAAU,EAAElB,IATP;AAULmB,IAAAA,gBAAgB,EAAER,UAVb;AAWLS,IAAAA,QAAQ,EAAEP,iBAAiB,IAAI,CAArB,GACNA,iBADM,GACcA,iBAAiB,GAAG,CAZvC;AAaLtC,IAAAA,MAAM,EAAEsC,iBAbH;;AAcLQ,IAAAA,QAAQ,CAACC,KAAD,EAAQ;AACd,aAAOd,cAAc,KAAKnD,EAAE,CAACoD,MAAH,CAAUpD,EAAE,CAAC2C,IAAH,CAAQsB,KAAR,EAAetB,IAAf,CAAV,CAA1B;AACD;;AAhBI,GAAP;AAkBD,CAvCD;;AAyCA3C,EAAE,CAACkE,UAAH,GAAgB,UAAUlB,UAAV,EAAsB;AACpC,QAAMC,SAAS,GAAGD,UAAU,CAACrC,KAAX,CAAiB,GAAjB,CAAlB;AAEA,QAAMiC,IAAI,GAAGK,SAAS,CAAC,CAAD,CAAtB;;AACA,MAAIA,SAAS,CAAC/B,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAIU,KAAJ,CAAW,wBAAuBgB,IAAK,EAAvC,CAAN;AACD;;AAED,QAAMD,IAAI,GAAG3C,EAAE,CAACsC,aAAH,CAAiBxB,QAAQ,CAACmC,SAAS,CAAC,CAAD,CAAV,EAAe,EAAf,CAAzB,CAAb;AAEA,SAAOjD,EAAE,CAACkD,MAAH,CAAUN,IAAV,EAAgBD,IAAhB,CAAP;AACD,CAXD;;AAaA3C,EAAE,CAACmE,GAAH,GAAS,UAAUvB,IAAV,EAAgB;AACvB,QAAMtC,IAAI,GAAGN,EAAE,CAACK,QAAH,CAAYuC,IAAZ,CAAb;;AACA,OAAK,IAAI3B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,IAAI,CAACY,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpCX,IAAAA,IAAI,CAACW,CAAD,CAAJ,GAAU,OAAOX,IAAI,CAACW,CAAD,CAArB;AACD;;AACD,SAAOjB,EAAE,CAACsB,QAAH,CAAYhB,IAAZ,CAAP;AACD,CAND;;AAQAN,EAAE,CAACoE,EAAH,GAAQ,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACtBD,EAAAA,CAAC,GAAGrE,EAAE,CAACK,QAAH,CAAYgE,CAAZ,CAAJ;AACAC,EAAAA,CAAC,GAAGtE,EAAE,CAACK,QAAH,CAAYiE,CAAZ,CAAJ,CAFsB,CAItB;;AACA,MAAID,CAAC,CAACnD,MAAF,KAAaoD,CAAC,CAACpD,MAAnB,EAA2B;AACzB,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoD,CAAC,CAACnD,MAAtB,EAA8B,EAAED,CAAhC,EAAmC;AACjCoD,MAAAA,CAAC,CAACpD,CAAD,CAAD,IAAQqD,CAAC,CAACrD,CAAD,CAAT;AACD;;AACD,WAAOjB,EAAE,CAACsB,QAAH,CAAY+C,CAAZ,CAAP,CAJyB,CAM3B;AACC;;AACD,MAAI/D,IAAI,GAAG+D,CAAX;AACA,MAAIJ,KAAK,GAAGK,CAAZ;;AACA,MAAIA,CAAC,CAACpD,MAAF,GAAWmD,CAAC,CAACnD,MAAjB,EAAyB;AACvBZ,IAAAA,IAAI,GAAGgE,CAAP;AACAL,IAAAA,KAAK,GAAGI,CAAR;AACD;;AAED,QAAM9D,MAAM,GAAGD,IAAI,CAACY,MAAL,GAAc+C,KAAK,CAAC/C,MAAnC;;AACA,OAAK,IAAID,CAAC,GAAGV,MAAb,EAAqBU,CAAC,GAAGX,IAAI,CAACY,MAA9B,EAAsC,EAAED,CAAxC,EAA2C;AACzCX,IAAAA,IAAI,CAACW,CAAD,CAAJ,IAAWgD,KAAK,CAAChD,CAAC,GAAGV,MAAL,CAAhB;AACD;;AAED,SAAOP,EAAE,CAACsB,QAAH,CAAYhB,IAAZ,CAAP;AACD,CA1BD;;AA4BAN,EAAE,CAACuE,OAAH,GAAa,UAAUF,CAAV,EAAaC,CAAb,EAAgB;AAC3BD,EAAAA,CAAC,GAAGrE,EAAE,CAACK,QAAH,CAAYgE,CAAZ,CAAJ;AACAC,EAAAA,CAAC,GAAGtE,EAAE,CAACK,QAAH,CAAYiE,CAAZ,CAAJ,CAF2B,CAI3B;;AACA,MAAID,CAAC,CAACnD,MAAF,KAAaoD,CAAC,CAACpD,MAAnB,EAA2B;AACzB,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoD,CAAC,CAACnD,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;AACjC,UAAIoD,CAAC,CAACpD,CAAD,CAAD,KAASqD,CAAC,CAACrD,CAAD,CAAd,EAAmB,OAAO,KAAP;AACpB;;AACD,WAAO,IAAP;AACD,GAV0B,CAY3B;;;AACA,MAAIqD,CAAC,CAACpD,MAAF,KAAa,CAAjB,EAAoB;AAClB,UAAMsD,CAAC,GAAGF,CAAV;AACAA,IAAAA,CAAC,GAAGD,CAAJ;AACAA,IAAAA,CAAC,GAAGG,CAAJ;AACD,GAjB0B,CAmB3B;;;AACA,OAAK,IAAIvD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3B,QAAIqD,CAAC,CAACrD,CAAD,CAAD,KAAS,CAAb,EAAgB,OAAO,KAAP;AACjB;;AAED,QAAMU,IAAI,GAAG2C,CAAC,CAACxC,YAAF,CAAe,EAAf,CAAb;AACA,MAAIH,IAAI,KAAK,CAAT,IAAcA,IAAI,KAAK,MAA3B,EAAmC,OAAO,KAAP;;AAEnC,OAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,QAAIoD,CAAC,CAACpD,CAAD,CAAD,KAASqD,CAAC,CAACrD,CAAC,GAAG,EAAL,CAAd,EAAwB,OAAO,KAAP;AACzB;;AAED,SAAO,IAAP;AACD,CAhCD;;AAkCAjB,EAAE,CAACyE,SAAH,GAAe,UAAU7B,IAAV,EAAgB;AAC7B,SAAO,4DACJV,IADI,CACCU,IADD,KAEF,oDAAoDV,IAApD,CAAyDU,IAAzD,CAFE,IAGF,mEACAV,IADA,CACKU,IADL,CAHE,IAKF,6DAA6DV,IAA7D,CAAkEU,IAAlE,CALE,IAMF,oDAAoDV,IAApD,CAAyDU,IAAzD,CANE,IAOF,sBAAsBV,IAAtB,CAA2BU,IAA3B,CAPE,IAQF,UAAUV,IAAV,CAAeU,IAAf,CARE,IASF,QAAQV,IAAR,CAAaU,IAAb,CATE,IAUF,OAAOV,IAAP,CAAYU,IAAZ,CAVL;AAWD,CAZD;;AAcA5C,EAAE,CAAC0E,QAAH,GAAc,UAAU9B,IAAV,EAAgB;AAC5B,SAAO,CAAC5C,EAAE,CAACyE,SAAH,CAAa7B,IAAb,CAAR;AACD,CAFD;;AAIA5C,EAAE,CAAC2E,UAAH,GAAgB,UAAU/B,IAAV,EAAgB;AAC9B,SAAO,2DACJV,IADI,CACCU,IADD,KAEF,YAAYV,IAAZ,CAAiBU,IAAjB,CAFE,IAGF,QAAQV,IAAR,CAAaU,IAAb,CAHE,IAIF,OAAOV,IAAP,CAAYU,IAAZ,CAJL;AAKD,CAND;;AAQA5C,EAAE,CAAC4E,QAAH,GAAc,UAAUxC,MAAV,EAAkB;AAC9B;AACA;AACA;AACAA,EAAAA,MAAM,GAAGD,gBAAgB,CAACC,MAAD,CAAzB;;AAEA,MAAIA,MAAM,KAAK,MAAX,IAAqBA,MAAM,KAAK,MAApC,EAA4C;AAC1C,UAAM,IAAIR,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,SAAOQ,MAAM,KAAK,MAAX,GAAoB,WAApB,GAAkC,SAAzC;AACD,CAXD,C,CAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApC,EAAE,CAAC6E,OAAH,GAAa,UAAUC,IAAV,EAAgB1C,MAAhB,EAAwB;AACnC,QAAM2C,UAAU,GAAG3E,EAAE,CAAC4E,iBAAH,EAAnB,CADmC,CAGnC;AACA;AACA;;AACA5C,EAAAA,MAAM,GAAGD,gBAAgB,CAACC,MAAD,CAAzB,CANmC,CAQnC;AACA;AACA;AACA;;AACA,MAAI0C,IAAI,IAAIA,IAAI,KAAK,SAAjB,IAA8BA,IAAI,KAAK,QAA3C,EAAqD;AACnD,UAAMG,GAAG,GAAGF,UAAU,CAACD,IAAD,CAAV,CAAiBI,MAAjB,CAAyBC,OAAD,IAAa;AAC/C,YAAMC,UAAU,GAAGjD,gBAAgB,CAACgD,OAAO,CAAC/C,MAAT,CAAnC;;AACA,aAAOgD,UAAU,KAAKhD,MAAtB;AACD,KAHW,CAAZ;;AAIA,QAAI6C,GAAG,CAAC/D,MAAJ,KAAe,CAAnB,EAAsB;AACpB,aAAOmE,SAAP;AACD;;AACD,WAAOJ,GAAG,CAAC,CAAD,CAAH,CAAOJ,OAAd;AACD;;AAED,QAAMS,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYT,UAAZ,EAAwBnE,GAAxB,CAA6B6E,GAAD,IAAS;AAC/C;AACA;AACA;AACA;AACA,UAAMC,SAAS,GAAGX,UAAU,CAACU,GAAD,CAAV,CAAgBP,MAAhB,CAAwBC,OAAD,IAAa;AACpDA,MAAAA,OAAO,CAAC/C,MAAR,GAAiBD,gBAAgB,CAACgD,OAAO,CAAC/C,MAAT,CAAjC;;AACA,UAAI+C,OAAO,CAAC/C,MAAR,KAAmBA,MAAnB,IAA6BpC,EAAE,CAAC2E,UAAH,CAAcQ,OAAO,CAACN,OAAtB,CAAjC,EAAiE;AAC/D,eAAO,KAAP;AACD;;AAAC,UAAI,CAACC,IAAL,EAAW;AACX,eAAO,IAAP;AACD;;AAED,aAAOA,IAAI,KAAK,QAAT,GAAoB9E,EAAE,CAACyE,SAAH,CAAaU,OAAO,CAACN,OAArB,CAApB,GACH7E,EAAE,CAAC0E,QAAH,CAAYS,OAAO,CAACN,OAApB,CADJ;AAED,KAViB,CAAlB;AAYA,WAAOa,SAAS,CAACxE,MAAV,GAAmBwE,SAAS,CAAC,CAAD,CAAT,CAAab,OAAhC,GAA0CQ,SAAjD;AACD,GAlBW,EAkBTH,MAlBS,CAkBFS,OAlBE,CAAZ;AAoBA,SAAO,CAACL,GAAG,CAACpE,MAAL,GAAclB,EAAE,CAAC4E,QAAH,CAAYxC,MAAZ,CAAd,GAAoCkD,GAAG,CAAC,CAAD,CAA9C;AACD,CA5CD;;AA8CAtF,EAAE,CAACoD,MAAH,GAAY,UAAUpD,EAAV,EAAc;AACxB,MAAI4F,GAAG,GAAG,CAAV;AACA5F,EAAAA,EAAE,CAACW,KAAH,CAAS,GAAT,EAAckF,OAAd,CAAuBtC,KAAD,IAAW;AAC/BqC,IAAAA,GAAG,KAAK,CAAR;AACAA,IAAAA,GAAG,IAAI9E,QAAQ,CAACyC,KAAD,CAAf;AACD,GAHD;AAIA,SAAQqC,GAAG,KAAK,CAAhB;AACD,CAPD;;AASA5F,EAAE,CAACyD,QAAH,GAAc,UAAUmC,GAAV,EAAe;AAC3B,SAAS,GAAEA,GAAG,KAAK,EAAG,IACpBA,GAAG,IAAI,EAAP,GAAY,GAAI,IAChBA,GAAG,IAAI,CAAP,GAAW,GAAI,IACfA,GAAG,GAAG,GAAI,EAHZ;AAID,CALD","sourcesContent":["const ip = exports;\nconst { Buffer } = require('buffer');\nconst os = require('os');\n\nip.toBuffer = function (ip, buff, offset) {\n  offset = ~~offset;\n\n  let result;\n\n  if (this.isV4Format(ip)) {\n    result = buff || Buffer.alloc(offset + 4);\n    ip.split(/\\./g).map((byte) => {\n      result[offset++] = parseInt(byte, 10) & 0xff;\n    });\n  } else if (this.isV6Format(ip)) {\n    const sections = ip.split(':', 8);\n\n    let i;\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = this.isV4Format(sections[i]);\n      let v4Buffer;\n\n      if (isv4) {\n        v4Buffer = this.toBuffer(sections[i]);\n        sections[i] = v4Buffer.slice(0, 2).toString('hex');\n      }\n\n      if (v4Buffer && ++i < 8) {\n        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0');\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0');\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      const argv = [i, 1];\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0');\n      }\n      sections.splice(...argv);\n    }\n\n    result = buff || Buffer.alloc(offset + 16);\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16);\n      result[offset++] = (word >> 8) & 0xff;\n      result[offset++] = word & 0xff;\n    }\n  }\n\n  if (!result) {\n    throw Error(`Invalid ip address: ${ip}`);\n  }\n\n  return result;\n};\n\nip.toString = function (buff, offset, length) {\n  offset = ~~offset;\n  length = length || (buff.length - offset);\n\n  let result = [];\n  if (length === 4) {\n    // IPv4\n    for (let i = 0; i < length; i++) {\n      result.push(buff[offset + i]);\n    }\n    result = result.join('.');\n  } else if (length === 16) {\n    // IPv6\n    for (let i = 0; i < length; i += 2) {\n      result.push(buff.readUInt16BE(offset + i).toString(16));\n    }\n    result = result.join(':');\n    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');\n    result = result.replace(/:{3,4}/, '::');\n  }\n\n  return result;\n};\n\nconst ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nconst ipv6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n\nip.isV4Format = function (ip) {\n  return ipv4Regex.test(ip);\n};\n\nip.isV6Format = function (ip) {\n  return ipv6Regex.test(ip);\n};\n\nfunction _normalizeFamily(family) {\n  if (family === 4) {\n    return 'ipv4';\n  }\n  if (family === 6) {\n    return 'ipv6';\n  }\n  return family ? family.toLowerCase() : 'ipv4';\n}\n\nip.fromPrefixLen = function (prefixlen, family) {\n  if (prefixlen > 32) {\n    family = 'ipv6';\n  } else {\n    family = _normalizeFamily(family);\n  }\n\n  let len = 4;\n  if (family === 'ipv6') {\n    len = 16;\n  }\n  const buff = Buffer.alloc(len);\n\n  for (let i = 0, n = buff.length; i < n; ++i) {\n    let bits = 8;\n    if (prefixlen < 8) {\n      bits = prefixlen;\n    }\n    prefixlen -= bits;\n\n    buff[i] = ~(0xff >> bits) & 0xff;\n  }\n\n  return ip.toString(buff);\n};\n\nip.mask = function (addr, mask) {\n  addr = ip.toBuffer(addr);\n  mask = ip.toBuffer(mask);\n\n  const result = Buffer.alloc(Math.max(addr.length, mask.length));\n\n  // Same protocol - do bitwise and\n  let i;\n  if (addr.length === mask.length) {\n    for (i = 0; i < addr.length; i++) {\n      result[i] = addr[i] & mask[i];\n    }\n  } else if (mask.length === 4) {\n    // IPv6 address and IPv4 mask\n    // (Mask low bits)\n    for (i = 0; i < mask.length; i++) {\n      result[i] = addr[addr.length - 4 + i] & mask[i];\n    }\n  } else {\n    // IPv6 mask and IPv4 addr\n    for (i = 0; i < result.length - 6; i++) {\n      result[i] = 0;\n    }\n\n    // ::ffff:ipv4\n    result[10] = 0xff;\n    result[11] = 0xff;\n    for (i = 0; i < addr.length; i++) {\n      result[i + 12] = addr[i] & mask[i + 12];\n    }\n    i += 12;\n  }\n  for (; i < result.length; i++) {\n    result[i] = 0;\n  }\n\n  return ip.toString(result);\n};\n\nip.cidr = function (cidrString) {\n  const cidrParts = cidrString.split('/');\n\n  const addr = cidrParts[0];\n  if (cidrParts.length !== 2) {\n    throw new Error(`invalid CIDR subnet: ${addr}`);\n  }\n\n  const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.mask(addr, mask);\n};\n\nip.subnet = function (addr, mask) {\n  const networkAddress = ip.toLong(ip.mask(addr, mask));\n\n  // Calculate the mask's length.\n  const maskBuffer = ip.toBuffer(mask);\n  let maskLength = 0;\n\n  for (let i = 0; i < maskBuffer.length; i++) {\n    if (maskBuffer[i] === 0xff) {\n      maskLength += 8;\n    } else {\n      let octet = maskBuffer[i] & 0xff;\n      while (octet) {\n        octet = (octet << 1) & 0xff;\n        maskLength++;\n      }\n    }\n  }\n\n  const numberOfAddresses = 2 ** (32 - maskLength);\n\n  return {\n    networkAddress: ip.fromLong(networkAddress),\n    firstAddress: numberOfAddresses <= 2\n      ? ip.fromLong(networkAddress)\n      : ip.fromLong(networkAddress + 1),\n    lastAddress: numberOfAddresses <= 2\n      ? ip.fromLong(networkAddress + numberOfAddresses - 1)\n      : ip.fromLong(networkAddress + numberOfAddresses - 2),\n    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n    subnetMask: mask,\n    subnetMaskLength: maskLength,\n    numHosts: numberOfAddresses <= 2\n      ? numberOfAddresses : numberOfAddresses - 2,\n    length: numberOfAddresses,\n    contains(other) {\n      return networkAddress === ip.toLong(ip.mask(other, mask));\n    },\n  };\n};\n\nip.cidrSubnet = function (cidrString) {\n  const cidrParts = cidrString.split('/');\n\n  const addr = cidrParts[0];\n  if (cidrParts.length !== 2) {\n    throw new Error(`invalid CIDR subnet: ${addr}`);\n  }\n\n  const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.subnet(addr, mask);\n};\n\nip.not = function (addr) {\n  const buff = ip.toBuffer(addr);\n  for (let i = 0; i < buff.length; i++) {\n    buff[i] = 0xff ^ buff[i];\n  }\n  return ip.toString(buff);\n};\n\nip.or = function (a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // same protocol\n  if (a.length === b.length) {\n    for (let i = 0; i < a.length; ++i) {\n      a[i] |= b[i];\n    }\n    return ip.toString(a);\n\n  // mixed protocols\n  }\n  let buff = a;\n  let other = b;\n  if (b.length > a.length) {\n    buff = b;\n    other = a;\n  }\n\n  const offset = buff.length - other.length;\n  for (let i = offset; i < buff.length; ++i) {\n    buff[i] |= other[i - offset];\n  }\n\n  return ip.toString(buff);\n};\n\nip.isEqual = function (a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // Same protocol\n  if (a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  // Swap\n  if (b.length === 4) {\n    const t = b;\n    b = a;\n    a = t;\n  }\n\n  // a - IPv4, b - IPv6\n  for (let i = 0; i < 10; i++) {\n    if (b[i] !== 0) return false;\n  }\n\n  const word = b.readUInt16BE(10);\n  if (word !== 0 && word !== 0xffff) return false;\n\n  for (let i = 0; i < 4; i++) {\n    if (a[i] !== b[i + 12]) return false;\n  }\n\n  return true;\n};\n\nip.isPrivate = function (addr) {\n  return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n    .test(addr)\n    || /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr)\n    || /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^f[cd][0-9a-f]{2}:/i.test(addr)\n    || /^fe80:/i.test(addr)\n    || /^::1$/.test(addr)\n    || /^::$/.test(addr);\n};\n\nip.isPublic = function (addr) {\n  return !ip.isPrivate(addr);\n};\n\nip.isLoopback = function (addr) {\n  return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/\n    .test(addr)\n    || /^fe80::1$/.test(addr)\n    || /^::1$/.test(addr)\n    || /^::$/.test(addr);\n};\n\nip.loopback = function (family) {\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  if (family !== 'ipv4' && family !== 'ipv6') {\n    throw new Error('family must be ipv4 or ipv6');\n  }\n\n  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';\n};\n\n//\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\nip.address = function (name, family) {\n  const interfaces = os.networkInterfaces();\n\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  //\n  // If a specific network interface has been named,\n  // return the address.\n  //\n  if (name && name !== 'private' && name !== 'public') {\n    const res = interfaces[name].filter((details) => {\n      const itemFamily = _normalizeFamily(details.family);\n      return itemFamily === family;\n    });\n    if (res.length === 0) {\n      return undefined;\n    }\n    return res[0].address;\n  }\n\n  const all = Object.keys(interfaces).map((nic) => {\n    //\n    // Note: name will only be `public` or `private`\n    // when this is called.\n    //\n    const addresses = interfaces[nic].filter((details) => {\n      details.family = _normalizeFamily(details.family);\n      if (details.family !== family || ip.isLoopback(details.address)) {\n        return false;\n      } if (!name) {\n        return true;\n      }\n\n      return name === 'public' ? ip.isPrivate(details.address)\n        : ip.isPublic(details.address);\n    });\n\n    return addresses.length ? addresses[0].address : undefined;\n  }).filter(Boolean);\n\n  return !all.length ? ip.loopback(family) : all[0];\n};\n\nip.toLong = function (ip) {\n  let ipl = 0;\n  ip.split('.').forEach((octet) => {\n    ipl <<= 8;\n    ipl += parseInt(octet);\n  });\n  return (ipl >>> 0);\n};\n\nip.fromLong = function (ipl) {\n  return (`${ipl >>> 24}.${\n    ipl >> 16 & 255}.${\n    ipl >> 8 & 255}.${\n    ipl & 255}`);\n};\n"]},"metadata":{},"sourceType":"script"}
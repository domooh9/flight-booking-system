{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    throw: verb(1),\n    return: verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.responseErrorInterceptor = exports.responseInterceptor = exports.interceptorFunctionRequestFulfilled = void 0;\n\nvar axiosError_1 = require(\"./axiosError\");\n\nvar fetch_1 = require(\"./fetch\");\n\nvar processState_1 = require(\"./processState\");\n\nvar utils_1 = require(\"./utils\");\n\nvar windowHandler_1 = require(\"./utils/windowHandler\");\n\nvar logger_1 = require(\"./logger\");\n\nfunction getUrlFromConfig(config) {\n  var url = config.url === undefined ? \"\" : config.url;\n  var baseURL = config.baseURL;\n\n  if (baseURL !== undefined) {\n    if (url.charAt(0) === \"/\" && baseURL.charAt(baseURL.length - 1) === \"/\") {\n      url = baseURL + url.substr(1);\n    } else if (url.charAt(0) !== \"/\" && baseURL.charAt(baseURL.length - 1) !== \"/\") {\n      url = baseURL + \"/\" + url;\n    } else {\n      url = baseURL + url;\n    }\n  }\n\n  return url;\n}\n\nfunction interceptorFunctionRequestFulfilled(config) {\n  return __awaiter(this, void 0, void 0, function () {\n    var url, doNotDoInterception, preRequestLSS, configWithAntiCsrf, antiCsrfToken, transferMethod;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: started axios interception\");\n          url = getUrlFromConfig(config);\n          doNotDoInterception = false;\n\n          try {\n            doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain);\n          } catch (err) {\n            if (err.message === \"Please provide a valid domain name\") {\n              (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Trying shouldDoInterceptionBasedOnUrl with location.origin\"); // .origin gives the port as well..\n\n              doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain);\n            } else {\n              throw err;\n            }\n          }\n\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Value of doNotDoInterception: \" + doNotDoInterception);\n\n          if (doNotDoInterception) {\n            (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Returning config unchanged\"); // this check means that if you are using axios via inteceptor, then we only do the refresh steps if you are calling your APIs.\n\n            return [2\n            /*return*/\n            , config];\n          }\n\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Modifying config\");\n          processState_1.ProcessState.getInstance().addState(processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST);\n          return [4\n          /*yield*/\n          , (0, fetch_1.getLocalSessionState)(true)];\n\n        case 1:\n          preRequestLSS = _a.sent();\n          configWithAntiCsrf = config;\n          if (!(preRequestLSS.status === \"EXISTS\")) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n\n        case 2:\n          antiCsrfToken = _a.sent();\n\n          if (antiCsrfToken !== undefined) {\n            (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding anti-csrf token to request\");\n            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n              headers: configWithAntiCsrf === undefined ? {\n                \"anti-csrf\": antiCsrfToken\n              } : __assign(__assign({}, configWithAntiCsrf.headers), {\n                \"anti-csrf\": antiCsrfToken\n              })\n            });\n          }\n\n          _a.label = 3;\n\n        case 3:\n          if (fetch_1.default.config.autoAddCredentials && configWithAntiCsrf.withCredentials === undefined) {\n            (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding credentials include\");\n            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n              withCredentials: true\n            });\n          } // adding rid for anti-csrf protection: Anti-csrf via custom header\n\n\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding rid header: anti-csrf (it may be overriden by the user's provided rid)\");\n          configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n            headers: configWithAntiCsrf === undefined ? {\n              rid: \"anti-csrf\"\n            } : __assign({\n              rid: \"anti-csrf\"\n            }, configWithAntiCsrf.headers)\n          });\n          transferMethod = fetch_1.default.config.tokenTransferMethod;\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding st-auth-mode header: \" + transferMethod);\n          configWithAntiCsrf.headers[\"st-auth-mode\"] = transferMethod;\n          return [4\n          /*yield*/\n          , removeAuthHeaderIfMatchesLocalToken(configWithAntiCsrf)];\n\n        case 4:\n          configWithAntiCsrf = _a.sent();\n          return [4\n          /*yield*/\n          , setAuthorizationHeaderIfRequired(configWithAntiCsrf)];\n\n        case 5:\n          _a.sent();\n\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: returning modified config\");\n          return [2\n          /*return*/\n          , configWithAntiCsrf];\n      }\n    });\n  });\n}\n\nexports.interceptorFunctionRequestFulfilled = interceptorFunctionRequestFulfilled;\n\nfunction responseInterceptor(axiosInstance) {\n  var _this = this;\n\n  return function (response) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var doNotDoInterception, url, preRequestLSS, config, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            doNotDoInterception = false;\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 8, 14]);\n\n            if (!fetch_1.default.initCalled) {\n              throw new Error(\"init function not called\");\n            }\n\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: started\");\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: already intercepted: \" + response.headers[\"x-supertokens-xhr-intercepted\"]);\n            url = getUrlFromConfig(response.config);\n\n            try {\n              doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain) || !!response.headers[\"x-supertokens-xhr-intercepted\"];\n            } catch (err) {\n              if (err.message === \"Please provide a valid domain name\") {\n                (0, logger_1.logDebugMessage)(\"responseInterceptor: Trying shouldDoInterceptionBasedOnUrl with location.origin\"); // .origin gives the port as well..\n\n                doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain) || !!response.headers[\"x-supertokens-xhr-intercepted\"];\n              } else {\n                throw err;\n              }\n            }\n\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Value of doNotDoInterception: \" + doNotDoInterception);\n\n            if (doNotDoInterception) {\n              (0, logger_1.logDebugMessage)(\"responseInterceptor: Returning without interception\"); // this check means that if you are using axios via inteceptor, then we only do the refresh steps if you are calling your APIs.\n\n              return [2\n              /*return*/\n              , response];\n            }\n\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Interception started\");\n            processState_1.ProcessState.getInstance().addState(processState_1.PROCESS_STATE.CALLING_INTERCEPTION_RESPONSE);\n            return [4\n            /*yield*/\n            , (0, fetch_1.getLocalSessionState)(false)];\n\n          case 2:\n            preRequestLSS = _b.sent();\n            return [4\n            /*yield*/\n            , saveTokensFromHeaders(response)];\n\n          case 3:\n            _b.sent();\n\n            (0, fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === \"EXISTS\", response.status, response.headers[\"front-token\"]);\n            if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode)) return [3\n            /*break*/\n            , 4];\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Status code is: \" + response.status);\n            config = response.config;\n            return [2\n            /*return*/\n            , AuthHttpRequest.doRequest(function (config) {\n              // we create an instance since we don't want to intercept this.\n              // const instance = axios.create();\n              // return instance(config);\n              return axiosInstance(config);\n            }, config, url, response, undefined, true)];\n\n          case 4:\n            if (!(response.status === fetch_1.default.config.invalidClaimStatusCode)) return [3\n            /*break*/\n            , 6]; // only fire event if body is defined.\n\n            return [4\n            /*yield*/\n            , (0, fetch_1.onInvalidClaimResponse)(response)];\n\n          case 5:\n            // only fire event if body is defined.\n            _b.sent();\n\n            _b.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            , response];\n\n          case 7:\n            return [3\n            /*break*/\n            , 14];\n\n          case 8:\n            _a = !doNotDoInterception;\n            if (!_a) return [3\n            /*break*/\n            , 10];\n            return [4\n            /*yield*/\n            , (0, fetch_1.getLocalSessionState)(true)];\n\n          case 9:\n            // we do not call doesSessionExist here cause the user might override that\n            // function here and then it may break the logic of our original implementation.\n            _a = !(_b.sent().status === \"EXISTS\");\n            _b.label = 10;\n\n          case 10:\n            if (!_a) return [3\n            /*break*/\n            , 13];\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n            return [4\n            /*yield*/\n            , fetch_1.AntiCsrfToken.removeToken()];\n\n          case 11:\n            _b.sent();\n\n            return [4\n            /*yield*/\n            , fetch_1.FrontToken.removeToken()];\n\n          case 12:\n            _b.sent();\n\n            _b.label = 13;\n\n          case 13:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 14:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n}\n\nexports.responseInterceptor = responseInterceptor;\n\nfunction responseErrorInterceptor(axiosInstance) {\n  var _this = this;\n\n  return function (error) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var config;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"responseErrorInterceptor: called\");\n            (0, logger_1.logDebugMessage)(\"responseErrorInterceptor: already intercepted: \" + (error.response && error.response.headers[\"x-supertokens-xhr-intercepted\"]));\n\n            if (error.response.headers[\"x-supertokens-xhr-intercepted\"]) {\n              throw error;\n            }\n\n            if (!(error.response !== undefined && error.response.status === fetch_1.default.config.sessionExpiredStatusCode)) return [3\n            /*break*/\n            , 1];\n            (0, logger_1.logDebugMessage)(\"responseErrorInterceptor: Status code is: \" + error.response.status);\n            config = error.config;\n            return [2\n            /*return*/\n            , AuthHttpRequest.doRequest(function (config) {\n              // we create an instance since we don't want to intercept this.\n              // const instance = axios.create();\n              // return instance(config);\n              return axiosInstance(config);\n            }, config, getUrlFromConfig(config), undefined, error, true)];\n\n          case 1:\n            if (!(error.response !== undefined && error.response.status === fetch_1.default.config.invalidClaimStatusCode)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , (0, fetch_1.onInvalidClaimResponse)(error.response)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            throw error;\n        }\n      });\n    });\n  };\n}\n\nexports.responseErrorInterceptor = responseErrorInterceptor;\n/**\n * @class AuthHttpRequest\n * @description wrapper for common http methods.\n */\n\nvar AuthHttpRequest =\n/** @class */\nfunction () {\n  function AuthHttpRequest() {}\n\n  var _a;\n\n  _a = AuthHttpRequest;\n  /**\n   * @description sends the actual http request and returns a response if successful/\n   * If not successful due to session expiry reasons, it\n   * attempts to call the refresh token API and if that is successful, calls this API again.\n   * @throws Error\n   */\n\n  AuthHttpRequest.doRequest = function (httpCall, config, url, prevResponse, prevError, viaInterceptor) {\n    if (viaInterceptor === void 0) {\n      viaInterceptor = false;\n    }\n\n    return __awaiter(void 0, void 0, void 0, function () {\n      var doNotDoInterception, returnObj, preRequestLSS, configWithAntiCsrf, antiCsrfToken, transferMethod, localPrevError, localPrevResponse, response, _b, refreshResult, _c, err_1, response, refreshResult, _d, postRequestIdToken;\n\n      return __generator(_a, function (_e) {\n        switch (_e.label) {\n          case 0:\n            if (!fetch_1.default.initCalled) {\n              throw Error(\"init function not called\");\n            }\n\n            (0, logger_1.logDebugMessage)(\"doRequest: called\");\n            doNotDoInterception = false;\n\n            try {\n              doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain) && viaInterceptor;\n            } catch (err) {\n              if (err.message === \"Please provide a valid domain name\") {\n                (0, logger_1.logDebugMessage)(\"doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin\"); // .origin gives the port as well..\n\n                doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain) && viaInterceptor;\n              } else {\n                throw err;\n              }\n            }\n\n            (0, logger_1.logDebugMessage)(\"doRequest: Value of doNotDoInterception: \" + doNotDoInterception);\n            if (!doNotDoInterception) return [3\n            /*break*/\n            , 2];\n            (0, logger_1.logDebugMessage)(\"doRequest: Returning without interception\");\n\n            if (prevError !== undefined) {\n              throw prevError;\n            } else if (prevResponse !== undefined) {\n              return [2\n              /*return*/\n              , prevResponse];\n            }\n\n            return [4\n            /*yield*/\n            , httpCall(config)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _e.sent()];\n\n          case 2:\n            (0, logger_1.logDebugMessage)(\"doRequest: Interception started\");\n            return [4\n            /*yield*/\n            , removeAuthHeaderIfMatchesLocalToken(config)];\n\n          case 3:\n            config = _e.sent();\n            _e.label = 4;\n\n          case 4:\n            _e.trys.push([4,, 40, 45]);\n\n            returnObj = undefined;\n            _e.label = 5;\n\n          case 5:\n            if (!true) return [3\n            /*break*/\n            , 39];\n            return [4\n            /*yield*/\n            , (0, fetch_1.getLocalSessionState)(true)];\n\n          case 6:\n            preRequestLSS = _e.sent();\n            configWithAntiCsrf = config;\n            if (!(preRequestLSS.status === \"EXISTS\")) return [3\n            /*break*/\n            , 8];\n            return [4\n            /*yield*/\n            , fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n\n          case 7:\n            antiCsrfToken = _e.sent();\n\n            if (antiCsrfToken !== undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding anti-csrf token to request\");\n              configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                headers: configWithAntiCsrf === undefined ? {\n                  \"anti-csrf\": antiCsrfToken\n                } : __assign(__assign({}, configWithAntiCsrf.headers), {\n                  \"anti-csrf\": antiCsrfToken\n                })\n              });\n            }\n\n            _e.label = 8;\n\n          case 8:\n            if (fetch_1.default.config.autoAddCredentials && configWithAntiCsrf.withCredentials === undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding credentials include\");\n              configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                withCredentials: true\n              });\n            } // adding rid for anti-csrf protection: Anti-csrf via custom header\n\n\n            (0, logger_1.logDebugMessage)(\"doRequest: Adding rid header: anti-csrf (May get overriden by user's rid)\");\n            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n              headers: configWithAntiCsrf === undefined ? {\n                rid: \"anti-csrf\"\n              } : __assign({\n                rid: \"anti-csrf\"\n              }, configWithAntiCsrf.headers)\n            });\n            transferMethod = fetch_1.default.config.tokenTransferMethod;\n            (0, logger_1.logDebugMessage)(\"doRequest: Adding st-auth-mode header: \" + transferMethod);\n            configWithAntiCsrf.headers[\"st-auth-mode\"] = transferMethod;\n            return [4\n            /*yield*/\n            , setAuthorizationHeaderIfRequired(configWithAntiCsrf)];\n\n          case 9:\n            _e.sent();\n\n            _e.label = 10;\n\n          case 10:\n            _e.trys.push([10, 25,, 38]);\n\n            localPrevError = prevError;\n            localPrevResponse = prevResponse;\n            prevError = undefined;\n            prevResponse = undefined;\n\n            if (localPrevError !== undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Not making call because localPrevError is not undefined\");\n              throw localPrevError;\n            }\n\n            if (localPrevResponse !== undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Not making call because localPrevResponse is not undefined\");\n            } else {\n              (0, logger_1.logDebugMessage)(\"doRequest: Making user's http call\");\n            }\n\n            if (!(localPrevResponse === undefined)) return [3\n            /*break*/\n            , 12];\n            return [4\n            /*yield*/\n            , httpCall(configWithAntiCsrf)];\n\n          case 11:\n            _b = _e.sent();\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            _b = localPrevResponse;\n            _e.label = 13;\n\n          case 13:\n            response = _b;\n            (0, logger_1.logDebugMessage)(\"doRequest: User's http call ended\");\n            return [4\n            /*yield*/\n            , saveTokensFromHeaders(response)];\n\n          case 14:\n            _e.sent();\n\n            (0, fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === \"EXISTS\", response.status, response.headers[\"front-token\"]);\n            if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode)) return [3\n            /*break*/\n            , 21];\n            (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n            return [4\n            /*yield*/\n            , (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];\n\n          case 15:\n            refreshResult = _e.sent();\n            if (!(refreshResult.result !== \"RETRY\")) return [3\n            /*break*/\n            , 20];\n            (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n            if (!refreshResult.error) return [3\n            /*break*/\n            , 17];\n            return [4\n            /*yield*/\n            , (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];\n\n          case 16:\n            _c = _e.sent();\n            return [3\n            /*break*/\n            , 19];\n\n          case 17:\n            return [4\n            /*yield*/\n            , (0, axiosError_1.createAxiosErrorFromAxiosResp)(response)];\n\n          case 18:\n            _c = _e.sent();\n            _e.label = 19;\n\n          case 19:\n            // Returning refreshResult.error as an Axios Error if we attempted a refresh\n            // Returning the response to the original response as an error if we did not attempt refreshing\n            returnObj = _c;\n            return [3\n            /*break*/\n            , 39];\n\n          case 20:\n            (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n            return [3\n            /*break*/\n            , 24];\n\n          case 21:\n            if (!(response.status === fetch_1.default.config.invalidClaimStatusCode)) return [3\n            /*break*/\n            , 23];\n            return [4\n            /*yield*/\n            , (0, fetch_1.onInvalidClaimResponse)(response)];\n\n          case 22:\n            _e.sent();\n\n            _e.label = 23;\n\n          case 23:\n            return [2\n            /*return*/\n            , response];\n\n          case 24:\n            return [3\n            /*break*/\n            , 38];\n\n          case 25:\n            err_1 = _e.sent();\n            response = err_1.response;\n            if (!(response !== undefined)) return [3\n            /*break*/\n            , 36];\n            return [4\n            /*yield*/\n            , saveTokensFromHeaders(response)];\n\n          case 26:\n            _e.sent();\n\n            (0, fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === \"EXISTS\", response.status, response.headers[\"front-token\"]);\n            if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode)) return [3\n            /*break*/\n            , 32];\n            (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n            return [4\n            /*yield*/\n            , (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];\n\n          case 27:\n            refreshResult = _e.sent();\n            if (!(refreshResult.result !== \"RETRY\")) return [3\n            /*break*/\n            , 31];\n            (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n            if (!(refreshResult.error !== undefined)) return [3\n            /*break*/\n            , 29];\n            return [4\n            /*yield*/\n            , (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];\n\n          case 28:\n            _d = _e.sent();\n            return [3\n            /*break*/\n            , 30];\n\n          case 29:\n            _d = err_1;\n            _e.label = 30;\n\n          case 30:\n            // Returning refreshResult.error as an Axios Error if we attempted a refresh\n            // Returning the original error if we did not attempt refreshing\n            returnObj = _d;\n            return [3\n            /*break*/\n            , 39];\n\n          case 31:\n            (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n            return [3\n            /*break*/\n            , 35];\n\n          case 32:\n            if (!(response.status === fetch_1.default.config.invalidClaimStatusCode)) return [3\n            /*break*/\n            , 34];\n            return [4\n            /*yield*/\n            , (0, fetch_1.onInvalidClaimResponse)(response)];\n\n          case 33:\n            _e.sent();\n\n            _e.label = 34;\n\n          case 34:\n            throw err_1;\n\n          case 35:\n            return [3\n            /*break*/\n            , 37];\n\n          case 36:\n            throw err_1;\n\n          case 37:\n            return [3\n            /*break*/\n            , 38];\n\n          case 38:\n            return [3\n            /*break*/\n            , 5];\n\n          case 39:\n            // if it comes here, means we called break. which happens only if we have logged out.\n            // which means it's a 401, so we throw\n            throw returnObj;\n\n          case 40:\n            return [4\n            /*yield*/\n            , (0, fetch_1.getLocalSessionState)(false)];\n\n          case 41:\n            postRequestIdToken = _e.sent();\n            if (!(postRequestIdToken.status === \"NOT_EXISTS\")) return [3\n            /*break*/\n            , 44];\n            (0, logger_1.logDebugMessage)(\"doRequest: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n            return [4\n            /*yield*/\n            , fetch_1.AntiCsrfToken.removeToken()];\n\n          case 42:\n            _e.sent();\n\n            return [4\n            /*yield*/\n            , fetch_1.FrontToken.removeToken()];\n\n          case 43:\n            _e.sent();\n\n            _e.label = 44;\n\n          case 44:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 45:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return AuthHttpRequest;\n}();\n\nexports.default = AuthHttpRequest;\n\nfunction setAuthorizationHeaderIfRequired(requestConfig) {\n  return __awaiter(this, void 0, void 0, function () {\n    var accessToken, refreshToken;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          if (requestConfig.headers === undefined) {\n            // This is makes TS happy\n            requestConfig.headers = {};\n          }\n\n          (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: adding existing tokens as header\");\n          return [4\n          /*yield*/\n          , (0, fetch_1.getTokenForHeaderAuth)(\"access\")];\n\n        case 1:\n          accessToken = _b.sent();\n          return [4\n          /*yield*/\n          , (0, fetch_1.getTokenForHeaderAuth)(\"refresh\")];\n\n        case 2:\n          refreshToken = _b.sent(); // We don't add the refresh token because that's only required by the refresh call which is done with fetch\n          // Still, we only add the Authorization header if both are present, because we are planning to add an option to expose the\n          // access token to the frontend while using cookie based auth - so that users can get the access token to use\n\n          if (accessToken !== undefined && refreshToken !== undefined) {\n            if (requestConfig.headers[\"Authorization\"] !== undefined || requestConfig.headers[\"authorization\"] !== undefined) {\n              (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding\");\n            } else {\n              (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: added authorization header\");\n              requestConfig.headers = __assign(__assign({}, requestConfig.headers), {\n                Authorization: \"Bearer \".concat(accessToken)\n              });\n            }\n          } else {\n            (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: token for header based auth not found\");\n          }\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction saveTokensFromHeaders(response) {\n  return __awaiter(this, void 0, void 0, function () {\n    var refreshToken, accessToken, frontToken, antiCsrfToken, tok;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Saving updated tokens from the response\");\n          refreshToken = response.headers[\"st-refresh-token\"];\n          if (!(refreshToken !== undefined)) return [3\n          /*break*/\n          , 2];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new refresh token\");\n          return [4\n          /*yield*/\n          , (0, fetch_1.setToken)(\"refresh\", refreshToken)];\n\n        case 1:\n          _b.sent();\n\n          _b.label = 2;\n\n        case 2:\n          accessToken = response.headers[\"st-access-token\"];\n          if (!(accessToken !== undefined)) return [3\n          /*break*/\n          , 4];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new access token\");\n          return [4\n          /*yield*/\n          , (0, fetch_1.setToken)(\"access\", accessToken)];\n\n        case 3:\n          _b.sent();\n\n          _b.label = 4;\n\n        case 4:\n          frontToken = response.headers[\"front-token\"];\n          if (!(frontToken !== undefined)) return [3\n          /*break*/\n          , 6];\n          (0, logger_1.logDebugMessage)(\"doRequest: Setting sFrontToken: \" + frontToken);\n          return [4\n          /*yield*/\n          , fetch_1.FrontToken.setItem(frontToken)];\n\n        case 5:\n          _b.sent();\n\n          _b.label = 6;\n\n        case 6:\n          antiCsrfToken = response.headers[\"anti-csrf\"];\n          if (!(antiCsrfToken !== undefined)) return [3\n          /*break*/\n          , 9];\n          return [4\n          /*yield*/\n          , (0, fetch_1.getLocalSessionState)(true)];\n\n        case 7:\n          tok = _b.sent();\n          if (!(tok.status === \"EXISTS\")) return [3\n          /*break*/\n          , 9];\n          (0, logger_1.logDebugMessage)(\"doRequest: Setting anti-csrf token\");\n          return [4\n          /*yield*/\n          , fetch_1.AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];\n\n        case 8:\n          _b.sent();\n\n          _b.label = 9;\n\n        case 9:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction removeAuthHeaderIfMatchesLocalToken(config) {\n  return __awaiter(this, void 0, void 0, function () {\n    var accessToken, authHeader, res;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , (0, fetch_1.getTokenForHeaderAuth)(\"access\")];\n\n        case 1:\n          accessToken = _b.sent();\n          authHeader = config.headers.Authorization || config.headers.authorization;\n\n          if (accessToken !== undefined) {\n            if (authHeader === \"Bearer \".concat(accessToken)) {\n              // We are ignoring the Authorization header set by the user in this case, because it would cause issues\n              // If we do not ignore this, then this header would be used even if the request is being retried after a refresh, even though it contains an outdated access token.\n              // This causes an infinite refresh loop.\n              (0, logger_1.logDebugMessage)(\"removeAuthHeaderIfMatchesLocalToken: Removing Authorization from user provided headers because it contains our access token\");\n              res = __assign(__assign({}, config), {\n                headers: __assign({}, config.headers)\n              });\n              delete res.headers.authorization;\n              delete res.headers.Authorization;\n              return [2\n              /*return*/\n              , res];\n            }\n          }\n\n          return [2\n          /*return*/\n          , config];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["/home/dom/FlyM/node_modules/supertokens-website/lib/build/axios.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","_","label","sent","trys","ops","f","y","g","verb","throw","return","Symbol","iterator","v","op","TypeError","pop","push","defineProperty","exports","responseErrorInterceptor","responseInterceptor","interceptorFunctionRequestFulfilled","axiosError_1","require","fetch_1","processState_1","utils_1","windowHandler_1","logger_1","getUrlFromConfig","config","url","undefined","baseURL","charAt","substr","doNotDoInterception","preRequestLSS","configWithAntiCsrf","antiCsrfToken","transferMethod","_a","logDebugMessage","shouldDoInterceptionBasedOnUrl","default","apiDomain","sessionTokenBackendDomain","err","message","getReferenceOrThrow","windowHandler","location","getOrigin","ProcessState","getInstance","addState","PROCESS_STATE","CALLING_INTERCEPTION_REQUEST","getLocalSessionState","status","AntiCsrfToken","getToken","lastAccessTokenUpdate","headers","autoAddCredentials","withCredentials","rid","tokenTransferMethod","removeAuthHeaderIfMatchesLocalToken","setAuthorizationHeaderIfRequired","axiosInstance","_this","response","_b","initCalled","Error","CALLING_INTERCEPTION_RESPONSE","saveTokensFromHeaders","fireSessionUpdateEventsIfNecessary","sessionExpiredStatusCode","AuthHttpRequest","doRequest","invalidClaimStatusCode","onInvalidClaimResponse","removeToken","FrontToken","error","httpCall","prevResponse","prevError","viaInterceptor","returnObj","localPrevError","localPrevResponse","refreshResult","_c","err_1","_d","postRequestIdToken","_e","onUnauthorisedResponse","createAxiosErrorFromFetchResp","createAxiosErrorFromAxiosResp","requestConfig","accessToken","refreshToken","getTokenForHeaderAuth","Authorization","concat","frontToken","tok","setToken","setItem","authHeader","res","authorization"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign =\n    (this && this.__assign) ||\n    function () {\n        __assign =\n            Object.assign ||\n            function (t) {\n                for (var s, i = 1, n = arguments.length; i < n; i++) {\n                    s = arguments[i];\n                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n                }\n                return t;\n            };\n        return __assign.apply(this, arguments);\n    };\nvar __awaiter =\n    (this && this.__awaiter) ||\n    function (thisArg, _arguments, P, generator) {\n        function adopt(value) {\n            return value instanceof P\n                ? value\n                : new P(function (resolve) {\n                      resolve(value);\n                  });\n        }\n        return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) {\n                try {\n                    step(generator.next(value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function rejected(value) {\n                try {\n                    step(generator[\"throw\"](value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n            }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    };\nvar __generator =\n    (this && this.__generator) ||\n    function (thisArg, body) {\n        var _ = {\n                label: 0,\n                sent: function () {\n                    if (t[0] & 1) throw t[1];\n                    return t[1];\n                },\n                trys: [],\n                ops: []\n            },\n            f,\n            y,\n            t,\n            g;\n        return (\n            (g = { next: verb(0), throw: verb(1), return: verb(2) }),\n            typeof Symbol === \"function\" &&\n                (g[Symbol.iterator] = function () {\n                    return this;\n                }),\n            g\n        );\n        function verb(n) {\n            return function (v) {\n                return step([n, v]);\n            };\n        }\n        function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_)\n                try {\n                    if (\n                        ((f = 1),\n                        y &&\n                            (t =\n                                op[0] & 2\n                                    ? y[\"return\"]\n                                    : op[0]\n                                    ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0)\n                                    : y.next) &&\n                            !(t = t.call(y, op[1])).done)\n                    )\n                        return t;\n                    if (((y = 0), t)) op = [op[0] & 2, t.value];\n                    switch (op[0]) {\n                        case 0:\n                        case 1:\n                            t = op;\n                            break;\n                        case 4:\n                            _.label++;\n                            return { value: op[1], done: false };\n                        case 5:\n                            _.label++;\n                            y = op[1];\n                            op = [0];\n                            continue;\n                        case 7:\n                            op = _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                        default:\n                            if (\n                                !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&\n                                (op[0] === 6 || op[0] === 2)\n                            ) {\n                                _ = 0;\n                                continue;\n                            }\n                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                                _.label = op[1];\n                                break;\n                            }\n                            if (op[0] === 6 && _.label < t[1]) {\n                                _.label = t[1];\n                                t = op;\n                                break;\n                            }\n                            if (t && _.label < t[2]) {\n                                _.label = t[2];\n                                _.ops.push(op);\n                                break;\n                            }\n                            if (t[2]) _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                    }\n                    op = body.call(thisArg, _);\n                } catch (e) {\n                    op = [6, e];\n                    y = 0;\n                } finally {\n                    f = t = 0;\n                }\n            if (op[0] & 5) throw op[1];\n            return { value: op[0] ? op[1] : void 0, done: true };\n        }\n    };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.responseErrorInterceptor = exports.responseInterceptor = exports.interceptorFunctionRequestFulfilled = void 0;\nvar axiosError_1 = require(\"./axiosError\");\nvar fetch_1 = require(\"./fetch\");\nvar processState_1 = require(\"./processState\");\nvar utils_1 = require(\"./utils\");\nvar windowHandler_1 = require(\"./utils/windowHandler\");\nvar logger_1 = require(\"./logger\");\nfunction getUrlFromConfig(config) {\n    var url = config.url === undefined ? \"\" : config.url;\n    var baseURL = config.baseURL;\n    if (baseURL !== undefined) {\n        if (url.charAt(0) === \"/\" && baseURL.charAt(baseURL.length - 1) === \"/\") {\n            url = baseURL + url.substr(1);\n        } else if (url.charAt(0) !== \"/\" && baseURL.charAt(baseURL.length - 1) !== \"/\") {\n            url = baseURL + \"/\" + url;\n        } else {\n            url = baseURL + url;\n        }\n    }\n    return url;\n}\nfunction interceptorFunctionRequestFulfilled(config) {\n    return __awaiter(this, void 0, void 0, function () {\n        var url, doNotDoInterception, preRequestLSS, configWithAntiCsrf, antiCsrfToken, transferMethod;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: started axios interception\");\n                    url = getUrlFromConfig(config);\n                    doNotDoInterception = false;\n                    try {\n                        doNotDoInterception =\n                            typeof url === \"string\" &&\n                            !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                url,\n                                fetch_1.default.config.apiDomain,\n                                fetch_1.default.config.sessionTokenBackendDomain\n                            );\n                    } catch (err) {\n                        if (err.message === \"Please provide a valid domain name\") {\n                            (0, logger_1.logDebugMessage)(\n                                \"interceptorFunctionRequestFulfilled: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                            );\n                            // .origin gives the port as well..\n                            doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),\n                                fetch_1.default.config.apiDomain,\n                                fetch_1.default.config.sessionTokenBackendDomain\n                            );\n                        } else {\n                            throw err;\n                        }\n                    }\n                    (0,\n                    logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Value of doNotDoInterception: \" + doNotDoInterception);\n                    if (doNotDoInterception) {\n                        (0, logger_1.logDebugMessage)(\n                            \"interceptorFunctionRequestFulfilled: Returning config unchanged\"\n                        );\n                        // this check means that if you are using axios via inteceptor, then we only do the refresh steps if you are calling your APIs.\n                        return [2 /*return*/, config];\n                    }\n                    (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Modifying config\");\n                    processState_1.ProcessState.getInstance().addState(\n                        processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST\n                    );\n                    return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(true)];\n                case 1:\n                    preRequestLSS = _a.sent();\n                    configWithAntiCsrf = config;\n                    if (!(preRequestLSS.status === \"EXISTS\")) return [3 /*break*/, 3];\n                    return [4 /*yield*/, fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n                case 2:\n                    antiCsrfToken = _a.sent();\n                    if (antiCsrfToken !== undefined) {\n                        (0, logger_1.logDebugMessage)(\n                            \"interceptorFunctionRequestFulfilled: Adding anti-csrf token to request\"\n                        );\n                        configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                            headers:\n                                configWithAntiCsrf === undefined\n                                    ? {\n                                          \"anti-csrf\": antiCsrfToken\n                                      }\n                                    : __assign(__assign({}, configWithAntiCsrf.headers), { \"anti-csrf\": antiCsrfToken })\n                        });\n                    }\n                    _a.label = 3;\n                case 3:\n                    if (fetch_1.default.config.autoAddCredentials && configWithAntiCsrf.withCredentials === undefined) {\n                        (0, logger_1.logDebugMessage)(\n                            \"interceptorFunctionRequestFulfilled: Adding credentials include\"\n                        );\n                        configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), { withCredentials: true });\n                    }\n                    // adding rid for anti-csrf protection: Anti-csrf via custom header\n                    (0,\n                    logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding rid header: anti-csrf (it may be overriden by the user's provided rid)\");\n                    configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                        headers:\n                            configWithAntiCsrf === undefined\n                                ? {\n                                      rid: \"anti-csrf\"\n                                  }\n                                : __assign({ rid: \"anti-csrf\" }, configWithAntiCsrf.headers)\n                    });\n                    transferMethod = fetch_1.default.config.tokenTransferMethod;\n                    (0,\n                    logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding st-auth-mode header: \" + transferMethod);\n                    configWithAntiCsrf.headers[\"st-auth-mode\"] = transferMethod;\n                    return [4 /*yield*/, removeAuthHeaderIfMatchesLocalToken(configWithAntiCsrf)];\n                case 4:\n                    configWithAntiCsrf = _a.sent();\n                    return [4 /*yield*/, setAuthorizationHeaderIfRequired(configWithAntiCsrf)];\n                case 5:\n                    _a.sent();\n                    (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: returning modified config\");\n                    return [2 /*return*/, configWithAntiCsrf];\n            }\n        });\n    });\n}\nexports.interceptorFunctionRequestFulfilled = interceptorFunctionRequestFulfilled;\nfunction responseInterceptor(axiosInstance) {\n    var _this = this;\n    return function (response) {\n        return __awaiter(_this, void 0, void 0, function () {\n            var doNotDoInterception, url, preRequestLSS, config, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        doNotDoInterception = false;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, , 8, 14]);\n                        if (!fetch_1.default.initCalled) {\n                            throw new Error(\"init function not called\");\n                        }\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: started\");\n                        (0,\n                        logger_1.logDebugMessage)(\"responseInterceptor: already intercepted: \" + response.headers[\"x-supertokens-xhr-intercepted\"]);\n                        url = getUrlFromConfig(response.config);\n                        try {\n                            doNotDoInterception =\n                                (typeof url === \"string\" &&\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        url,\n                                        fetch_1.default.config.apiDomain,\n                                        fetch_1.default.config.sessionTokenBackendDomain\n                                    )) ||\n                                !!response.headers[\"x-supertokens-xhr-intercepted\"];\n                        } catch (err) {\n                            if (err.message === \"Please provide a valid domain name\") {\n                                (0, logger_1.logDebugMessage)(\n                                    \"responseInterceptor: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                                );\n                                // .origin gives the port as well..\n                                doNotDoInterception =\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        windowHandler_1.default\n                                            .getReferenceOrThrow()\n                                            .windowHandler.location.getOrigin(),\n                                        fetch_1.default.config.apiDomain,\n                                        fetch_1.default.config.sessionTokenBackendDomain\n                                    ) || !!response.headers[\"x-supertokens-xhr-intercepted\"];\n                            } else {\n                                throw err;\n                            }\n                        }\n                        (0,\n                        logger_1.logDebugMessage)(\"responseInterceptor: Value of doNotDoInterception: \" + doNotDoInterception);\n                        if (doNotDoInterception) {\n                            (0, logger_1.logDebugMessage)(\"responseInterceptor: Returning without interception\");\n                            // this check means that if you are using axios via inteceptor, then we only do the refresh steps if you are calling your APIs.\n                            return [2 /*return*/, response];\n                        }\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: Interception started\");\n                        processState_1.ProcessState.getInstance().addState(\n                            processState_1.PROCESS_STATE.CALLING_INTERCEPTION_RESPONSE\n                        );\n                        return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(false)];\n                    case 2:\n                        preRequestLSS = _b.sent();\n                        return [4 /*yield*/, saveTokensFromHeaders(response)];\n                    case 3:\n                        _b.sent();\n                        (0,\n                        fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === \"EXISTS\", response.status, response.headers[\"front-token\"]);\n                        if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))\n                            return [3 /*break*/, 4];\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: Status code is: \" + response.status);\n                        config = response.config;\n                        return [\n                            2 /*return*/,\n                            AuthHttpRequest.doRequest(\n                                function (config) {\n                                    // we create an instance since we don't want to intercept this.\n                                    // const instance = axios.create();\n                                    // return instance(config);\n                                    return axiosInstance(config);\n                                },\n                                config,\n                                url,\n                                response,\n                                undefined,\n                                true\n                            )\n                        ];\n                    case 4:\n                        if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))\n                            return [3 /*break*/, 6];\n                        // only fire event if body is defined.\n                        return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n                    case 5:\n                        // only fire event if body is defined.\n                        _b.sent();\n                        _b.label = 6;\n                    case 6:\n                        return [2 /*return*/, response];\n                    case 7:\n                        return [3 /*break*/, 14];\n                    case 8:\n                        _a = !doNotDoInterception;\n                        if (!_a) return [3 /*break*/, 10];\n                        return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(true)];\n                    case 9:\n                        // we do not call doesSessionExist here cause the user might override that\n                        // function here and then it may break the logic of our original implementation.\n                        _a = !(_b.sent().status === \"EXISTS\");\n                        _b.label = 10;\n                    case 10:\n                        if (!_a) return [3 /*break*/, 13];\n                        (0,\n                        logger_1.logDebugMessage)(\"responseInterceptor: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n                        return [4 /*yield*/, fetch_1.AntiCsrfToken.removeToken()];\n                    case 11:\n                        _b.sent();\n                        return [4 /*yield*/, fetch_1.FrontToken.removeToken()];\n                    case 12:\n                        _b.sent();\n                        _b.label = 13;\n                    case 13:\n                        return [7 /*endfinally*/];\n                    case 14:\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n}\nexports.responseInterceptor = responseInterceptor;\nfunction responseErrorInterceptor(axiosInstance) {\n    var _this = this;\n    return function (error) {\n        return __awaiter(_this, void 0, void 0, function () {\n            var config;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"responseErrorInterceptor: called\");\n                        (0,\n                        logger_1.logDebugMessage)(\"responseErrorInterceptor: already intercepted: \" + (error.response && error.response.headers[\"x-supertokens-xhr-intercepted\"]));\n                        if (error.response.headers[\"x-supertokens-xhr-intercepted\"]) {\n                            throw error;\n                        }\n                        if (\n                            !(\n                                error.response !== undefined &&\n                                error.response.status === fetch_1.default.config.sessionExpiredStatusCode\n                            )\n                        )\n                            return [3 /*break*/, 1];\n                        (0,\n                        logger_1.logDebugMessage)(\"responseErrorInterceptor: Status code is: \" + error.response.status);\n                        config = error.config;\n                        return [\n                            2 /*return*/,\n                            AuthHttpRequest.doRequest(\n                                function (config) {\n                                    // we create an instance since we don't want to intercept this.\n                                    // const instance = axios.create();\n                                    // return instance(config);\n                                    return axiosInstance(config);\n                                },\n                                config,\n                                getUrlFromConfig(config),\n                                undefined,\n                                error,\n                                true\n                            )\n                        ];\n                    case 1:\n                        if (\n                            !(\n                                error.response !== undefined &&\n                                error.response.status === fetch_1.default.config.invalidClaimStatusCode\n                            )\n                        )\n                            return [3 /*break*/, 3];\n                        return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(error.response)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        throw error;\n                }\n            });\n        });\n    };\n}\nexports.responseErrorInterceptor = responseErrorInterceptor;\n/**\n * @class AuthHttpRequest\n * @description wrapper for common http methods.\n */\nvar AuthHttpRequest = /** @class */ (function () {\n    function AuthHttpRequest() {}\n    var _a;\n    _a = AuthHttpRequest;\n    /**\n     * @description sends the actual http request and returns a response if successful/\n     * If not successful due to session expiry reasons, it\n     * attempts to call the refresh token API and if that is successful, calls this API again.\n     * @throws Error\n     */\n    AuthHttpRequest.doRequest = function (httpCall, config, url, prevResponse, prevError, viaInterceptor) {\n        if (viaInterceptor === void 0) {\n            viaInterceptor = false;\n        }\n        return __awaiter(void 0, void 0, void 0, function () {\n            var doNotDoInterception,\n                returnObj,\n                preRequestLSS,\n                configWithAntiCsrf,\n                antiCsrfToken,\n                transferMethod,\n                localPrevError,\n                localPrevResponse,\n                response,\n                _b,\n                refreshResult,\n                _c,\n                err_1,\n                response,\n                refreshResult,\n                _d,\n                postRequestIdToken;\n            return __generator(_a, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        if (!fetch_1.default.initCalled) {\n                            throw Error(\"init function not called\");\n                        }\n                        (0, logger_1.logDebugMessage)(\"doRequest: called\");\n                        doNotDoInterception = false;\n                        try {\n                            doNotDoInterception =\n                                typeof url === \"string\" &&\n                                !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                    url,\n                                    fetch_1.default.config.apiDomain,\n                                    fetch_1.default.config.sessionTokenBackendDomain\n                                ) &&\n                                viaInterceptor;\n                        } catch (err) {\n                            if (err.message === \"Please provide a valid domain name\") {\n                                (0, logger_1.logDebugMessage)(\n                                    \"doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                                );\n                                // .origin gives the port as well..\n                                doNotDoInterception =\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        windowHandler_1.default\n                                            .getReferenceOrThrow()\n                                            .windowHandler.location.getOrigin(),\n                                        fetch_1.default.config.apiDomain,\n                                        fetch_1.default.config.sessionTokenBackendDomain\n                                    ) && viaInterceptor;\n                            } else {\n                                throw err;\n                            }\n                        }\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: Value of doNotDoInterception: \" + doNotDoInterception);\n                        if (!doNotDoInterception) return [3 /*break*/, 2];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Returning without interception\");\n                        if (prevError !== undefined) {\n                            throw prevError;\n                        } else if (prevResponse !== undefined) {\n                            return [2 /*return*/, prevResponse];\n                        }\n                        return [4 /*yield*/, httpCall(config)];\n                    case 1:\n                        return [2 /*return*/, _e.sent()];\n                    case 2:\n                        (0, logger_1.logDebugMessage)(\"doRequest: Interception started\");\n                        return [4 /*yield*/, removeAuthHeaderIfMatchesLocalToken(config)];\n                    case 3:\n                        config = _e.sent();\n                        _e.label = 4;\n                    case 4:\n                        _e.trys.push([4, , 40, 45]);\n                        returnObj = undefined;\n                        _e.label = 5;\n                    case 5:\n                        if (!true) return [3 /*break*/, 39];\n                        return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(true)];\n                    case 6:\n                        preRequestLSS = _e.sent();\n                        configWithAntiCsrf = config;\n                        if (!(preRequestLSS.status === \"EXISTS\")) return [3 /*break*/, 8];\n                        return [4 /*yield*/, fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n                    case 7:\n                        antiCsrfToken = _e.sent();\n                        if (antiCsrfToken !== undefined) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding anti-csrf token to request\");\n                            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                                headers:\n                                    configWithAntiCsrf === undefined\n                                        ? {\n                                              \"anti-csrf\": antiCsrfToken\n                                          }\n                                        : __assign(__assign({}, configWithAntiCsrf.headers), {\n                                              \"anti-csrf\": antiCsrfToken\n                                          })\n                            });\n                        }\n                        _e.label = 8;\n                    case 8:\n                        if (\n                            fetch_1.default.config.autoAddCredentials &&\n                            configWithAntiCsrf.withCredentials === undefined\n                        ) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding credentials include\");\n                            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), { withCredentials: true });\n                        }\n                        // adding rid for anti-csrf protection: Anti-csrf via custom header\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: Adding rid header: anti-csrf (May get overriden by user's rid)\");\n                        configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                            headers:\n                                configWithAntiCsrf === undefined\n                                    ? {\n                                          rid: \"anti-csrf\"\n                                      }\n                                    : __assign({ rid: \"anti-csrf\" }, configWithAntiCsrf.headers)\n                        });\n                        transferMethod = fetch_1.default.config.tokenTransferMethod;\n                        (0, logger_1.logDebugMessage)(\"doRequest: Adding st-auth-mode header: \" + transferMethod);\n                        configWithAntiCsrf.headers[\"st-auth-mode\"] = transferMethod;\n                        return [4 /*yield*/, setAuthorizationHeaderIfRequired(configWithAntiCsrf)];\n                    case 9:\n                        _e.sent();\n                        _e.label = 10;\n                    case 10:\n                        _e.trys.push([10, 25, , 38]);\n                        localPrevError = prevError;\n                        localPrevResponse = prevResponse;\n                        prevError = undefined;\n                        prevResponse = undefined;\n                        if (localPrevError !== undefined) {\n                            (0, logger_1.logDebugMessage)(\n                                \"doRequest: Not making call because localPrevError is not undefined\"\n                            );\n                            throw localPrevError;\n                        }\n                        if (localPrevResponse !== undefined) {\n                            (0, logger_1.logDebugMessage)(\n                                \"doRequest: Not making call because localPrevResponse is not undefined\"\n                            );\n                        } else {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Making user's http call\");\n                        }\n                        if (!(localPrevResponse === undefined)) return [3 /*break*/, 12];\n                        return [4 /*yield*/, httpCall(configWithAntiCsrf)];\n                    case 11:\n                        _b = _e.sent();\n                        return [3 /*break*/, 13];\n                    case 12:\n                        _b = localPrevResponse;\n                        _e.label = 13;\n                    case 13:\n                        response = _b;\n                        (0, logger_1.logDebugMessage)(\"doRequest: User's http call ended\");\n                        return [4 /*yield*/, saveTokensFromHeaders(response)];\n                    case 14:\n                        _e.sent();\n                        (0,\n                        fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === \"EXISTS\", response.status, response.headers[\"front-token\"]);\n                        if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))\n                            return [3 /*break*/, 21];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n                        return [4 /*yield*/, (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];\n                    case 15:\n                        refreshResult = _e.sent();\n                        if (!(refreshResult.result !== \"RETRY\")) return [3 /*break*/, 20];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n                        if (!refreshResult.error) return [3 /*break*/, 17];\n                        return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];\n                    case 16:\n                        _c = _e.sent();\n                        return [3 /*break*/, 19];\n                    case 17:\n                        return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromAxiosResp)(response)];\n                    case 18:\n                        _c = _e.sent();\n                        _e.label = 19;\n                    case 19:\n                        // Returning refreshResult.error as an Axios Error if we attempted a refresh\n                        // Returning the response to the original response as an error if we did not attempt refreshing\n                        returnObj = _c;\n                        return [3 /*break*/, 39];\n                    case 20:\n                        (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n                        return [3 /*break*/, 24];\n                    case 21:\n                        if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))\n                            return [3 /*break*/, 23];\n                        return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n                    case 22:\n                        _e.sent();\n                        _e.label = 23;\n                    case 23:\n                        return [2 /*return*/, response];\n                    case 24:\n                        return [3 /*break*/, 38];\n                    case 25:\n                        err_1 = _e.sent();\n                        response = err_1.response;\n                        if (!(response !== undefined)) return [3 /*break*/, 36];\n                        return [4 /*yield*/, saveTokensFromHeaders(response)];\n                    case 26:\n                        _e.sent();\n                        (0,\n                        fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === \"EXISTS\", response.status, response.headers[\"front-token\"]);\n                        if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))\n                            return [3 /*break*/, 32];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n                        return [4 /*yield*/, (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];\n                    case 27:\n                        refreshResult = _e.sent();\n                        if (!(refreshResult.result !== \"RETRY\")) return [3 /*break*/, 31];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n                        if (!(refreshResult.error !== undefined)) return [3 /*break*/, 29];\n                        return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];\n                    case 28:\n                        _d = _e.sent();\n                        return [3 /*break*/, 30];\n                    case 29:\n                        _d = err_1;\n                        _e.label = 30;\n                    case 30:\n                        // Returning refreshResult.error as an Axios Error if we attempted a refresh\n                        // Returning the original error if we did not attempt refreshing\n                        returnObj = _d;\n                        return [3 /*break*/, 39];\n                    case 31:\n                        (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n                        return [3 /*break*/, 35];\n                    case 32:\n                        if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))\n                            return [3 /*break*/, 34];\n                        return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n                    case 33:\n                        _e.sent();\n                        _e.label = 34;\n                    case 34:\n                        throw err_1;\n                    case 35:\n                        return [3 /*break*/, 37];\n                    case 36:\n                        throw err_1;\n                    case 37:\n                        return [3 /*break*/, 38];\n                    case 38:\n                        return [3 /*break*/, 5];\n                    case 39:\n                        // if it comes here, means we called break. which happens only if we have logged out.\n                        // which means it's a 401, so we throw\n                        throw returnObj;\n                    case 40:\n                        return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(false)];\n                    case 41:\n                        postRequestIdToken = _e.sent();\n                        if (!(postRequestIdToken.status === \"NOT_EXISTS\")) return [3 /*break*/, 44];\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n                        return [4 /*yield*/, fetch_1.AntiCsrfToken.removeToken()];\n                    case 42:\n                        _e.sent();\n                        return [4 /*yield*/, fetch_1.FrontToken.removeToken()];\n                    case 43:\n                        _e.sent();\n                        _e.label = 44;\n                    case 44:\n                        return [7 /*endfinally*/];\n                    case 45:\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return AuthHttpRequest;\n})();\nexports.default = AuthHttpRequest;\nfunction setAuthorizationHeaderIfRequired(requestConfig) {\n    return __awaiter(this, void 0, void 0, function () {\n        var accessToken, refreshToken;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (requestConfig.headers === undefined) {\n                        // This is makes TS happy\n                        requestConfig.headers = {};\n                    }\n                    (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: adding existing tokens as header\");\n                    return [4 /*yield*/, (0, fetch_1.getTokenForHeaderAuth)(\"access\")];\n                case 1:\n                    accessToken = _b.sent();\n                    return [4 /*yield*/, (0, fetch_1.getTokenForHeaderAuth)(\"refresh\")];\n                case 2:\n                    refreshToken = _b.sent();\n                    // We don't add the refresh token because that's only required by the refresh call which is done with fetch\n                    // Still, we only add the Authorization header if both are present, because we are planning to add an option to expose the\n                    // access token to the frontend while using cookie based auth - so that users can get the access token to use\n                    if (accessToken !== undefined && refreshToken !== undefined) {\n                        if (\n                            requestConfig.headers[\"Authorization\"] !== undefined ||\n                            requestConfig.headers[\"authorization\"] !== undefined\n                        ) {\n                            (0, logger_1.logDebugMessage)(\n                                \"setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding\"\n                            );\n                        } else {\n                            (0, logger_1.logDebugMessage)(\n                                \"setAuthorizationHeaderIfRequired: added authorization header\"\n                            );\n                            requestConfig.headers = __assign(__assign({}, requestConfig.headers), {\n                                Authorization: \"Bearer \".concat(accessToken)\n                            });\n                        }\n                    } else {\n                        (0, logger_1.logDebugMessage)(\n                            \"setAuthorizationHeaderIfRequired: token for header based auth not found\"\n                        );\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction saveTokensFromHeaders(response) {\n    return __awaiter(this, void 0, void 0, function () {\n        var refreshToken, accessToken, frontToken, antiCsrfToken, tok;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Saving updated tokens from the response\");\n                    refreshToken = response.headers[\"st-refresh-token\"];\n                    if (!(refreshToken !== undefined)) return [3 /*break*/, 2];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new refresh token\");\n                    return [4 /*yield*/, (0, fetch_1.setToken)(\"refresh\", refreshToken)];\n                case 1:\n                    _b.sent();\n                    _b.label = 2;\n                case 2:\n                    accessToken = response.headers[\"st-access-token\"];\n                    if (!(accessToken !== undefined)) return [3 /*break*/, 4];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new access token\");\n                    return [4 /*yield*/, (0, fetch_1.setToken)(\"access\", accessToken)];\n                case 3:\n                    _b.sent();\n                    _b.label = 4;\n                case 4:\n                    frontToken = response.headers[\"front-token\"];\n                    if (!(frontToken !== undefined)) return [3 /*break*/, 6];\n                    (0, logger_1.logDebugMessage)(\"doRequest: Setting sFrontToken: \" + frontToken);\n                    return [4 /*yield*/, fetch_1.FrontToken.setItem(frontToken)];\n                case 5:\n                    _b.sent();\n                    _b.label = 6;\n                case 6:\n                    antiCsrfToken = response.headers[\"anti-csrf\"];\n                    if (!(antiCsrfToken !== undefined)) return [3 /*break*/, 9];\n                    return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(true)];\n                case 7:\n                    tok = _b.sent();\n                    if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 9];\n                    (0, logger_1.logDebugMessage)(\"doRequest: Setting anti-csrf token\");\n                    return [4 /*yield*/, fetch_1.AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];\n                case 8:\n                    _b.sent();\n                    _b.label = 9;\n                case 9:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction removeAuthHeaderIfMatchesLocalToken(config) {\n    return __awaiter(this, void 0, void 0, function () {\n        var accessToken, authHeader, res;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    return [4 /*yield*/, (0, fetch_1.getTokenForHeaderAuth)(\"access\")];\n                case 1:\n                    accessToken = _b.sent();\n                    authHeader = config.headers.Authorization || config.headers.authorization;\n                    if (accessToken !== undefined) {\n                        if (authHeader === \"Bearer \".concat(accessToken)) {\n                            // We are ignoring the Authorization header set by the user in this case, because it would cause issues\n                            // If we do not ignore this, then this header would be used even if the request is being retried after a refresh, even though it contains an outdated access token.\n                            // This causes an infinite refresh loop.\n                            (0, logger_1.logDebugMessage)(\n                                \"removeAuthHeaderIfMatchesLocalToken: Removing Authorization from user provided headers because it contains our access token\"\n                            );\n                            res = __assign(__assign({}, config), { headers: __assign({}, config.headers) });\n                            delete res.headers.authorization;\n                            delete res.headers.Authorization;\n                            return [2 /*return*/, res];\n                        }\n                    }\n                    return [2 /*return*/, config];\n            }\n        });\n    });\n}\n"]},"metadata":{},"sourceType":"script"}
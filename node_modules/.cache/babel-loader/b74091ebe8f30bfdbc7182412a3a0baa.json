{"ast":null,"code":"\"use strict\";\n/* Copyright (c) 2020, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    throw: verb(1),\n    return: verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addInterceptorsToXMLHttpRequest = void 0;\n\nvar utils_1 = require(\"./utils\");\n\nvar fetch_1 = require(\"./fetch\");\n\nvar logger_1 = require(\"./logger\");\n\nvar windowHandler_1 = require(\"./utils/windowHandler\");\n\nvar processState_1 = require(\"./processState\");\n\nvar XHR_EVENTS = [\"readystatechange\", \"abort\", \"error\", \"load\", \"loadend\", \"loadstart\", \"progress\", \"timeout\"];\n\nfunction addInterceptorsToXMLHttpRequest() {\n  var firstEventLoopDone = false;\n  setTimeout(function () {\n    return firstEventLoopDone = true;\n  }, 0);\n  var oldXMLHttpRequest = XMLHttpRequest;\n  (0, logger_1.logDebugMessage)(\"addInterceptorsToXMLHttpRequest called\"); // create XMLHttpRequest proxy object\n  // define constructor for my proxy object\n\n  XMLHttpRequest = function () {\n    var actual = new oldXMLHttpRequest();\n    var delayActualCalls = !firstEventLoopDone;\n\n    function delayIfNecessary(cb) {\n      if (delayActualCalls) {\n        setTimeout(function () {\n          cb();\n        }, 0);\n      } else {\n        cb();\n      }\n    }\n\n    var self = this;\n    var listOfFunctionCallsInProxy = [];\n    var requestHeaders = [];\n    var customGetterValues = {};\n    var customResponseHeaders;\n    var eventHandlers = new Map(); // We define these during open\n    // let method: string = \"\";\n\n    var url = \"\";\n    var doNotDoInterception = false;\n    var preRequestLSS = undefined;\n    var body; // we do not provide onerror cause that is fired only on\n    // network level failures and nothing else. If a status code is > 400,\n    // then onload and onreadystatechange are called.\n    // Setting up props (event handlers) that we use in event handlers\n    // These require processing the response (and possibly retrying) before they are forwarded to the user\n\n    self.onload = null;\n    self.onreadystatechange = null;\n    self.onloadend = null; // TODO: add support for other event listener options\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters\n\n    self.addEventListener = function (type, listener, _options) {\n      var handlers = eventHandlers.get(type);\n\n      if (handlers === undefined) {\n        handlers = new Set();\n        eventHandlers.set(type, handlers);\n      }\n\n      handlers.add(listener);\n    };\n\n    self.removeEventListener = function (type, listener) {\n      var handlers = eventHandlers.get(type);\n\n      if (handlers === undefined) {\n        handlers = new Set();\n        eventHandlers.set(type, handlers);\n      }\n\n      handlers.delete(listener);\n    };\n\n    function redispatchEvent(name, ev) {\n      var handlers = eventHandlers.get(name);\n      (0, logger_1.logDebugMessage)(\"XHRInterceptor dispatching \".concat(ev.type, \" to \").concat(handlers ? handlers.size : 0, \" listeners\"));\n\n      if (handlers) {\n        Array.from(handlers).forEach(function (handler) {\n          return handler.apply(self, [ev]);\n        });\n      }\n    }\n\n    function handleRetryPostRefreshing() {\n      return __awaiter(this, void 0, void 0, function () {\n        var refreshResult, retryXhr;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (preRequestLSS === undefined) {\n                throw new Error(\"Should never come here..\");\n              }\n\n              (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleRetryPostRefreshing: preRequestLSS \" + preRequestLSS.status);\n              return [4\n              /*yield*/\n              , (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];\n\n            case 1:\n              refreshResult = _a.sent();\n\n              if (refreshResult.result !== \"RETRY\") {\n                (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleRetryPostRefreshing: Not retrying original request \" + !!refreshResult.error);\n\n                if (refreshResult.error !== undefined) {\n                  // this will cause the responseText of the self to be updated\n                  // to the error message and make the status code the same as\n                  // what the error's status code is.\n                  throw refreshResult.error;\n                } // it can come here if refreshResult.result is SESSION_EXPIRED.\n                // in that case, the status of self is already 401. So we let it\n                // pass through.\n\n\n                return [2\n                /*return*/\n                , true];\n              }\n\n              (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleRetryPostRefreshing: Retrying original request\");\n              retryXhr = new oldXMLHttpRequest();\n              setUpXHR(self, retryXhr, true); // this also calls the send function with the appropriate body\n\n              listOfFunctionCallsInProxy.forEach(function (i) {\n                i(retryXhr);\n              });\n              sendXHR(retryXhr, body);\n              return [2\n              /*return*/\n              , false];\n          }\n        });\n      });\n    }\n\n    function handleResponse(xhr) {\n      return __awaiter(this, void 0, void 0, function () {\n        var status_1, headers, err_1, resp;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (doNotDoInterception) {\n                (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: Returning without interception\");\n                return [2\n                /*return*/\n                , true];\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 14,, 18]);\n\n              _a.label = 2;\n\n            case 2:\n              _a.trys.push([2,, 8, 13]);\n\n              (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: Interception started\");\n              processState_1.ProcessState.getInstance().addState(processState_1.PROCESS_STATE.CALLING_INTERCEPTION_RESPONSE);\n              status_1 = xhr.status;\n              headers = getResponseHeadersFromXHR(xhr);\n              return [4\n              /*yield*/\n              , saveTokensFromHeaders(headers)];\n\n            case 3:\n              _a.sent();\n\n              (0, fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === \"EXISTS\", status_1, headers.get(\"front-token\"));\n              if (!(status_1 === fetch_1.default.config.sessionExpiredStatusCode)) return [3\n              /*break*/\n              , 5];\n              (0, logger_1.logDebugMessage)(\"responseInterceptor: Status code is: \" + status_1);\n              return [4\n              /*yield*/\n              , handleRetryPostRefreshing()];\n\n            case 4:\n              return [2\n              /*return*/\n              , _a.sent()];\n\n            case 5:\n              if (!(status_1 === fetch_1.default.config.invalidClaimStatusCode)) return [3\n              /*break*/\n              , 7];\n              return [4\n              /*yield*/\n              , (0, fetch_1.onInvalidClaimResponse)({\n                data: JSON.parse(xhr.responseText)\n              })];\n\n            case 6:\n              _a.sent();\n\n              _a.label = 7;\n\n            case 7:\n              return [2\n              /*return*/\n              , true];\n\n            case 8:\n              (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: doFinallyCheck running\");\n              return [4\n              /*yield*/\n              , (0, fetch_1.getLocalSessionState)(false)];\n\n            case 9:\n              if (!!(_a.sent().status === \"EXISTS\")) return [3\n              /*break*/\n              , 12];\n              (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n              return [4\n              /*yield*/\n              , fetch_1.AntiCsrfToken.removeToken()];\n\n            case 10:\n              _a.sent();\n\n              return [4\n              /*yield*/\n              , fetch_1.FrontToken.removeToken()];\n\n            case 11:\n              _a.sent();\n\n              _a.label = 12;\n\n            case 12:\n              return [7\n              /*endfinally*/\n              ];\n\n            case 13:\n              return [3\n              /*break*/\n              , 18];\n\n            case 14:\n              err_1 = _a.sent();\n              (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: caught error\");\n              if (!(err_1.status !== undefined)) return [3\n              /*break*/\n              , 16];\n              return [4\n              /*yield*/\n              , getXMLHttpStatusAndResponseTextFromFetchResponse(err_1)];\n\n            case 15:\n              resp = _a.sent();\n              customGetterValues[\"status\"] = resp.status;\n              customGetterValues[\"statusText\"] = resp.statusText;\n              customGetterValues[\"responseType\"] = resp.responseType;\n              customResponseHeaders = resp.headers;\n\n              if (resp.responseType === \"json\") {\n                try {\n                  customGetterValues[\"response\"] = JSON.parse(resp.responseText);\n                } catch (_b) {\n                  customGetterValues[\"response\"] = resp.responseText;\n                }\n              } else {\n                customGetterValues[\"response\"] = resp.responseText;\n              }\n\n              customGetterValues[\"responseText\"] = resp.responseText;\n              return [3\n              /*break*/\n              , 17];\n\n            case 16:\n              // Here we only need to handle fetch related errors, from the refresh endpoint called by the retry\n              // So we should only get network level errors here\n              redispatchEvent(\"error\", new Event(\"error\"));\n              _a.label = 17;\n\n            case 17:\n              return [2\n              /*return*/\n              , true];\n\n            case 18:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n\n    self.open = function (_, u) {\n      (0, logger_1.logDebugMessage)(\"XHRInterceptor.open called\");\n      var args = arguments;\n      listOfFunctionCallsInProxy.push(function (xhr) {\n        xhr.open.apply(xhr, args);\n      }); // method = m;\n\n      url = u;\n\n      try {\n        doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain) || typeof url !== \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url.toString(), fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain);\n      } catch (err) {\n        if (err.message === \"Please provide a valid domain name\") {\n          (0, logger_1.logDebugMessage)(\"XHRInterceptor.open: Trying shouldDoInterceptionBasedOnUrl with location.origin\"); // .origin gives the port as well..\n\n          doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), fetch_1.default.config.apiDomain, fetch_1.default.config.sessionTokenBackendDomain);\n        } else {\n          throw err;\n        }\n      } // here we use the apply syntax cause there are other optional args that\n      // can be passed by the user.\n\n\n      delayIfNecessary(function () {\n        return actual.open.apply(actual, args);\n      });\n    };\n\n    self.send = function (inputBody) {\n      body = inputBody;\n      sendXHR(actual, body);\n    };\n\n    self.setRequestHeader = function (name, value) {\n      var _this = this;\n\n      if (doNotDoInterception) {\n        delayIfNecessary(function () {\n          return actual.setRequestHeader(name, value);\n        });\n        return;\n      } // We need to do this, because if there is another interceptor wrapping this (e.g.: the axios interceptor)\n      // then the anti-csrf token they add would be concatenated to the anti-csrf token added by this interceptor\n\n\n      if (name === \"anti-csrf\") {\n        return;\n      }\n\n      void function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var accessToken;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!(name.toLowerCase() === \"authorization\")) return [3\n                /*break*/\n                , 2];\n                return [4\n                /*yield*/\n                , (0, fetch_1.getTokenForHeaderAuth)(\"access\")];\n\n              case 1:\n                accessToken = _a.sent();\n\n                if (value === \"Bearer \".concat(accessToken)) {\n                  // We are ignoring the Authorization header set by the user in this case, because it would cause issues\n                  // If we do not ignore this, then this header would be used even if the request is being retried after a refresh, even though it contains an outdated access token.\n                  // This causes an infinite refresh loop.\n                  (0, logger_1.logDebugMessage)(\"XHRInterceptor.setRequestHeader: skipping Authorization from user provided headers because it contains our access token\");\n                  return [2\n                  /*return*/\n                  ];\n                }\n\n                _a.label = 2;\n\n              case 2:\n                listOfFunctionCallsInProxy.push(function (xhr) {\n                  xhr.setRequestHeader(name, value);\n                }); // The original version \"combines\" headers according to MDN.\n\n                requestHeaders.push({\n                  name: name,\n                  value: value\n                });\n                delayIfNecessary(function () {\n                  return actual.setRequestHeader(name, value);\n                });\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }().catch(function (err) {\n        // This should basically never happen: it'd mean that getCookie threw an error\n        console.error(\"An error occured during setRequestHeader: \", err);\n      });\n    };\n\n    var copiedProps = undefined;\n    setUpXHR(self, actual, false);\n\n    function setUpXHR(self, xhr, isRetry) {\n      var responseProcessed;\n      var delayedEvents = [\"load\", \"loadend\", \"readystatechange\"];\n      (0, logger_1.logDebugMessage)(\"XHRInterceptor.setUpXHR called\");\n\n      var _loop_1 = function (name_1) {\n        (0, logger_1.logDebugMessage)(\"XHRInterceptor added listener for event \".concat(name_1));\n        xhr.addEventListener(name_1, function (ev) {\n          (0, logger_1.logDebugMessage)(\"XHRInterceptor got event \".concat(name_1));\n\n          if (!delayedEvents.includes(name_1)) {\n            redispatchEvent(name_1, ev);\n          }\n        });\n      };\n\n      for (var _i = 0, XHR_EVENTS_1 = XHR_EVENTS; _i < XHR_EVENTS_1.length; _i++) {\n        var name_1 = XHR_EVENTS_1[_i];\n\n        _loop_1(name_1);\n      }\n\n      xhr.onload = function (ev) {\n        if (responseProcessed === undefined) {\n          responseProcessed = handleResponse(xhr);\n        }\n\n        responseProcessed.then(function (callself) {\n          if (!callself) {\n            return;\n          }\n\n          if (self.onload) {\n            self.onload(ev);\n          }\n\n          redispatchEvent(\"load\", ev);\n        });\n      };\n\n      xhr.onreadystatechange = function (ev) {\n        // In local files, status is 0 upon success in Mozilla Firefox\n        if (xhr.readyState === oldXMLHttpRequest.DONE) {\n          if (responseProcessed === undefined) {\n            responseProcessed = handleResponse(xhr);\n          }\n\n          responseProcessed.then(function (callself) {\n            if (!callself) {\n              return;\n            }\n\n            if (self.onreadystatechange) self.onreadystatechange(ev);\n            redispatchEvent(\"readystatechange\", ev);\n          });\n        } else {\n          if (self.onreadystatechange) {\n            self.onreadystatechange(ev);\n          }\n\n          redispatchEvent(\"readystatechange\", ev);\n        }\n      };\n\n      xhr.onloadend = function (ev) {\n        if (responseProcessed === undefined) {\n          responseProcessed = handleResponse(xhr);\n        }\n\n        responseProcessed.then(function (callself) {\n          if (!callself) {\n            return;\n          }\n\n          if (self.onloadend) {\n            self.onloadend(ev);\n          }\n\n          redispatchEvent(\"loadend\", ev);\n        });\n      };\n\n      self.getAllResponseHeaders = function () {\n        var headersString;\n\n        if (customResponseHeaders) {\n          headersString = \"\";\n          customResponseHeaders.forEach(function (v, k) {\n            return headersString += \"\".concat(k, \": \").concat(v, \"\\r\\n\");\n          });\n        } else {\n          headersString = xhr.getAllResponseHeaders();\n        } // We use this \"fake-header\" to signal other interceptors (axios) that this is done\n        // in case both is applied\n\n\n        return headersString + \"x-supertokens-xhr-intercepted: true\\r\\n\";\n      };\n\n      self.getResponseHeader = function (name) {\n        if (name === \"x-supertokens-xhr-intercepted\") {\n          return \"true\";\n        }\n\n        if (customResponseHeaders) {\n          return customResponseHeaders.get(name);\n        }\n\n        return xhr.getResponseHeader(name);\n      };\n\n      if (copiedProps === undefined) {\n        copiedProps = []; // iterate all properties in actual to proxy them according to their type\n        // For functions, we call actual and return the result\n        // For non-functions, we make getters/setters\n        // If the property already exists on self, then don't proxy it\n\n        for (var prop in xhr) {\n          // skip properties we already have - this will skip both the above defined properties\n          // that we don't want to proxy and skip properties on the prototype belonging to Object\n          if (!(prop in self)) {\n            // We save these props into an array - in case we need to set up a retry XHR\n            copiedProps.push(prop);\n          }\n        }\n      }\n\n      var _loop_2 = function (prop) {\n        if (typeof xhr[prop] === \"function\") {\n          // define our own property that calls the same method on the actual\n          Object.defineProperty(self, prop, {\n            configurable: true,\n            value: function () {\n              var args = arguments;\n\n              if (!isRetry) {\n                listOfFunctionCallsInProxy.push(function (xhr) {\n                  xhr[prop].apply(xhr, args);\n                });\n              }\n\n              return xhr[prop].apply(xhr, args);\n            }\n          });\n        } else {\n          // define our own property that just gets or sets the same prop on the actual\n          Object.defineProperty(self, prop, {\n            configurable: true,\n            get: function () {\n              if (customGetterValues[prop] !== undefined) {\n                return customGetterValues[prop];\n              }\n\n              return xhr[prop];\n            },\n            set: function (val) {\n              if (!isRetry) {\n                listOfFunctionCallsInProxy.push(function (xhr) {\n                  xhr[prop] = val;\n                });\n              }\n\n              (0, logger_1.logDebugMessage)(\"XHRInterceptor.set[\".concat(prop, \"] = \").concat(val));\n              xhr[prop] = val;\n            }\n          });\n        }\n      };\n\n      for (var _a = 0, copiedProps_1 = copiedProps; _a < copiedProps_1.length; _a++) {\n        var prop = copiedProps_1[_a];\n\n        _loop_2(prop);\n      }\n    }\n\n    function sendXHR(xhr, body) {\n      var _this = this;\n\n      (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: called\");\n      (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Value of doNotDoInterception: \" + doNotDoInterception);\n\n      if (doNotDoInterception) {\n        (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Returning without interception\");\n        delayIfNecessary(function () {\n          return xhr.send(body);\n        });\n        return;\n      }\n\n      (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Interception started\");\n      processState_1.ProcessState.getInstance().addState(processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST);\n      delayIfNecessary(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var antiCsrfToken, transferMethod;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , (0, fetch_1.getLocalSessionState)(true)];\n\n              case 1:\n                preRequestLSS = _a.sent();\n                if (!(preRequestLSS.status === \"EXISTS\")) return [3\n                /*break*/\n                , 3];\n                return [4\n                /*yield*/\n                , fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];\n\n              case 2:\n                antiCsrfToken = _a.sent();\n\n                if (antiCsrfToken !== undefined) {\n                  (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Adding anti-csrf token to request\");\n                  xhr.setRequestHeader(\"anti-csrf\", antiCsrfToken);\n                }\n\n                _a.label = 3;\n\n              case 3:\n                if (fetch_1.default.config.autoAddCredentials) {\n                  (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Adding credentials include\");\n                  self.withCredentials = true;\n                }\n\n                if (!requestHeaders.some(function (i) {\n                  return i.name === \"rid\";\n                })) {\n                  (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Adding rid header: anti-csrf\");\n                  xhr.setRequestHeader(\"rid\", \"anti-csrf\");\n                } else {\n                  (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: rid header was already there in request\");\n                }\n\n                transferMethod = fetch_1.default.config.tokenTransferMethod;\n\n                if (!requestHeaders.some(function (i) {\n                  return i.name === \"st-auth-mode\";\n                })) {\n                  (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Adding st-auth-mode header: \" + transferMethod);\n                  xhr.setRequestHeader(\"st-auth-mode\", transferMethod);\n                } else {\n                  (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: st-auth-mode header was already there in request\");\n                }\n\n                return [4\n                /*yield*/\n                , setAuthorizationHeaderIfRequired(xhr, requestHeaders)];\n\n              case 4:\n                _a.sent();\n\n                (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Making user's http call\");\n                return [2\n                /*return*/\n                , xhr.send(body)];\n            }\n          });\n        });\n      });\n    }\n  }; // This can be used by other interceptors (axios) to detect if this interceptor has been added or not\n\n\n  XMLHttpRequest.__interceptedBySuperTokens = true;\n  XMLHttpRequest.__original = oldXMLHttpRequest;\n}\n\nexports.addInterceptorsToXMLHttpRequest = addInterceptorsToXMLHttpRequest;\n\nfunction getXMLHttpStatusAndResponseTextFromFetchResponse(response) {\n  return __awaiter(this, void 0, void 0, function () {\n    var contentType, data, responseType, _a, _b, _c;\n\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          contentType = response.headers.get(\"content-type\");\n          data = \"\";\n          responseType = \"text\";\n          if (!(contentType === null)) return [3\n          /*break*/\n          , 5];\n          _d.label = 1;\n\n        case 1:\n          _d.trys.push([1, 3,, 4]);\n\n          return [4\n          /*yield*/\n          , response.text()];\n\n        case 2:\n          data = _d.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          _a = _d.sent();\n          data = \"\";\n          return [3\n          /*break*/\n          , 4];\n\n        case 4:\n          return [3\n          /*break*/\n          , 9];\n\n        case 5:\n          if (!contentType.includes(\"application/json\")) return [3\n          /*break*/\n          , 7];\n          responseType = \"json\";\n          _c = (_b = JSON).stringify;\n          return [4\n          /*yield*/\n          , response.json()];\n\n        case 6:\n          data = _c.apply(_b, [_d.sent()]);\n          return [3\n          /*break*/\n          , 9];\n\n        case 7:\n          if (!contentType.includes(\"text/\")) return [3\n          /*break*/\n          , 9];\n          return [4\n          /*yield*/\n          , response.text()];\n\n        case 8:\n          data = _d.sent();\n          _d.label = 9;\n\n        case 9:\n          return [2\n          /*return*/\n          , {\n            status: response.status,\n            responseText: data,\n            statusText: response.statusText,\n            responseType: responseType,\n            headers: response.headers\n          }];\n      }\n    });\n  });\n}\n\nfunction setAuthorizationHeaderIfRequired(xhr, requestHeaders) {\n  return __awaiter(this, void 0, void 0, function () {\n    var accessToken, refreshToken;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: adding existing tokens as header\");\n          return [4\n          /*yield*/\n          , (0, fetch_1.getTokenForHeaderAuth)(\"access\")];\n\n        case 1:\n          accessToken = _a.sent();\n          return [4\n          /*yield*/\n          , (0, fetch_1.getTokenForHeaderAuth)(\"refresh\")];\n\n        case 2:\n          refreshToken = _a.sent(); // We don't add the refresh token because that's only required by the refresh call which is done with fetch\n          // Still, we only add the Authorization header if both are present, because we are planning to add an option to expose the\n          // access token to the frontend while using cookie based auth - so that users can get the access token to use\n\n          if (accessToken !== undefined && refreshToken !== undefined) {\n            if (requestHeaders.some(function (_a) {\n              var name = _a.name;\n              return name.toLowerCase() === \"authorization\";\n            })) {\n              (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding\");\n            } else {\n              if (accessToken !== undefined) {\n                (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: added authorization header\");\n                xhr.setRequestHeader(\"Authorization\", \"Bearer \".concat(accessToken));\n              } // We don't add the refresh token because that's only required by the refresh call which is done with fetch\n\n            }\n          } else {\n            (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: token for header based auth not found\");\n          }\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction saveTokensFromHeaders(headers) {\n  return __awaiter(this, void 0, void 0, function () {\n    var refreshToken, accessToken, frontToken, antiCsrfToken, tok;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Saving updated tokens from the response\");\n          refreshToken = headers.get(\"st-refresh-token\");\n          if (!(refreshToken !== null)) return [3\n          /*break*/\n          , 2];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new refresh token\");\n          return [4\n          /*yield*/\n          , (0, fetch_1.setToken)(\"refresh\", refreshToken)];\n\n        case 1:\n          _a.sent();\n\n          _a.label = 2;\n\n        case 2:\n          accessToken = headers.get(\"st-access-token\");\n          if (!(accessToken !== null)) return [3\n          /*break*/\n          , 4];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new access token\");\n          return [4\n          /*yield*/\n          , (0, fetch_1.setToken)(\"access\", accessToken)];\n\n        case 3:\n          _a.sent();\n\n          _a.label = 4;\n\n        case 4:\n          frontToken = headers.get(\"front-token\");\n          if (!(frontToken !== null)) return [3\n          /*break*/\n          , 6];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Setting sFrontToken: \" + frontToken);\n          return [4\n          /*yield*/\n          , fetch_1.FrontToken.setItem(frontToken)];\n\n        case 5:\n          _a.sent();\n\n          _a.label = 6;\n\n        case 6:\n          antiCsrfToken = headers.get(\"anti-csrf\");\n          if (!(antiCsrfToken !== null)) return [3\n          /*break*/\n          , 9];\n          return [4\n          /*yield*/\n          , (0, fetch_1.getLocalSessionState)(true)];\n\n        case 7:\n          tok = _a.sent();\n          if (!(tok.status === \"EXISTS\")) return [3\n          /*break*/\n          , 9];\n          (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Setting anti-csrf token\");\n          return [4\n          /*yield*/\n          , fetch_1.AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];\n\n        case 8:\n          _a.sent();\n\n          _a.label = 9;\n\n        case 9:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction getResponseHeadersFromXHR(xhr) {\n  return new Headers(xhr.getAllResponseHeaders().split(\"\\r\\n\").map(function (line) {\n    var sep = line.indexOf(\": \");\n\n    if (sep === -1) {\n      return [\"\", \"\"];\n    }\n\n    return [line.slice(0, sep), line.slice(sep + 2)];\n  }).filter(function (e) {\n    return e[0].length !== 0;\n  }));\n}","map":{"version":3,"sources":["/home/dom/FlyM/node_modules/supertokens-website/lib/build/xmlhttprequest.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","throw","return","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","Object","defineProperty","exports","addInterceptorsToXMLHttpRequest","utils_1","require","fetch_1","logger_1","windowHandler_1","processState_1","XHR_EVENTS","firstEventLoopDone","setTimeout","oldXMLHttpRequest","XMLHttpRequest","logDebugMessage","actual","delayActualCalls","delayIfNecessary","cb","self","listOfFunctionCallsInProxy","requestHeaders","customGetterValues","customResponseHeaders","eventHandlers","Map","url","doNotDoInterception","preRequestLSS","undefined","onload","onreadystatechange","onloadend","addEventListener","type","listener","_options","handlers","get","Set","set","add","removeEventListener","delete","redispatchEvent","name","ev","concat","size","Array","from","forEach","handler","handleRetryPostRefreshing","refreshResult","retryXhr","_a","Error","status","onUnauthorisedResponse","error","setUpXHR","i","sendXHR","handleResponse","xhr","status_1","headers","err_1","resp","ProcessState","getInstance","addState","PROCESS_STATE","CALLING_INTERCEPTION_RESPONSE","getResponseHeadersFromXHR","saveTokensFromHeaders","fireSessionUpdateEventsIfNecessary","default","config","sessionExpiredStatusCode","invalidClaimStatusCode","onInvalidClaimResponse","data","JSON","parse","responseText","getLocalSessionState","AntiCsrfToken","removeToken","FrontToken","getXMLHttpStatusAndResponseTextFromFetchResponse","statusText","responseType","_b","Event","open","u","args","arguments","shouldDoInterceptionBasedOnUrl","apiDomain","sessionTokenBackendDomain","toString","err","message","getReferenceOrThrow","windowHandler","location","getOrigin","send","inputBody","setRequestHeader","_this","accessToken","toLowerCase","getTokenForHeaderAuth","catch","console","copiedProps","isRetry","responseProcessed","delayedEvents","_loop_1","name_1","includes","_i","XHR_EVENTS_1","callself","readyState","DONE","getAllResponseHeaders","headersString","k","getResponseHeader","prop","_loop_2","configurable","val","copiedProps_1","CALLING_INTERCEPTION_REQUEST","antiCsrfToken","transferMethod","getToken","lastAccessTokenUpdate","autoAddCredentials","withCredentials","some","tokenTransferMethod","setAuthorizationHeaderIfRequired","__interceptedBySuperTokens","__original","response","contentType","_c","_d","text","stringify","json","refreshToken","frontToken","tok","setToken","setItem","Headers","split","map","line","sep","indexOf","slice","filter"],"mappings":"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","sourcesContent":["\"use strict\";\n/* Copyright (c) 2020, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\nvar __awaiter =\n    (this && this.__awaiter) ||\n    function (thisArg, _arguments, P, generator) {\n        function adopt(value) {\n            return value instanceof P\n                ? value\n                : new P(function (resolve) {\n                      resolve(value);\n                  });\n        }\n        return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) {\n                try {\n                    step(generator.next(value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function rejected(value) {\n                try {\n                    step(generator[\"throw\"](value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n            }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    };\nvar __generator =\n    (this && this.__generator) ||\n    function (thisArg, body) {\n        var _ = {\n                label: 0,\n                sent: function () {\n                    if (t[0] & 1) throw t[1];\n                    return t[1];\n                },\n                trys: [],\n                ops: []\n            },\n            f,\n            y,\n            t,\n            g;\n        return (\n            (g = { next: verb(0), throw: verb(1), return: verb(2) }),\n            typeof Symbol === \"function\" &&\n                (g[Symbol.iterator] = function () {\n                    return this;\n                }),\n            g\n        );\n        function verb(n) {\n            return function (v) {\n                return step([n, v]);\n            };\n        }\n        function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_)\n                try {\n                    if (\n                        ((f = 1),\n                        y &&\n                            (t =\n                                op[0] & 2\n                                    ? y[\"return\"]\n                                    : op[0]\n                                    ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0)\n                                    : y.next) &&\n                            !(t = t.call(y, op[1])).done)\n                    )\n                        return t;\n                    if (((y = 0), t)) op = [op[0] & 2, t.value];\n                    switch (op[0]) {\n                        case 0:\n                        case 1:\n                            t = op;\n                            break;\n                        case 4:\n                            _.label++;\n                            return { value: op[1], done: false };\n                        case 5:\n                            _.label++;\n                            y = op[1];\n                            op = [0];\n                            continue;\n                        case 7:\n                            op = _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                        default:\n                            if (\n                                !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&\n                                (op[0] === 6 || op[0] === 2)\n                            ) {\n                                _ = 0;\n                                continue;\n                            }\n                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                                _.label = op[1];\n                                break;\n                            }\n                            if (op[0] === 6 && _.label < t[1]) {\n                                _.label = t[1];\n                                t = op;\n                                break;\n                            }\n                            if (t && _.label < t[2]) {\n                                _.label = t[2];\n                                _.ops.push(op);\n                                break;\n                            }\n                            if (t[2]) _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                    }\n                    op = body.call(thisArg, _);\n                } catch (e) {\n                    op = [6, e];\n                    y = 0;\n                } finally {\n                    f = t = 0;\n                }\n            if (op[0] & 5) throw op[1];\n            return { value: op[0] ? op[1] : void 0, done: true };\n        }\n    };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addInterceptorsToXMLHttpRequest = void 0;\nvar utils_1 = require(\"./utils\");\nvar fetch_1 = require(\"./fetch\");\nvar logger_1 = require(\"./logger\");\nvar windowHandler_1 = require(\"./utils/windowHandler\");\nvar processState_1 = require(\"./processState\");\nvar XHR_EVENTS = [\"readystatechange\", \"abort\", \"error\", \"load\", \"loadend\", \"loadstart\", \"progress\", \"timeout\"];\nfunction addInterceptorsToXMLHttpRequest() {\n    var firstEventLoopDone = false;\n    setTimeout(function () {\n        return (firstEventLoopDone = true);\n    }, 0);\n    var oldXMLHttpRequest = XMLHttpRequest;\n    (0, logger_1.logDebugMessage)(\"addInterceptorsToXMLHttpRequest called\");\n    // create XMLHttpRequest proxy object\n    // define constructor for my proxy object\n    XMLHttpRequest = function () {\n        var actual = new oldXMLHttpRequest();\n        var delayActualCalls = !firstEventLoopDone;\n        function delayIfNecessary(cb) {\n            if (delayActualCalls) {\n                setTimeout(function () {\n                    cb();\n                }, 0);\n            } else {\n                cb();\n            }\n        }\n        var self = this;\n        var listOfFunctionCallsInProxy = [];\n        var requestHeaders = [];\n        var customGetterValues = {};\n        var customResponseHeaders;\n        var eventHandlers = new Map();\n        // We define these during open\n        // let method: string = \"\";\n        var url = \"\";\n        var doNotDoInterception = false;\n        var preRequestLSS = undefined;\n        var body;\n        // we do not provide onerror cause that is fired only on\n        // network level failures and nothing else. If a status code is > 400,\n        // then onload and onreadystatechange are called.\n        // Setting up props (event handlers) that we use in event handlers\n        // These require processing the response (and possibly retrying) before they are forwarded to the user\n        self.onload = null;\n        self.onreadystatechange = null;\n        self.onloadend = null;\n        // TODO: add support for other event listener options\n        // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters\n        self.addEventListener = function (type, listener, _options) {\n            var handlers = eventHandlers.get(type);\n            if (handlers === undefined) {\n                handlers = new Set();\n                eventHandlers.set(type, handlers);\n            }\n            handlers.add(listener);\n        };\n        self.removeEventListener = function (type, listener) {\n            var handlers = eventHandlers.get(type);\n            if (handlers === undefined) {\n                handlers = new Set();\n                eventHandlers.set(type, handlers);\n            }\n            handlers.delete(listener);\n        };\n        function redispatchEvent(name, ev) {\n            var handlers = eventHandlers.get(name);\n            (0, logger_1.logDebugMessage)(\n                \"XHRInterceptor dispatching \".concat(ev.type, \" to \").concat(handlers ? handlers.size : 0, \" listeners\")\n            );\n            if (handlers) {\n                Array.from(handlers).forEach(function (handler) {\n                    return handler.apply(self, [ev]);\n                });\n            }\n        }\n        function handleRetryPostRefreshing() {\n            return __awaiter(this, void 0, void 0, function () {\n                var refreshResult, retryXhr;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (preRequestLSS === undefined) {\n                                throw new Error(\"Should never come here..\");\n                            }\n                            (0,\n                            logger_1.logDebugMessage)(\"XHRInterceptor.handleRetryPostRefreshing: preRequestLSS \" + preRequestLSS.status);\n                            return [4 /*yield*/, (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];\n                        case 1:\n                            refreshResult = _a.sent();\n                            if (refreshResult.result !== \"RETRY\") {\n                                (0, logger_1.logDebugMessage)(\n                                    \"XHRInterceptor.handleRetryPostRefreshing: Not retrying original request \" +\n                                        !!refreshResult.error\n                                );\n                                if (refreshResult.error !== undefined) {\n                                    // this will cause the responseText of the self to be updated\n                                    // to the error message and make the status code the same as\n                                    // what the error's status code is.\n                                    throw refreshResult.error;\n                                }\n                                // it can come here if refreshResult.result is SESSION_EXPIRED.\n                                // in that case, the status of self is already 401. So we let it\n                                // pass through.\n                                return [2 /*return*/, true];\n                            }\n                            (0,\n                            logger_1.logDebugMessage)(\"XHRInterceptor.handleRetryPostRefreshing: Retrying original request\");\n                            retryXhr = new oldXMLHttpRequest();\n                            setUpXHR(self, retryXhr, true);\n                            // this also calls the send function with the appropriate body\n                            listOfFunctionCallsInProxy.forEach(function (i) {\n                                i(retryXhr);\n                            });\n                            sendXHR(retryXhr, body);\n                            return [2 /*return*/, false];\n                    }\n                });\n            });\n        }\n        function handleResponse(xhr) {\n            return __awaiter(this, void 0, void 0, function () {\n                var status_1, headers, err_1, resp;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (doNotDoInterception) {\n                                (0, logger_1.logDebugMessage)(\n                                    \"XHRInterceptor.handleResponse: Returning without interception\"\n                                );\n                                return [2 /*return*/, true];\n                            }\n                            _a.label = 1;\n                        case 1:\n                            _a.trys.push([1, 14, , 18]);\n                            _a.label = 2;\n                        case 2:\n                            _a.trys.push([2, , 8, 13]);\n                            (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: Interception started\");\n                            processState_1.ProcessState.getInstance().addState(\n                                processState_1.PROCESS_STATE.CALLING_INTERCEPTION_RESPONSE\n                            );\n                            status_1 = xhr.status;\n                            headers = getResponseHeadersFromXHR(xhr);\n                            return [4 /*yield*/, saveTokensFromHeaders(headers)];\n                        case 3:\n                            _a.sent();\n                            (0,\n                            fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === \"EXISTS\", status_1, headers.get(\"front-token\"));\n                            if (!(status_1 === fetch_1.default.config.sessionExpiredStatusCode))\n                                return [3 /*break*/, 5];\n                            (0, logger_1.logDebugMessage)(\"responseInterceptor: Status code is: \" + status_1);\n                            return [4 /*yield*/, handleRetryPostRefreshing()];\n                        case 4:\n                            return [2 /*return*/, _a.sent()];\n                        case 5:\n                            if (!(status_1 === fetch_1.default.config.invalidClaimStatusCode)) return [3 /*break*/, 7];\n                            return [\n                                4 /*yield*/,\n                                (0, fetch_1.onInvalidClaimResponse)({\n                                    data: JSON.parse(xhr.responseText)\n                                })\n                            ];\n                        case 6:\n                            _a.sent();\n                            _a.label = 7;\n                        case 7:\n                            return [2 /*return*/, true];\n                        case 8:\n                            (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: doFinallyCheck running\");\n                            return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(false)];\n                        case 9:\n                            if (!!(_a.sent().status === \"EXISTS\")) return [3 /*break*/, 12];\n                            (0,\n                            logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: local session doesn't exist, so removing anti-csrf and sFrontToken\");\n                            return [4 /*yield*/, fetch_1.AntiCsrfToken.removeToken()];\n                        case 10:\n                            _a.sent();\n                            return [4 /*yield*/, fetch_1.FrontToken.removeToken()];\n                        case 11:\n                            _a.sent();\n                            _a.label = 12;\n                        case 12:\n                            return [7 /*endfinally*/];\n                        case 13:\n                            return [3 /*break*/, 18];\n                        case 14:\n                            err_1 = _a.sent();\n                            (0, logger_1.logDebugMessage)(\"XHRInterceptor.handleResponse: caught error\");\n                            if (!(err_1.status !== undefined)) return [3 /*break*/, 16];\n                            return [4 /*yield*/, getXMLHttpStatusAndResponseTextFromFetchResponse(err_1)];\n                        case 15:\n                            resp = _a.sent();\n                            customGetterValues[\"status\"] = resp.status;\n                            customGetterValues[\"statusText\"] = resp.statusText;\n                            customGetterValues[\"responseType\"] = resp.responseType;\n                            customResponseHeaders = resp.headers;\n                            if (resp.responseType === \"json\") {\n                                try {\n                                    customGetterValues[\"response\"] = JSON.parse(resp.responseText);\n                                } catch (_b) {\n                                    customGetterValues[\"response\"] = resp.responseText;\n                                }\n                            } else {\n                                customGetterValues[\"response\"] = resp.responseText;\n                            }\n                            customGetterValues[\"responseText\"] = resp.responseText;\n                            return [3 /*break*/, 17];\n                        case 16:\n                            // Here we only need to handle fetch related errors, from the refresh endpoint called by the retry\n                            // So we should only get network level errors here\n                            redispatchEvent(\"error\", new Event(\"error\"));\n                            _a.label = 17;\n                        case 17:\n                            return [2 /*return*/, true];\n                        case 18:\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        }\n        self.open = function (_, u) {\n            (0, logger_1.logDebugMessage)(\"XHRInterceptor.open called\");\n            var args = arguments;\n            listOfFunctionCallsInProxy.push(function (xhr) {\n                xhr.open.apply(xhr, args);\n            });\n            // method = m;\n            url = u;\n            try {\n                doNotDoInterception =\n                    (typeof url === \"string\" &&\n                        !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                            url,\n                            fetch_1.default.config.apiDomain,\n                            fetch_1.default.config.sessionTokenBackendDomain\n                        )) ||\n                    (typeof url !== \"string\" &&\n                        !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                            url.toString(),\n                            fetch_1.default.config.apiDomain,\n                            fetch_1.default.config.sessionTokenBackendDomain\n                        ));\n            } catch (err) {\n                if (err.message === \"Please provide a valid domain name\") {\n                    (0, logger_1.logDebugMessage)(\n                        \"XHRInterceptor.open: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                    );\n                    // .origin gives the port as well..\n                    doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                        windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),\n                        fetch_1.default.config.apiDomain,\n                        fetch_1.default.config.sessionTokenBackendDomain\n                    );\n                } else {\n                    throw err;\n                }\n            }\n            // here we use the apply syntax cause there are other optional args that\n            // can be passed by the user.\n            delayIfNecessary(function () {\n                return actual.open.apply(actual, args);\n            });\n        };\n        self.send = function (inputBody) {\n            body = inputBody;\n            sendXHR(actual, body);\n        };\n        self.setRequestHeader = function (name, value) {\n            var _this = this;\n            if (doNotDoInterception) {\n                delayIfNecessary(function () {\n                    return actual.setRequestHeader(name, value);\n                });\n                return;\n            }\n            // We need to do this, because if there is another interceptor wrapping this (e.g.: the axios interceptor)\n            // then the anti-csrf token they add would be concatenated to the anti-csrf token added by this interceptor\n            if (name === \"anti-csrf\") {\n                return;\n            }\n            void (function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                    var accessToken;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                if (!(name.toLowerCase() === \"authorization\")) return [3 /*break*/, 2];\n                                return [4 /*yield*/, (0, fetch_1.getTokenForHeaderAuth)(\"access\")];\n                            case 1:\n                                accessToken = _a.sent();\n                                if (value === \"Bearer \".concat(accessToken)) {\n                                    // We are ignoring the Authorization header set by the user in this case, because it would cause issues\n                                    // If we do not ignore this, then this header would be used even if the request is being retried after a refresh, even though it contains an outdated access token.\n                                    // This causes an infinite refresh loop.\n                                    (0, logger_1.logDebugMessage)(\n                                        \"XHRInterceptor.setRequestHeader: skipping Authorization from user provided headers because it contains our access token\"\n                                    );\n                                    return [2 /*return*/];\n                                }\n                                _a.label = 2;\n                            case 2:\n                                listOfFunctionCallsInProxy.push(function (xhr) {\n                                    xhr.setRequestHeader(name, value);\n                                });\n                                // The original version \"combines\" headers according to MDN.\n                                requestHeaders.push({ name: name, value: value });\n                                delayIfNecessary(function () {\n                                    return actual.setRequestHeader(name, value);\n                                });\n                                return [2 /*return*/];\n                        }\n                    });\n                });\n            })().catch(function (err) {\n                // This should basically never happen: it'd mean that getCookie threw an error\n                console.error(\"An error occured during setRequestHeader: \", err);\n            });\n        };\n        var copiedProps = undefined;\n        setUpXHR(self, actual, false);\n        function setUpXHR(self, xhr, isRetry) {\n            var responseProcessed;\n            var delayedEvents = [\"load\", \"loadend\", \"readystatechange\"];\n            (0, logger_1.logDebugMessage)(\"XHRInterceptor.setUpXHR called\");\n            var _loop_1 = function (name_1) {\n                (0, logger_1.logDebugMessage)(\"XHRInterceptor added listener for event \".concat(name_1));\n                xhr.addEventListener(name_1, function (ev) {\n                    (0, logger_1.logDebugMessage)(\"XHRInterceptor got event \".concat(name_1));\n                    if (!delayedEvents.includes(name_1)) {\n                        redispatchEvent(name_1, ev);\n                    }\n                });\n            };\n            for (var _i = 0, XHR_EVENTS_1 = XHR_EVENTS; _i < XHR_EVENTS_1.length; _i++) {\n                var name_1 = XHR_EVENTS_1[_i];\n                _loop_1(name_1);\n            }\n            xhr.onload = function (ev) {\n                if (responseProcessed === undefined) {\n                    responseProcessed = handleResponse(xhr);\n                }\n                responseProcessed.then(function (callself) {\n                    if (!callself) {\n                        return;\n                    }\n                    if (self.onload) {\n                        self.onload(ev);\n                    }\n                    redispatchEvent(\"load\", ev);\n                });\n            };\n            xhr.onreadystatechange = function (ev) {\n                // In local files, status is 0 upon success in Mozilla Firefox\n                if (xhr.readyState === oldXMLHttpRequest.DONE) {\n                    if (responseProcessed === undefined) {\n                        responseProcessed = handleResponse(xhr);\n                    }\n                    responseProcessed.then(function (callself) {\n                        if (!callself) {\n                            return;\n                        }\n                        if (self.onreadystatechange) self.onreadystatechange(ev);\n                        redispatchEvent(\"readystatechange\", ev);\n                    });\n                } else {\n                    if (self.onreadystatechange) {\n                        self.onreadystatechange(ev);\n                    }\n                    redispatchEvent(\"readystatechange\", ev);\n                }\n            };\n            xhr.onloadend = function (ev) {\n                if (responseProcessed === undefined) {\n                    responseProcessed = handleResponse(xhr);\n                }\n                responseProcessed.then(function (callself) {\n                    if (!callself) {\n                        return;\n                    }\n                    if (self.onloadend) {\n                        self.onloadend(ev);\n                    }\n                    redispatchEvent(\"loadend\", ev);\n                });\n            };\n            self.getAllResponseHeaders = function () {\n                var headersString;\n                if (customResponseHeaders) {\n                    headersString = \"\";\n                    customResponseHeaders.forEach(function (v, k) {\n                        return (headersString += \"\".concat(k, \": \").concat(v, \"\\r\\n\"));\n                    });\n                } else {\n                    headersString = xhr.getAllResponseHeaders();\n                }\n                // We use this \"fake-header\" to signal other interceptors (axios) that this is done\n                // in case both is applied\n                return headersString + \"x-supertokens-xhr-intercepted: true\\r\\n\";\n            };\n            self.getResponseHeader = function (name) {\n                if (name === \"x-supertokens-xhr-intercepted\") {\n                    return \"true\";\n                }\n                if (customResponseHeaders) {\n                    return customResponseHeaders.get(name);\n                }\n                return xhr.getResponseHeader(name);\n            };\n            if (copiedProps === undefined) {\n                copiedProps = [];\n                // iterate all properties in actual to proxy them according to their type\n                // For functions, we call actual and return the result\n                // For non-functions, we make getters/setters\n                // If the property already exists on self, then don't proxy it\n                for (var prop in xhr) {\n                    // skip properties we already have - this will skip both the above defined properties\n                    // that we don't want to proxy and skip properties on the prototype belonging to Object\n                    if (!(prop in self)) {\n                        // We save these props into an array - in case we need to set up a retry XHR\n                        copiedProps.push(prop);\n                    }\n                }\n            }\n            var _loop_2 = function (prop) {\n                if (typeof xhr[prop] === \"function\") {\n                    // define our own property that calls the same method on the actual\n                    Object.defineProperty(self, prop, {\n                        configurable: true,\n                        value: function () {\n                            var args = arguments;\n                            if (!isRetry) {\n                                listOfFunctionCallsInProxy.push(function (xhr) {\n                                    xhr[prop].apply(xhr, args);\n                                });\n                            }\n                            return xhr[prop].apply(xhr, args);\n                        }\n                    });\n                } else {\n                    // define our own property that just gets or sets the same prop on the actual\n                    Object.defineProperty(self, prop, {\n                        configurable: true,\n                        get: function () {\n                            if (customGetterValues[prop] !== undefined) {\n                                return customGetterValues[prop];\n                            }\n                            return xhr[prop];\n                        },\n                        set: function (val) {\n                            if (!isRetry) {\n                                listOfFunctionCallsInProxy.push(function (xhr) {\n                                    xhr[prop] = val;\n                                });\n                            }\n                            (0, logger_1.logDebugMessage)(\"XHRInterceptor.set[\".concat(prop, \"] = \").concat(val));\n                            xhr[prop] = val;\n                        }\n                    });\n                }\n            };\n            for (var _a = 0, copiedProps_1 = copiedProps; _a < copiedProps_1.length; _a++) {\n                var prop = copiedProps_1[_a];\n                _loop_2(prop);\n            }\n        }\n        function sendXHR(xhr, body) {\n            var _this = this;\n            (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: called\");\n            (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Value of doNotDoInterception: \" + doNotDoInterception);\n            if (doNotDoInterception) {\n                (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Returning without interception\");\n                delayIfNecessary(function () {\n                    return xhr.send(body);\n                });\n                return;\n            }\n            (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Interception started\");\n            processState_1.ProcessState.getInstance().addState(\n                processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST\n            );\n            delayIfNecessary(function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                    var antiCsrfToken, transferMethod;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(true)];\n                            case 1:\n                                preRequestLSS = _a.sent();\n                                if (!(preRequestLSS.status === \"EXISTS\")) return [3 /*break*/, 3];\n                                return [\n                                    4 /*yield*/,\n                                    fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)\n                                ];\n                            case 2:\n                                antiCsrfToken = _a.sent();\n                                if (antiCsrfToken !== undefined) {\n                                    (0, logger_1.logDebugMessage)(\n                                        \"XHRInterceptor.send: Adding anti-csrf token to request\"\n                                    );\n                                    xhr.setRequestHeader(\"anti-csrf\", antiCsrfToken);\n                                }\n                                _a.label = 3;\n                            case 3:\n                                if (fetch_1.default.config.autoAddCredentials) {\n                                    (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Adding credentials include\");\n                                    self.withCredentials = true;\n                                }\n                                if (\n                                    !requestHeaders.some(function (i) {\n                                        return i.name === \"rid\";\n                                    })\n                                ) {\n                                    (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Adding rid header: anti-csrf\");\n                                    xhr.setRequestHeader(\"rid\", \"anti-csrf\");\n                                } else {\n                                    (0, logger_1.logDebugMessage)(\n                                        \"XHRInterceptor.send: rid header was already there in request\"\n                                    );\n                                }\n                                transferMethod = fetch_1.default.config.tokenTransferMethod;\n                                if (\n                                    !requestHeaders.some(function (i) {\n                                        return i.name === \"st-auth-mode\";\n                                    })\n                                ) {\n                                    (0, logger_1.logDebugMessage)(\n                                        \"XHRInterceptor.send: Adding st-auth-mode header: \" + transferMethod\n                                    );\n                                    xhr.setRequestHeader(\"st-auth-mode\", transferMethod);\n                                } else {\n                                    (0, logger_1.logDebugMessage)(\n                                        \"XHRInterceptor.send: st-auth-mode header was already there in request\"\n                                    );\n                                }\n                                return [4 /*yield*/, setAuthorizationHeaderIfRequired(xhr, requestHeaders)];\n                            case 4:\n                                _a.sent();\n                                (0, logger_1.logDebugMessage)(\"XHRInterceptor.send: Making user's http call\");\n                                return [2 /*return*/, xhr.send(body)];\n                        }\n                    });\n                });\n            });\n        }\n    };\n    // This can be used by other interceptors (axios) to detect if this interceptor has been added or not\n    XMLHttpRequest.__interceptedBySuperTokens = true;\n    XMLHttpRequest.__original = oldXMLHttpRequest;\n}\nexports.addInterceptorsToXMLHttpRequest = addInterceptorsToXMLHttpRequest;\nfunction getXMLHttpStatusAndResponseTextFromFetchResponse(response) {\n    return __awaiter(this, void 0, void 0, function () {\n        var contentType, data, responseType, _a, _b, _c;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0:\n                    contentType = response.headers.get(\"content-type\");\n                    data = \"\";\n                    responseType = \"text\";\n                    if (!(contentType === null)) return [3 /*break*/, 5];\n                    _d.label = 1;\n                case 1:\n                    _d.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, response.text()];\n                case 2:\n                    data = _d.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    _a = _d.sent();\n                    data = \"\";\n                    return [3 /*break*/, 4];\n                case 4:\n                    return [3 /*break*/, 9];\n                case 5:\n                    if (!contentType.includes(\"application/json\")) return [3 /*break*/, 7];\n                    responseType = \"json\";\n                    _c = (_b = JSON).stringify;\n                    return [4 /*yield*/, response.json()];\n                case 6:\n                    data = _c.apply(_b, [_d.sent()]);\n                    return [3 /*break*/, 9];\n                case 7:\n                    if (!contentType.includes(\"text/\")) return [3 /*break*/, 9];\n                    return [4 /*yield*/, response.text()];\n                case 8:\n                    data = _d.sent();\n                    _d.label = 9;\n                case 9:\n                    return [\n                        2 /*return*/,\n                        {\n                            status: response.status,\n                            responseText: data,\n                            statusText: response.statusText,\n                            responseType: responseType,\n                            headers: response.headers\n                        }\n                    ];\n            }\n        });\n    });\n}\nfunction setAuthorizationHeaderIfRequired(xhr, requestHeaders) {\n    return __awaiter(this, void 0, void 0, function () {\n        var accessToken, refreshToken;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"setAuthorizationHeaderIfRequired: adding existing tokens as header\");\n                    return [4 /*yield*/, (0, fetch_1.getTokenForHeaderAuth)(\"access\")];\n                case 1:\n                    accessToken = _a.sent();\n                    return [4 /*yield*/, (0, fetch_1.getTokenForHeaderAuth)(\"refresh\")];\n                case 2:\n                    refreshToken = _a.sent();\n                    // We don't add the refresh token because that's only required by the refresh call which is done with fetch\n                    // Still, we only add the Authorization header if both are present, because we are planning to add an option to expose the\n                    // access token to the frontend while using cookie based auth - so that users can get the access token to use\n                    if (accessToken !== undefined && refreshToken !== undefined) {\n                        if (\n                            requestHeaders.some(function (_a) {\n                                var name = _a.name;\n                                return name.toLowerCase() === \"authorization\";\n                            })\n                        ) {\n                            (0, logger_1.logDebugMessage)(\n                                \"setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding\"\n                            );\n                        } else {\n                            if (accessToken !== undefined) {\n                                (0, logger_1.logDebugMessage)(\n                                    \"setAuthorizationHeaderIfRequired: added authorization header\"\n                                );\n                                xhr.setRequestHeader(\"Authorization\", \"Bearer \".concat(accessToken));\n                            }\n                            // We don't add the refresh token because that's only required by the refresh call which is done with fetch\n                        }\n                    } else {\n                        (0, logger_1.logDebugMessage)(\n                            \"setAuthorizationHeaderIfRequired: token for header based auth not found\"\n                        );\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction saveTokensFromHeaders(headers) {\n    return __awaiter(this, void 0, void 0, function () {\n        var refreshToken, accessToken, frontToken, antiCsrfToken, tok;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Saving updated tokens from the response\");\n                    refreshToken = headers.get(\"st-refresh-token\");\n                    if (!(refreshToken !== null)) return [3 /*break*/, 2];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new refresh token\");\n                    return [4 /*yield*/, (0, fetch_1.setToken)(\"refresh\", refreshToken)];\n                case 1:\n                    _a.sent();\n                    _a.label = 2;\n                case 2:\n                    accessToken = headers.get(\"st-access-token\");\n                    if (!(accessToken !== null)) return [3 /*break*/, 4];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: saving new access token\");\n                    return [4 /*yield*/, (0, fetch_1.setToken)(\"access\", accessToken)];\n                case 3:\n                    _a.sent();\n                    _a.label = 4;\n                case 4:\n                    frontToken = headers.get(\"front-token\");\n                    if (!(frontToken !== null)) return [3 /*break*/, 6];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Setting sFrontToken: \" + frontToken);\n                    return [4 /*yield*/, fetch_1.FrontToken.setItem(frontToken)];\n                case 5:\n                    _a.sent();\n                    _a.label = 6;\n                case 6:\n                    antiCsrfToken = headers.get(\"anti-csrf\");\n                    if (!(antiCsrfToken !== null)) return [3 /*break*/, 9];\n                    return [4 /*yield*/, (0, fetch_1.getLocalSessionState)(true)];\n                case 7:\n                    tok = _a.sent();\n                    if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 9];\n                    (0, logger_1.logDebugMessage)(\"saveTokensFromHeaders: Setting anti-csrf token\");\n                    return [4 /*yield*/, fetch_1.AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];\n                case 8:\n                    _a.sent();\n                    _a.label = 9;\n                case 9:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction getResponseHeadersFromXHR(xhr) {\n    return new Headers(\n        xhr\n            .getAllResponseHeaders()\n            .split(\"\\r\\n\")\n            .map(function (line) {\n                var sep = line.indexOf(\": \");\n                if (sep === -1) {\n                    return [\"\", \"\"];\n                }\n                return [line.slice(0, sep), line.slice(sep + 2)];\n            })\n            .filter(function (e) {\n                return e[0].length !== 0;\n            })\n    );\n}\n"]},"metadata":{},"sourceType":"script"}
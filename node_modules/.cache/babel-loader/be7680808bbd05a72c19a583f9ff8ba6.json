{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _response = _interopRequireDefault(require(\"./response\"));\n\nvar _util = _interopRequireDefault(require(\"util\"));\n\nvar _errors = require(\"./errors\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n/**\n * Listen to changes in the HTTP request and build Response/ResponseError\n * objects accordingly.\n *\n * @param {Request} request the request object used to make the call\n * @param {EventEmitter} emitter a Node event emitter\n * @param {Client} client the client instance to log results to\n * @protected\n */\n\n\nvar Listener = /*#__PURE__*/function () {\n  function Listener(request, emitter, client) {\n    _classCallCheck(this, Listener);\n\n    this.request = request;\n    this.emitter = emitter;\n    this.client = client;\n  } // PROTECTED\n\n  /**\n   * Listens to various events on the http_response object, listening for data,\n   * connections closing for bad reasons, and the end of the response.\n   *\n   * Used by the Client when making an API call.\n   *\n   * @param  {Object} http_response a Node http response object\n   * @protected\n   */\n\n\n  _createClass(Listener, [{\n    key: \"onResponse\",\n    value: function onResponse(http_response) {\n      var response = new _response[\"default\"](http_response, this.request);\n      http_response.on('data', response.addChunk.bind(response));\n      http_response.on('end', this.onEnd(response).bind(this));\n      http_response.on('close', this.onNetworkError(response).bind(this));\n      http_response.on('error', this.onNetworkError(response).bind(this));\n    }\n    /**\n     * Listens to a network error when making an API call.\n     *\n     * Used by the Client when making an API call.\n     *\n     * @param  {Object} http_response a Node http response object\n     * @protected\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(http_response) {\n      var response = new _response[\"default\"](http_response, this.request);\n      this.onNetworkError(response)();\n    } // PRIVATE\n\n    /**\n     * When the connection ends, check if the response can be parsed or not and\n     * act accordingly.\n     *\n     * @param  {Response} response\n     */\n\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(response) {\n      var _this = this;\n\n      return function () {\n        response.parse();\n\n        if (response.success()) {\n          _this.onSuccess(response);\n        } else {\n          _this.onFail(response);\n        }\n      };\n    }\n    /**\n     * When the response was successful, resolve the promise and return the\n     * response object\n     *\n     * @param  {Response} response\n     */\n\n  }, {\n    key: \"onSuccess\",\n    value: function onSuccess(response) {\n      this.log(response);\n      this.emitter.emit('resolve', response);\n    }\n    /**\n     * When the connection was not successful, determine the reason and resolve\n     * the promise accordingly.\n     *\n     * @param  {Response} response\n     */\n\n  }, {\n    key: \"onFail\",\n    value: function onFail(response) {\n      var Error = this.errorFor(response);\n      var error = new Error(response);\n      this.log(response, error);\n      this.emitter.emit('reject', error);\n    }\n    /**\n     * Find the right error for the given response.\n     *\n     * @param {Response} reponse\n     * @returns {ResponseError}\n     */\n\n  }, {\n    key: \"errorFor\",\n    value: function errorFor(_ref) {\n      var statusCode = _ref.statusCode,\n          parsed = _ref.parsed;\n      var error = null;\n\n      if (statusCode >= 500) {\n        error = _errors.ServerError;\n      } else if (statusCode === 401) {\n        error = _errors.AuthenticationError;\n      } else if (statusCode === 404) {\n        error = _errors.NotFoundError;\n      } else if (statusCode >= 400) {\n        error = _errors.ClientError;\n      } else if (!parsed) {\n        error = _errors.ParserError;\n      } else {\n        error = _errors.UnknownError;\n      }\n\n      return error;\n    }\n    /**\n     * When the connection ran into a network error, reject the promise with a\n     * NetworkError.\n     *\n     * @param  {Response} response\n     */\n\n  }, {\n    key: \"onNetworkError\",\n    value: function onNetworkError(response) {\n      var _this2 = this;\n\n      return function () {\n        response.parse();\n        var error = new _errors.NetworkError(response);\n\n        _this2.log(response, error);\n\n        _this2.emitter.emit('reject', error);\n      };\n    }\n    /**\n     * Logs the response, when in debug mode\n     *\n     * @param  {Response} response the response object to log\n     * @private\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(response, error) {\n      if (this.client.debug()) {\n        /* istanbul ignore next */\n        this.client.logger.log(_util[\"default\"].inspect(response, false, null));\n      }\n\n      if (!this.client.debug() && this.client.warn() && error) {\n        /* istanbul ignore next */\n        this.client.logger.log('Amadeus', error.code, error.description);\n      }\n    }\n  }]);\n\n  return Listener;\n}();\n\nvar _default = Listener;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"mappings":"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","names":["descriptor","Object","writable","Listener","request","emitter","client","_classCallCheck","_createClass","key","value","http_response","response","Response","on","addChunk","bind","onEnd","onNetworkError","parse","success","_this","onSuccess","onFail","log","emit","Error","errorFor","error","statusCode","parsed","ServerError","AuthenticationError","NotFoundError","ClientError","ParserError","UnknownError","NetworkError","_this2","debug","logger","util","inspect","warn","code","description","exports","module"],"sources":["/home/dom/Videos/FlyM/node_modules/amadeus/src/amadeus/client/listener.js"],"sourcesContent":["import Response from './response';\nimport util     from 'util';\n\nimport {\n  ServerError,\n  NotFoundError,\n  ClientError,\n  ParserError,\n  UnknownError,\n  NetworkError,\n  AuthenticationError\n} from './errors';\n\n\n/**\n * Listen to changes in the HTTP request and build Response/ResponseError\n * objects accordingly.\n *\n * @param {Request} request the request object used to make the call\n * @param {EventEmitter} emitter a Node event emitter\n * @param {Client} client the client instance to log results to\n * @protected\n */\nclass Listener {\n  constructor(request, emitter, client) {\n    this.request = request;\n    this.emitter = emitter;\n    this.client  = client;\n  }\n\n  // PROTECTED\n\n\n  /**\n   * Listens to various events on the http_response object, listening for data,\n   * connections closing for bad reasons, and the end of the response.\n   *\n   * Used by the Client when making an API call.\n   *\n   * @param  {Object} http_response a Node http response object\n   * @protected\n   */\n  onResponse(http_response) {\n    let response = new Response(http_response, this.request);\n\n    http_response.on('data',  response.addChunk.bind(response));\n    http_response.on('end',   this.onEnd(response).bind(this));\n    http_response.on('close', this.onNetworkError(response).bind(this));\n    http_response.on('error', this.onNetworkError(response).bind(this));\n  }\n\n  /**\n   * Listens to a network error when making an API call.\n   *\n   * Used by the Client when making an API call.\n   *\n   * @param  {Object} http_response a Node http response object\n   * @protected\n   */\n\n  onError(http_response) {\n    let response = new Response(http_response, this.request);\n    this.onNetworkError(response)();\n  }\n\n  // PRIVATE\n\n\n  /**\n   * When the connection ends, check if the response can be parsed or not and\n   * act accordingly.\n   *\n   * @param  {Response} response\n   */\n  onEnd(response) {\n    return () => {\n      response.parse();\n      if (response.success()) { this.onSuccess(response); }\n      else { this.onFail(response);  }\n    };\n  }\n\n  /**\n   * When the response was successful, resolve the promise and return the\n   * response object\n   *\n   * @param  {Response} response\n   */\n  onSuccess(response) {\n    this.log(response);\n    this.emitter.emit('resolve', response);\n  }\n\n  /**\n   * When the connection was not successful, determine the reason and resolve\n   * the promise accordingly.\n   *\n   * @param  {Response} response\n   */\n  onFail(response) {\n    let Error = this.errorFor(response);\n    let error = new Error(response);\n    this.log(response, error);\n    this.emitter.emit('reject', error);\n  }\n\n\n  /**\n   * Find the right error for the given response.\n   *\n   * @param {Response} reponse\n   * @returns {ResponseError}\n   */\n  errorFor({statusCode, parsed}) {\n    let error = null;\n    if (statusCode >= 500) { error = ServerError; }\n    else if (statusCode === 401) { error = AuthenticationError; }\n    else if (statusCode === 404) { error = NotFoundError; }\n    else if (statusCode >= 400) { error = ClientError; }\n    else if (!parsed) { error = ParserError; }\n    else { error = UnknownError; }\n    return error;\n  }\n\n  /**\n   * When the connection ran into a network error, reject the promise with a\n   * NetworkError.\n   *\n   * @param  {Response} response\n   */\n  onNetworkError(response) {\n    return () => {\n      response.parse();\n      let error = new NetworkError(response);\n      this.log(response, error);\n      this.emitter.emit('reject', error);\n    };\n  }\n\n  /**\n   * Logs the response, when in debug mode\n   *\n   * @param  {Response} response the response object to log\n   * @private\n   */\n  log(response, error) {\n    if (this.client.debug()) {\n      /* istanbul ignore next */\n      this.client.logger.log(util.inspect(response, false, null));\n    }\n    if (!this.client.debug() && this.client.warn() && error) {\n      /* istanbul ignore next */\n      this.client.logger.log('Amadeus', error.code, error.description);\n    }\n  }\n}\n\nexport default Listener;\n"]},"metadata":{},"sourceType":"script"}
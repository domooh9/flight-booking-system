{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = _interopRequireDefault(require(\"events\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n} // The number of seconds before the token expires, when\n// we will already try to refresh it\n\n\nvar TOKEN_BUFFER = 10;\n/**\n  * A helper library to create and maintain the OAuth2 AccessTokens between\n  * requests. Keeps track of the expiry time and automatically tries to fetch\n  * a new token if needed.\n  *\n  * @property {string} accessToken the cached current access token (bearer)\n  * @property {number} expiresAt the aproximate time this token expires at\n  * @protected\n  */\n\nvar AccessToken = /*#__PURE__*/function () {\n  function AccessToken() {\n    _classCallCheck(this, AccessToken);\n\n    this.accessToken;\n    this.expiresAt;\n  } // PROTECTED\n\n  /**\n   * Fetches or returns a cached bearer token. Used by the Client to get a\n   * token before making an API call.\n   *\n   * @param  {Client} client the Amadeus Client to make an API call with\n   * @return {Promise.<Response,ResponseError>} a Bluebird Promise\n   * @protected\n   */\n\n\n  _createClass(AccessToken, [{\n    key: \"bearerToken\",\n    value: function bearerToken(client) {\n      var emitter = new _events[\"default\"]();\n      var promise = this.promise(emitter);\n      this.emitOrLoadAccessToken(client, emitter);\n      return promise;\n    } // PRIVATE\n\n    /**\n     * Builds a Bluebird promise to be returned to the API user\n     *\n     * @param  {type} emitter the EventEmitter used to notify the Promise of\n     * @return {Promise} a Bluebird promise\n     * @private\n     */\n\n  }, {\n    key: \"promise\",\n    value: function promise(emitter) {\n      return new Promise(function (resolve, reject) {\n        emitter.on('resolve', function (response) {\n          return resolve(response);\n        });\n        emitter.on('reject', function (error) {\n          return reject(error);\n        });\n      });\n    }\n    /**\n     * Checks if the token needs a refresh, if not emits the cached token,\n     * otherwise tries to load a new access token\n     *\n     * @param  {Client} client the Amadeus Client to make an API call with\n     * @param  {type} emitter the EventEmitter used to emit the token\n     * @private\n     */\n\n  }, {\n    key: \"emitOrLoadAccessToken\",\n    value: function emitOrLoadAccessToken(client, emitter) {\n      if (this.needsLoadOrRefresh()) {\n        this.loadAccessToken(client, emitter);\n      } else {\n        emitter.emit('resolve', this.accessToken);\n      }\n    }\n    /**\n     * Checks if the token needs a refresh or first load\n     *\n     * @return {boolean} wether the token needs a refresh\n     * @private\n     */\n\n  }, {\n    key: \"needsLoadOrRefresh\",\n    value: function needsLoadOrRefresh() {\n      if (!this.accessToken) {\n        return true;\n      } else if (Date.now() + TOKEN_BUFFER > this.expiresAt) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Loads the access token using the client, emits the token when it's loaded\n     *\n     * @param  {Client} client the Amadeus Client to make an API call with\n     * @param  {type} emitter the EventEmitter used to emit the token\n     * @private\n     */\n\n  }, {\n    key: \"loadAccessToken\",\n    value: function loadAccessToken(client, emitter) {\n      var _this = this;\n\n      client.unauthenticatedRequest('POST', '/v1/security/oauth2/token', {\n        'grant_type': 'client_credentials',\n        'client_id': client.clientId,\n        'client_secret': client.clientSecret\n      }).then(function (response) {\n        _this.storeAccessToken(response);\n\n        _this.emitOrLoadAccessToken(client, emitter);\n      })[\"catch\"](function (error) {\n        emitter.emit('reject', error);\n      });\n    }\n    /**\n     * Stores a loaded access token, calculating the expiry date\n     *\n     * @param  {Response} response the response object received from the client\n     * @private\n     */\n\n  }, {\n    key: \"storeAccessToken\",\n    value: function storeAccessToken(response) {\n      this.accessToken = response.result['access_token'];\n      this.expiresAt = Date.now() + response.result['expires_in'] * 1000;\n    }\n  }]);\n\n  return AccessToken;\n}();\n\nvar _default = AccessToken;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"mappings":"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","names":["descriptor","Object","writable","TOKEN_BUFFER","AccessToken","_classCallCheck","accessToken","expiresAt","_createClass","key","value","client","emitter","EventEmitter","promise","emitOrLoadAccessToken","Promise","resolve","reject","on","response","error","needsLoadOrRefresh","loadAccessToken","emit","Date","now","unauthenticatedRequest","clientId","clientSecret","then","_this","storeAccessToken","result","exports","module"],"sources":["/home/dom/Videos/FlyM/node_modules/amadeus/src/amadeus/client/access_token.js"],"sourcesContent":["import EventEmitter from 'events';\n\n// The number of seconds before the token expires, when\n// we will already try to refresh it\nconst TOKEN_BUFFER = 10;\n\n/**\n  * A helper library to create and maintain the OAuth2 AccessTokens between\n  * requests. Keeps track of the expiry time and automatically tries to fetch\n  * a new token if needed.\n  *\n  * @property {string} accessToken the cached current access token (bearer)\n  * @property {number} expiresAt the aproximate time this token expires at\n  * @protected\n  */\nclass AccessToken {\n  constructor() {\n    this.accessToken;\n    this.expiresAt;\n  }\n\n  // PROTECTED\n\n  /**\n   * Fetches or returns a cached bearer token. Used by the Client to get a\n   * token before making an API call.\n   *\n   * @param  {Client} client the Amadeus Client to make an API call with\n   * @return {Promise.<Response,ResponseError>} a Bluebird Promise\n   * @protected\n   */\n  bearerToken(client) {\n    let emitter = new EventEmitter();\n    let promise = this.promise(emitter);\n    this.emitOrLoadAccessToken(client, emitter);\n    return promise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Builds a Bluebird promise to be returned to the API user\n   *\n   * @param  {type} emitter the EventEmitter used to notify the Promise of\n   * @return {Promise} a Bluebird promise\n   * @private\n   */\n  promise(emitter) {\n    return new Promise((resolve, reject) => {\n      emitter.on('resolve', response => resolve(response));\n      emitter.on('reject', error => reject(error));\n    });\n  }\n\n\n  /**\n   * Checks if the token needs a refresh, if not emits the cached token,\n   * otherwise tries to load a new access token\n   *\n   * @param  {Client} client the Amadeus Client to make an API call with\n   * @param  {type} emitter the EventEmitter used to emit the token\n   * @private\n   */\n  emitOrLoadAccessToken(client, emitter) {\n    if (this.needsLoadOrRefresh()) { this.loadAccessToken(client, emitter); }\n    else { emitter.emit('resolve', this.accessToken); }\n  }\n\n  /**\n   * Checks if the token needs a refresh or first load\n   *\n   * @return {boolean} wether the token needs a refresh\n   * @private\n   */\n  needsLoadOrRefresh() {\n    if (!this.accessToken) { return true; }\n    else if ((Date.now() + TOKEN_BUFFER) > this.expiresAt) { return true; }\n    else { return false; }\n  }\n\n\n  /**\n   * Loads the access token using the client, emits the token when it's loaded\n   *\n   * @param  {Client} client the Amadeus Client to make an API call with\n   * @param  {type} emitter the EventEmitter used to emit the token\n   * @private\n   */\n  loadAccessToken(client, emitter) {\n    client.unauthenticatedRequest('POST', '/v1/security/oauth2/token', {\n      'grant_type' : 'client_credentials',\n      'client_id' : client.clientId,\n      'client_secret' : client.clientSecret\n    }).then((response) => {\n      this.storeAccessToken(response);\n      this.emitOrLoadAccessToken(client, emitter);\n    }).catch((error) => {\n      emitter.emit('reject', error);\n    });\n  }\n\n  /**\n   * Stores a loaded access token, calculating the expiry date\n   *\n   * @param  {Response} response the response object received from the client\n   * @private\n   */\n  storeAccessToken(response) {\n    this.accessToken = response.result['access_token'];\n    this.expiresAt = Date.now() + (response.result['expires_in'] * 1000);\n  }\n}\n\nexport default AccessToken;\n"]},"metadata":{},"sourceType":"script"}
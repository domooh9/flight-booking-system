{"ast":null,"code":"// this file is a modified version of the code in node 17.2.0\n// which is, in turn, a modified version of the fs-extra module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\n'use strict';\n\nconst {\n  ERR_FS_CP_DIR_TO_NON_DIR,\n  ERR_FS_CP_EEXIST,\n  ERR_FS_CP_EINVAL,\n  ERR_FS_CP_FIFO_PIPE,\n  ERR_FS_CP_NON_DIR_TO_DIR,\n  ERR_FS_CP_SOCKET,\n  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n  ERR_FS_CP_UNKNOWN,\n  ERR_FS_EISDIR,\n  ERR_INVALID_ARG_TYPE\n} = require('../errors.js');\n\nconst {\n  constants: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR\n    }\n  }\n} = require('os');\n\nconst {\n  chmod,\n  copyFile,\n  lstat,\n  mkdir,\n  readdir,\n  readlink,\n  stat,\n  symlink,\n  unlink,\n  utimes\n} = require('../fs.js');\n\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve,\n  sep,\n  toNamespacedPath\n} = require('path');\n\nconst {\n  fileURLToPath\n} = require('url');\n\nconst defaultOptions = {\n  dereference: false,\n  errorOnExist: false,\n  filter: undefined,\n  force: true,\n  preserveTimestamps: false,\n  recursive: false\n};\n\nasync function cp(src, dest, opts) {\n  if (opts != null && typeof opts !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts);\n  }\n\n  return cpFn(toNamespacedPath(getValidatedPath(src)), toNamespacedPath(getValidatedPath(dest)), { ...defaultOptions,\n    ...opts\n  });\n}\n\nfunction getValidatedPath(fileURLOrPath) {\n  const path = fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath;\n  return path;\n}\n\nasync function cpFn(src, dest, opts) {\n  // Warn about using preserveTimestamps on 32-bit node\n  // istanbul ignore next\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    const warning = 'Using the preserveTimestamps option in 32-bit ' + 'node is not recommended';\n    process.emitWarning(warning, 'TimestampPrecisionWarning');\n  }\n\n  const stats = await checkPaths(src, dest, opts);\n  const {\n    srcStat,\n    destStat\n  } = stats;\n  await checkParentPaths(src, srcStat, dest);\n\n  if (opts.filter) {\n    return handleFilter(checkParentDir, destStat, src, dest, opts);\n  }\n\n  return checkParentDir(destStat, src, dest, opts);\n}\n\nasync function checkPaths(src, dest, opts) {\n  const {\n    0: srcStat,\n    1: destStat\n  } = await getStats(src, dest, opts);\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: 'src and dest cannot be the same',\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new ERR_FS_CP_DIR_TO_NON_DIR({\n        message: `cannot overwrite directory ${src} ` + `with non-directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EISDIR\n      });\n    }\n\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new ERR_FS_CP_NON_DIR_TO_DIR({\n        message: `cannot overwrite non-directory ${src} ` + `with directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: ENOTDIR\n      });\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  }\n\n  return {\n    srcStat,\n    destStat\n  };\n}\n\nfunction areIdentical(srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n}\n\nfunction getStats(src, dest, opts) {\n  const statFunc = opts.dereference ? file => stat(file, {\n    bigint: true\n  }) : file => lstat(file, {\n    bigint: true\n  });\n  return Promise.all([statFunc(src), statFunc(dest).catch(err => {\n    // istanbul ignore next: unsure how to cover.\n    if (err.code === 'ENOENT') {\n      return null;\n    } // istanbul ignore next: unsure how to cover.\n\n\n    throw err;\n  })]);\n}\n\nasync function checkParentDir(destStat, src, dest, opts) {\n  const destParent = dirname(dest);\n  const dirExists = await pathExists(destParent);\n\n  if (dirExists) {\n    return getStatsForCopy(destStat, src, dest, opts);\n  }\n\n  await mkdir(destParent, {\n    recursive: true\n  });\n  return getStatsForCopy(destStat, src, dest, opts);\n}\n\nfunction pathExists(dest) {\n  return stat(dest).then(() => true, // istanbul ignore next: not sure when this would occur\n  err => err.code === 'ENOENT' ? false : Promise.reject(err));\n} // Recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\n\n\nasync function checkParentPaths(src, srcStat, dest) {\n  const srcParent = resolve(dirname(src));\n  const destParent = resolve(dirname(dest));\n\n  if (destParent === srcParent || destParent === parse(destParent).root) {\n    return;\n  }\n\n  let destStat;\n\n  try {\n    destStat = await stat(destParent, {\n      bigint: true\n    });\n  } catch (err) {\n    // istanbul ignore else: not sure when this would occur\n    if (err.code === 'ENOENT') {\n      return;\n    } // istanbul ignore next: not sure when this would occur\n\n\n    throw err;\n  }\n\n  if (areIdentical(srcStat, destStat)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  }\n\n  return checkParentPaths(src, srcStat, destParent);\n}\n\nconst normalizePathToArray = path => resolve(path).split(sep).filter(Boolean); // Return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\n\n\nfunction isSrcSubdir(src, dest) {\n  const srcArr = normalizePathToArray(src);\n  const destArr = normalizePathToArray(dest);\n  return srcArr.every((cur, i) => destArr[i] === cur);\n}\n\nasync function handleFilter(onInclude, destStat, src, dest, opts, cb) {\n  const include = await opts.filter(src, dest);\n\n  if (include) {\n    return onInclude(destStat, src, dest, opts, cb);\n  }\n}\n\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter) {\n    return handleFilter(getStatsForCopy, destStat, src, dest, opts);\n  }\n\n  return getStatsForCopy(destStat, src, dest, opts);\n}\n\nasync function getStatsForCopy(destStat, src, dest, opts) {\n  const statFn = opts.dereference ? stat : lstat;\n  const srcStat = await statFn(src); // istanbul ignore else: can't portably test FIFO\n\n  if (srcStat.isDirectory() && opts.recursive) {\n    return onDir(srcStat, destStat, src, dest, opts);\n  } else if (srcStat.isDirectory()) {\n    throw new ERR_FS_EISDIR({\n      message: `${src} is a directory (not copied)`,\n      path: src,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {\n    return onFile(srcStat, destStat, src, dest, opts);\n  } else if (srcStat.isSymbolicLink()) {\n    return onLink(destStat, src, dest);\n  } else if (srcStat.isSocket()) {\n    throw new ERR_FS_CP_SOCKET({\n      message: `cannot copy a socket file: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  } else if (srcStat.isFIFO()) {\n    throw new ERR_FS_CP_FIFO_PIPE({\n      message: `cannot copy a FIFO pipe: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  } // istanbul ignore next: should be unreachable\n\n\n  throw new ERR_FS_CP_UNKNOWN({\n    message: `cannot copy an unknown file type: ${dest}`,\n    path: dest,\n    syscall: 'cp',\n    errno: EINVAL\n  });\n}\n\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return _copyFile(srcStat, src, dest, opts);\n  }\n\n  return mayCopyFile(srcStat, src, dest, opts);\n}\n\nasync function mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.force) {\n    await unlink(dest);\n    return _copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new ERR_FS_CP_EEXIST({\n      message: `${dest} already exists`,\n      path: dest,\n      syscall: 'cp',\n      errno: EEXIST\n    });\n  }\n}\n\nasync function _copyFile(srcStat, src, dest, opts) {\n  await copyFile(src, dest);\n\n  if (opts.preserveTimestamps) {\n    return handleTimestampsAndMode(srcStat.mode, src, dest);\n  }\n\n  return setDestMode(dest, srcStat.mode);\n}\n\nasync function handleTimestampsAndMode(srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    await makeFileWritable(dest, srcMode);\n    return setDestTimestampsAndMode(srcMode, src, dest);\n  }\n\n  return setDestTimestampsAndMode(srcMode, src, dest);\n}\n\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\n\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200);\n}\n\nasync function setDestTimestampsAndMode(srcMode, src, dest) {\n  await setDestTimestamps(src, dest);\n  return setDestMode(dest, srcMode);\n}\n\nfunction setDestMode(dest, srcMode) {\n  return chmod(dest, srcMode);\n}\n\nasync function setDestTimestamps(src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = await stat(src);\n  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n}\n\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  }\n\n  return copyDir(src, dest, opts);\n}\n\nasync function mkDirAndCopy(srcMode, src, dest, opts) {\n  await mkdir(dest);\n  await copyDir(src, dest, opts);\n  return setDestMode(dest, srcMode);\n}\n\nasync function copyDir(src, dest, opts) {\n  const dir = await readdir(src);\n\n  for (let i = 0; i < dir.length; i++) {\n    const item = dir[i];\n    const srcItem = join(src, item);\n    const destItem = join(dest, item);\n    const {\n      destStat\n    } = await checkPaths(srcItem, destItem, opts);\n    await startCopy(destStat, srcItem, destItem, opts);\n  }\n}\n\nasync function onLink(destStat, src, dest) {\n  let resolvedSrc = await readlink(src);\n\n  if (!isAbsolute(resolvedSrc)) {\n    resolvedSrc = resolve(dirname(src), resolvedSrc);\n  }\n\n  if (!destStat) {\n    return symlink(resolvedSrc, dest);\n  }\n\n  let resolvedDest;\n\n  try {\n    resolvedDest = await readlink(dest);\n  } catch (err) {\n    // Dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    // istanbul ignore next: can only test on windows\n    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {\n      return symlink(resolvedSrc, dest);\n    } // istanbul ignore next: should not be possible\n\n\n    throw err;\n  }\n\n  if (!isAbsolute(resolvedDest)) {\n    resolvedDest = resolve(dirname(dest), resolvedDest);\n  }\n\n  if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` + `${resolvedDest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  } // Do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n\n\n  const srcStat = await stat(src);\n\n  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  }\n\n  return copyLink(resolvedSrc, dest);\n}\n\nasync function copyLink(resolvedSrc, dest) {\n  await unlink(dest);\n  return symlink(resolvedSrc, dest);\n}\n\nmodule.exports = cp;","map":{"version":3,"sources":["/home/dom/Videos/FlyM/node_modules/@npmcli/fs/lib/cp/polyfill.js"],"names":["ERR_FS_CP_DIR_TO_NON_DIR","ERR_FS_CP_EEXIST","ERR_FS_CP_EINVAL","ERR_FS_CP_FIFO_PIPE","ERR_FS_CP_NON_DIR_TO_DIR","ERR_FS_CP_SOCKET","ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY","ERR_FS_CP_UNKNOWN","ERR_FS_EISDIR","ERR_INVALID_ARG_TYPE","require","constants","errno","EEXIST","EISDIR","EINVAL","ENOTDIR","chmod","copyFile","lstat","mkdir","readdir","readlink","stat","symlink","unlink","utimes","dirname","isAbsolute","join","parse","resolve","sep","toNamespacedPath","fileURLToPath","defaultOptions","dereference","errorOnExist","filter","undefined","force","preserveTimestamps","recursive","cp","src","dest","opts","cpFn","getValidatedPath","fileURLOrPath","path","href","origin","process","arch","warning","emitWarning","stats","checkPaths","srcStat","destStat","checkParentPaths","handleFilter","checkParentDir","getStats","areIdentical","message","syscall","isDirectory","isSrcSubdir","ino","dev","statFunc","file","bigint","Promise","all","catch","err","code","destParent","dirExists","pathExists","getStatsForCopy","then","reject","srcParent","root","normalizePathToArray","split","Boolean","srcArr","destArr","every","cur","i","onInclude","cb","include","startCopy","statFn","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","isFIFO","_copyFile","mayCopyFile","handleTimestampsAndMode","mode","setDestMode","srcMode","fileIsNotWritable","makeFileWritable","setDestTimestampsAndMode","setDestTimestamps","updatedSrcStat","atime","mtime","mkDirAndCopy","copyDir","dir","length","item","srcItem","destItem","resolvedSrc","resolvedDest","copyLink","module","exports"],"mappings":"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","sourcesContent":["// this file is a modified version of the code in node 17.2.0\n// which is, in turn, a modified version of the fs-extra module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\n'use strict'\n\nconst {\n  ERR_FS_CP_DIR_TO_NON_DIR,\n  ERR_FS_CP_EEXIST,\n  ERR_FS_CP_EINVAL,\n  ERR_FS_CP_FIFO_PIPE,\n  ERR_FS_CP_NON_DIR_TO_DIR,\n  ERR_FS_CP_SOCKET,\n  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n  ERR_FS_CP_UNKNOWN,\n  ERR_FS_EISDIR,\n  ERR_INVALID_ARG_TYPE,\n} = require('../errors.js')\nconst {\n  constants: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR,\n    },\n  },\n} = require('os')\nconst {\n  chmod,\n  copyFile,\n  lstat,\n  mkdir,\n  readdir,\n  readlink,\n  stat,\n  symlink,\n  unlink,\n  utimes,\n} = require('../fs.js')\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve,\n  sep,\n  toNamespacedPath,\n} = require('path')\nconst { fileURLToPath } = require('url')\n\nconst defaultOptions = {\n  dereference: false,\n  errorOnExist: false,\n  filter: undefined,\n  force: true,\n  preserveTimestamps: false,\n  recursive: false,\n}\n\nasync function cp (src, dest, opts) {\n  if (opts != null && typeof opts !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts)\n  }\n  return cpFn(\n    toNamespacedPath(getValidatedPath(src)),\n    toNamespacedPath(getValidatedPath(dest)),\n    { ...defaultOptions, ...opts })\n}\n\nfunction getValidatedPath (fileURLOrPath) {\n  const path = fileURLOrPath != null && fileURLOrPath.href\n      && fileURLOrPath.origin\n    ? fileURLToPath(fileURLOrPath)\n    : fileURLOrPath\n  return path\n}\n\nasync function cpFn (src, dest, opts) {\n  // Warn about using preserveTimestamps on 32-bit node\n  // istanbul ignore next\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    const warning = 'Using the preserveTimestamps option in 32-bit ' +\n      'node is not recommended'\n    process.emitWarning(warning, 'TimestampPrecisionWarning')\n  }\n  const stats = await checkPaths(src, dest, opts)\n  const { srcStat, destStat } = stats\n  await checkParentPaths(src, srcStat, dest)\n  if (opts.filter) {\n    return handleFilter(checkParentDir, destStat, src, dest, opts)\n  }\n  return checkParentDir(destStat, src, dest, opts)\n}\n\nasync function checkPaths (src, dest, opts) {\n  const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts)\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: 'src and dest cannot be the same',\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL,\n      })\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new ERR_FS_CP_DIR_TO_NON_DIR({\n        message: `cannot overwrite directory ${src} ` +\n            `with non-directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EISDIR,\n      })\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new ERR_FS_CP_NON_DIR_TO_DIR({\n        message: `cannot overwrite non-directory ${src} ` +\n            `with directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: ENOTDIR,\n      })\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return { srcStat, destStat }\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino &&\n    destStat.dev === srcStat.dev\n}\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference ?\n    (file) => stat(file, { bigint: true }) :\n    (file) => lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch((err) => {\n      // istanbul ignore next: unsure how to cover.\n      if (err.code === 'ENOENT') {\n        return null\n      }\n      // istanbul ignore next: unsure how to cover.\n      throw err\n    }),\n  ])\n}\n\nasync function checkParentDir (destStat, src, dest, opts) {\n  const destParent = dirname(dest)\n  const dirExists = await pathExists(destParent)\n  if (dirExists) {\n    return getStatsForCopy(destStat, src, dest, opts)\n  }\n  await mkdir(destParent, { recursive: true })\n  return getStatsForCopy(destStat, src, dest, opts)\n}\n\nfunction pathExists (dest) {\n  return stat(dest).then(\n    () => true,\n    // istanbul ignore next: not sure when this would occur\n    (err) => (err.code === 'ENOENT' ? false : Promise.reject(err)))\n}\n\n// Recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nasync function checkParentPaths (src, srcStat, dest) {\n  const srcParent = resolve(dirname(src))\n  const destParent = resolve(dirname(dest))\n  if (destParent === srcParent || destParent === parse(destParent).root) {\n    return\n  }\n  let destStat\n  try {\n    destStat = await stat(destParent, { bigint: true })\n  } catch (err) {\n    // istanbul ignore else: not sure when this would occur\n    if (err.code === 'ENOENT') {\n      return\n    }\n    // istanbul ignore next: not sure when this would occur\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return checkParentPaths(src, srcStat, destParent)\n}\n\nconst normalizePathToArray = (path) =>\n  resolve(path).split(sep).filter(Boolean)\n\n// Return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = normalizePathToArray(src)\n  const destArr = normalizePathToArray(dest)\n  return srcArr.every((cur, i) => destArr[i] === cur)\n}\n\nasync function handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  const include = await opts.filter(src, dest)\n  if (include) {\n    return onInclude(destStat, src, dest, opts, cb)\n  }\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter) {\n    return handleFilter(getStatsForCopy, destStat, src, dest, opts)\n  }\n  return getStatsForCopy(destStat, src, dest, opts)\n}\n\nasync function getStatsForCopy (destStat, src, dest, opts) {\n  const statFn = opts.dereference ? stat : lstat\n  const srcStat = await statFn(src)\n  // istanbul ignore else: can't portably test FIFO\n  if (srcStat.isDirectory() && opts.recursive) {\n    return onDir(srcStat, destStat, src, dest, opts)\n  } else if (srcStat.isDirectory()) {\n    throw new ERR_FS_EISDIR({\n      message: `${src} is a directory (not copied)`,\n      path: src,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  } else if (srcStat.isFile() ||\n            srcStat.isCharacterDevice() ||\n            srcStat.isBlockDevice()) {\n    return onFile(srcStat, destStat, src, dest, opts)\n  } else if (srcStat.isSymbolicLink()) {\n    return onLink(destStat, src, dest)\n  } else if (srcStat.isSocket()) {\n    throw new ERR_FS_CP_SOCKET({\n      message: `cannot copy a socket file: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  } else if (srcStat.isFIFO()) {\n    throw new ERR_FS_CP_FIFO_PIPE({\n      message: `cannot copy a FIFO pipe: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  // istanbul ignore next: should be unreachable\n  throw new ERR_FS_CP_UNKNOWN({\n    message: `cannot copy an unknown file type: ${dest}`,\n    path: dest,\n    syscall: 'cp',\n    errno: EINVAL,\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return _copyFile(srcStat, src, dest, opts)\n  }\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nasync function mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.force) {\n    await unlink(dest)\n    return _copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new ERR_FS_CP_EEXIST({\n      message: `${dest} already exists`,\n      path: dest,\n      syscall: 'cp',\n      errno: EEXIST,\n    })\n  }\n}\n\nasync function _copyFile (srcStat, src, dest, opts) {\n  await copyFile(src, dest)\n  if (opts.preserveTimestamps) {\n    return handleTimestampsAndMode(srcStat.mode, src, dest)\n  }\n  return setDestMode(dest, srcStat.mode)\n}\n\nasync function handleTimestampsAndMode (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    await makeFileWritable(dest, srcMode)\n    return setDestTimestampsAndMode(srcMode, src, dest)\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nasync function setDestTimestampsAndMode (srcMode, src, dest) {\n  await setDestTimestamps(src, dest)\n  return setDestMode(dest, srcMode)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return chmod(dest, srcMode)\n}\n\nasync function setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = await stat(src)\n  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  }\n  return copyDir(src, dest, opts)\n}\n\nasync function mkDirAndCopy (srcMode, src, dest, opts) {\n  await mkdir(dest)\n  await copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nasync function copyDir (src, dest, opts) {\n  const dir = await readdir(src)\n  for (let i = 0; i < dir.length; i++) {\n    const item = dir[i]\n    const srcItem = join(src, item)\n    const destItem = join(dest, item)\n    const { destStat } = await checkPaths(srcItem, destItem, opts)\n    await startCopy(destStat, srcItem, destItem, opts)\n  }\n}\n\nasync function onLink (destStat, src, dest) {\n  let resolvedSrc = await readlink(src)\n  if (!isAbsolute(resolvedSrc)) {\n    resolvedSrc = resolve(dirname(src), resolvedSrc)\n  }\n  if (!destStat) {\n    return symlink(resolvedSrc, dest)\n  }\n  let resolvedDest\n  try {\n    resolvedDest = await readlink(dest)\n  } catch (err) {\n    // Dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    // istanbul ignore next: can only test on windows\n    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {\n      return symlink(resolvedSrc, dest)\n    }\n    // istanbul ignore next: should not be possible\n    throw err\n  }\n  if (!isAbsolute(resolvedDest)) {\n    resolvedDest = resolve(dirname(dest), resolvedDest)\n  }\n  if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` +\n            `${resolvedDest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  // Do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  const srcStat = await stat(src)\n  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return copyLink(resolvedSrc, dest)\n}\n\nasync function copyLink (resolvedSrc, dest) {\n  await unlink(dest)\n  return symlink(resolvedSrc, dest)\n}\n\nmodule.exports = cp\n"]},"metadata":{},"sourceType":"script"}